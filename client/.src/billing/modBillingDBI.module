' Gambas module file

' Copyright (C) 2008-2012 Dr. Richard Terry  rterry@pacific.net.au Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'--------------------- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
' Billing Stuff
'-------------------------------------------------------------------------------

' searches on the schedule of items
' "descriptor" can be words in the descriptor text
' OR a umber: gets by Medicare item number
' OR letters and numbers together: searches by AMA item number
' use_vwfees: true if uses vwfees view (recommended for most uses below)
' 
Public Function Fee_Schedule_Import_From_Pracsoft()
   
   'only used by richard during development
   ' 
   'ItemNo|Description|OpRule|DerivedFee|Deleted|TaxRate|ReportGroup|SchedFee|Rebate85|Rebate75|VetFee|VetLMO|AMAFee|User1|User2|User3|User4|User5|User6|User7|User8|User9|User10|User11|User12|User13|User14|ID
   ' 0            1     2        3        4        5        6           7        8        9        10    11    12       13 
   ' field 16 is private
   ' CREATE TABLE billing.prices
   ' (
   '   pk serial NOT NULL,
   '   fk_fee_schedule integer NOT NULL,
   '   price money NOT NULL DEFAULT '$0.00'::money, -- the price to the patient
   '   fk_lu_billing_type integer NOT NULL,
   '   notes text,
   '   CONSTRAINT prices_pkey PRIMARY KEY (pk ),
   '   CONSTRAINT prices_fk_fee_schedule_fkey FOREIGN KEY (fk_fee_schedule)
   '       REFERENCES billing.fee_schedule (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '   CONSTRAINT prices_fk_lu_billing_type_fkey FOREIGN KEY (fk_lu_billing_type)
   '       REFERENCES billing.lu_billing_type (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION
   ' )
   ' WITH (
   '   OIDS=FALSE
   ' );
   
   ' Public Const Billingtype_AMA As Integer = 1
   ' Public Const Billingtype_DVA_Non_LM0 As Integer = 2
   ' Public Const Billingtype_DVA_LM0 As Integer = 3
   ' Public Const Billingtype_Health_Care_Card_Concession As Integer = 4
   ' Public Const Billingtype_Pensioner_Concession As Integer = 5
   ' Public Const Billingtype_Private As Integer = 6
   ' Public Const  set"Billingtype_Transport_Accident_Commision_Victoria As Integer = 7
   ' Public Const Billingtype_Scheduled_Fee As Integer = 8
   ' 
   
   Dim hFile As File
   Dim soneline As String
   Dim Fee_Info As String[]
   Dim all_Fees As New Collection
   Dim Fields As String[]
   Dim x As Integer
   Dim y As Integer
   Dim item As New CRow  
   Dim sql As String
   Dim R As Result
   Dim price As CRow
   Dim fk_fee_schedule As Integer
   Dim unsaved_fees As New Collection 
   Dim sql_insert As String
   Dim hSqlFile As File
   
   hFile = Open "/home/richard/FEES.txt" For Read
   hSqlFile = Open "/home/richard/fee_update.sql" For Write Create
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      If x = 0 Then
         Fields = Split(sOneLine, " |")
      Else   
         Fee_Info = Split(sOneLine, "|")
         Item!number = Fee_info[0]
         sql = "Select * from billing.fee_schedule where mbs_item = $$" & Trim(Fee_info[0]) & "$$"
         R = modDBConnect.exec_query(sql)
         If R.count Then
            fk_fee_schedule = R!pk
            Item!description = Fee_info[1]
            Item!deleted = Fee_info[4]
            Item!gst = Fee_info[5]
            Item!vet_fee_non_lmo = Fee_info[10]
            Item!vet_fee_lmo = Fee_info[11]
            item!private_fee = Fee_info[16]
            If Fee_Info[0] = 23 Then
               Print Fee_Info
               item!private_fee = Fee_info[16]
            Endif  
            '--------------------------
            'Save the private fee level
            '--------------------------
            If Not IsNull(item!private_fee) Then 
               price = New CRow  
               price!fk_fee_schedule = fk_fee_schedule
               price!price = item!private_fee
               price!fk_lu_billing_type = const.Billingtype_Private
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, item!private_fee, const.Billingtype_Private) & ");"
               Print #hSqlFile, sql
            End If   
            '------------------------------
            'Save the dva non LMO fee level
            '------------------------------
            If Not IsNull(Item!vet_fee_non_lmo) Then 
               price = New CRow  
               price!fk_fee_schedule = fk_fee_schedule
               price!price = Item!vet_fee_non_lmo
               price!fk_lu_billing_type = const.Billingtype_DVA_Non_LM0
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, Item!vet_fee_non_lmo, const.Billingtype_DVA_Non_LM0) & ");"
               Print #hSqlFile, sql
            End If  
            '--------------------------
            'Save the dva LMO fee level
            '--------------------------
            If Not IsNull(Item!vet_fee_lmo) Then 
               price = New CRow  
               price!fk_fee_schedule = fk_fee_schedule
               price!price = Item!vet_fee_lmo
               price!fk_lu_billing_type = const.Billingtype_DVA_LM0
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, Item!vet_fee_lmo, const.Billingtype_DVA_LM0) & ");"
               Print #hSqlFile, sql
            End If   
         Else
            unsaved_fees.Add(Fee_Info, unsaved_fees.count)
            sql_insert = "insert into billing.fee_schedule (descriptor, mbs_item, group) values ($$"
            sql_insert &= Fee_info[1] & "$$,$$" & 3 & "$$,$$" & "$$A1$$)"
            ' insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values (currval('billing.fee_schedule_pk_seq'),'16.30',3);
            ' 
            
         End If  
      End If 
      all_Fees.Add(Fee_Info, all_Fees.count)
      Inc x
   Wend
   Print unsaved_fees
   ' modDBConnect.CommitTrans()
   Message.Info("Finished")
   Close #hFile
   Close #HsqlFile
   Print all_Fees
   
End

Public Function Responsible_Payer_Get(fk_patient As Integer) As Collection
   'fixme this is temporary, only works if the patient has another patient as responsible person
   'just doing this for development stuff
   
   Dim R As Result
   
   R = modDBConnect.exec_query("Select * from clerical.data_patients where pk = " & fk_patient)
   If r.count Then
      If r!fk_payer Then
         Return modContactsDBI.Patient_Get_Using_PK(r!fk_payer)
      End If   
   End If   
   
End

Public Function Consultations_UnBilled_Get() As Collection
   '--------------------------------------------------------------------
   'returns a collection of all unbilled consultations
   'A consultation is is determined as unbilled if
   'a) The appointment is marked completed in the waiting room list and
   'b) The invoiced flag is false
   'c) They actually did attend
   '--------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from clerical.vwAppointments where invoiced = false and did_not_attend = false "
   sql &= "And fk_patient Is Not Null "
   sql &= "And fk_lu_appointment_status = " & const.Appointment_Status_Completed
   Return modDBConnect.exec_query_collection(sql)
   
End

' 
Public Function Veteran_Card_Types_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from clerical.lu_veteran_card_type")
   
End

Public Function Centrelink_Card_Types_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from clerical.lu_centrelink_card_type")
   
End

Public Function Health_Funds_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from clerical.lu_private_health_funds")
   
End

Public Function Billing_Types_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from billing.lu_billing_type")
   
End

Public Function Billing_Level_Get() As Collection
   '-------------------------------------------------------------------------------
   'The levels of billing available for a patient eg bulk bill, private, concession
   '-------------------------------------------------------------------------------  
   
   Return modDBConnect.exec_query_collection("Select * from billing.lu_default_billing_level order by level")
   
End

Public Function Payment_Methods_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from billing.lu_payment_method") 
   
End

Public Function Invoice_Comments_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from billing.lu_invoice_comments order by comment") 
   
End

Public Function Descriptors_Get(descriptor As String, Optional include_ama As Boolean = True, use_vwfees As Boolean = True, Optional limit As Integer = 500) As Collection
   
   Dim sql As String
   Dim searchcomponents As New String[]
   Dim component As String
   Dim i As Integer
   Dim r As Regexp
   
   If use_vwfees Then
      sql = "billing.vwfees"
   Else
      sql = "billing.fee_schedule"
   Endif
   sql = "Select * from " & sql & " where "
   r = New Regexp(descriptor, "^[0-9]+$")
   If r.Offset <> -1 Then 
      sql &= "mbs_item = '" & descriptor & "'"
   Else 
      r = New Regexp(descriptor, "^[a-z]+[0-9]+$", Regexp.Caseless)
      If r.Offset <> -1 And include_ama Then
         sql &= "ama_item = '" & descriptor & "'"
      Else
         searchcomponents = Split(descriptor, ",")
         For i = 0 To searchcomponents.Max
            searchcomponents[i] = "descriptor ILIKE $$%" & Trim$(searchcomponents[i]) & "%$$"
         Next
         sql &= searchcomponents.Join(" AND ")
      End If
   End If
   If Not include_ama Then
      sql &= " and not mbs_item is null"
   End If
   sql &= " order by cast(mbs_item as int), descriptor   LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End
' saves a changed schedule descriptor

Public Function Descriptors_Save(old_data As Collection, pk_descriptor As Integer, new_data As Collection)
   
   If pk_descriptor = -1 Then
      
   Else
      modDBConnect.update("billing.fee_schedule", old_data[pk_descriptor], new_data)
   End If  
   
End

Public Function Fees_Get_For_Descriptor(fk_fee_schedule As Integer) As Collection
   
   Dim sql As String
   
   sql = "Select * from billing.vwFees where fk_fee_schedule=" & fk_fee_schedule
   Return modDBConnect.exec_query_collection(sql) 
   
End

' returns a list of all fee types
Public Function Fee_Types_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from billing.lu_billing_type order by type")  'fixme fix schema to be type
   
End

Public Function fk_fee_shedule_Get_For_Item_Number(item As String) As Integer
   'this is temporary and will need trashing
    Dim R As Result
    Dim sql As String
    
    sql = "Select * From billing.fee_schedule where mbs_item =$$" & item & "$$"
    R = modDBConnect.exec_query(sql)
    If R.count Then
       Return R!pk
    Else
       Message.Info("This should never happen - couldn't find the item numbers primary key")
       
    Endif
    
   
End

' returns schedule entries searching by brief descriptor 
Public Function Descriptors_Brief_Get(searchtext As String, Optional limit As Integer = 100) As Collection 
   
   Dim sql As String
   
   sql = "Select * from billing.fee_schedule where descriptor_brief ILIKE $$%" & searchtext
   sql &= "%$$ order by cast(mbs_item as int), descriptor LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End

' Public Function Scheduled_Fee_Get(item As String) As Collection
'    '-----------------------------------------------------------------------------------------------
'    'Returns just the scheduled fee to allow display of the gap's when various fee levels are chosen
'    '-----------------------------------------------------------------------------------------------
'    Dim sql As String
'    
'    sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$)" 
'    sql &= " and fk_lu_billing_type = " & const.Billingtype_Scheduled_Fee
'    Return modDBConnect.exec_query_first(sql)
'    
' End

Public Function Fee_Get_For_Item_And_Billing_Type(item As String, fk_lu_billing_type As Integer) As Collection
   'Returns the billing.price for a particular item number for a particular billing type e.g Private
    Dim sql As String
   
   sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$)" 
   sql &= " and fk_lu_billing_type = " & fk_lu_billing_type
   Return modDBConnect.exec_query_first(sql)
   
End

Public Function Items_Get(item As String, Optional fk_lu_billing_type As Integer = -1) As Collection
   '---------------------------------------------
   'Gets list of item numbers and associated fees
   '---------------------------------------------
   
   Dim sql As String
   
   sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$)"
   If fk_lu_billing_type <> -1 Then
      sql &= " and fk_lu_billing_type = " & fk_lu_billing_type
   Endif
   Return modDBConnect.exec_query_collection(sql)
   
End

' makes a new invoice on the backend
' NOTE: "invoice" is the arbitrary easygp internal term  and is not legally correct
' what gets spit out at the end is technically a "account receipt" for private billing and 
' a "voucher" when bulk-billing
' also saves also the items billed
' items: array of Collections. Collections should orginate from billing.vwFees (must have a fk_fee_schedule and price fields)
' if price is changed from what's in the schedule can add a patient_charge field too
' if fk_staff is zero uses current logged in staff as the billing doctor
' fk_lu_billing_type is the billing type (some values in const)
' returns the PK of the new invoice

' Public Sub Make_Invoice(pk_patient As Integer, items As Collection[], fk_lu_billing_type As Integer, date_printed As Date Default Null, fk_staff As Integer = 0, Optional notes As String) As Integer
'    ' CREATE TABLE billing.invoices
'    ' (
'    '   pk serial NOT NULL,
'    '   fk_staff_invoicing integer NOT NULL, -- the staff member raising the invoice
'    '   date_printed timestamp without time zone,
'    '   notes text,
'    '   fk_lu_billing_type integer NOT NULL,
'    '   fk_staff_provided_service integer NOT NULL, -- the staff member who provider the service on which the invoice is based
'    '   fk_patient integer,
'    '   date_invoiced timestamp without time zone NOT NULL DEFAULT now(),
'    '   paid boolean NOT NULL DEFAULT false,
'    '   CONSTRAINT invoices_pkey PRIMARY KEY (pk ),
'    '   CONSTRAINT invoices_fk_doctor_raising_fkey FOREIGN KEY (fk_staff_provided_service)
'    '       REFERENCES admin.staff (pk) MATCH SIMPLE
'    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
'    '   CONSTRAINT invoices_fk_lu_billing_type_fkey FOREIGN KEY (fk_lu_billing_type)
'    '       REFERENCES billing.lu_billing_type (pk) MATCH SIMPLE
'    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
'    '   CONSTRAINT invoices_fk_patient_fkey FOREIGN KEY (fk_patient)
'    '       REFERENCES clerical.data_patients (pk) MATCH SIMPLE
'    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
'    '   CONSTRAINT invoices_fk_staff_invoicing_fkey FOREIGN KEY (fk_staff_invoicing)
'    '       REFERENCES admin.staff (pk) MATCH SIMPLE
'    '       ON UPDATE NO ACTION ON DELETE NO ACTION
'    ' )
'    ' WITH (
'    '   OIDS=FALSE
'    ' );
'    
'    Dim invoice As New Collection
'    Dim i As Collection
'    Dim new_item As Collection
'    
'    If fk_staff = 0 Then
'       fk_staff = modDBConnect.currentUser!fk_staff
'    Endif
'    If Not IsNull(date_printed) Then
'       invoice!date_printed = date_printed 
'    Endif
'    invoice!fk_staff_invoicing = fk_staff
'    invoice!notes = notes
'    invoice!fk_lu_billing_type = fk_lu_billing_type
'    invoice!fk_patient = pk_patient
'    invoice!pk = modDBConnect.insert("billing.invoices", invoice)
'    Save_Items(invoice!pk, items, False)
'    Return invoice!pk
'    
' End

' saves a list of items to an existing invoice
' delete_preexisting is a flag to delete any pre-existing items on that invoice
' useful if saving from an invoice editor
' items is a list of Collections that must have the following members
' - patient_charge: the amont to charge the patient
' (if doesn't exist will use "price" instead, such as when collections come from billing.vwFees in search
' functions above)
' - fk_fee_schedule: link to billing.fee_schedule
' 
Public Sub Save_Items(fk_invoice As Integer, items As Collection[], Optional delete_preexisting As Boolean = True)
   
   Dim i As Collection
   Dim new_item As Collection
   
   If delete_preexisting Then modDBConnect.exec_query("delete from billing.items_billed where fk_invoice = &1", [fk_invoice])
   For Each i In items
      new_item = New Collection
      new_item!fk_invoice = fk_invoice
      new_item!fk_fee_schedule = i!fk_fee_schedule
      If i.Exist("patient_charge") Then
         new_item!patient_charge = i!patient_charge
      Else
         new_item!patient_charge = i!price
         i!patient_charge = i!price
      Endif
      i!pk_item = modDBConnect.insert("billing.items_billed", new_item)
   Next 
   
End

' returns a Collection of all invoices for this patient, most recent first
Public Function Invoices_Get(pk_patient As Integer, Optional limit As Integer = 100) As Collection
   
   Return modDBConnect.exec_query_row("select * from billing.invoices where fk_patient = &1 order by raised desc limit &2", [pk_patient, limit]) 
   
End

' finds a referral for this patient
' returns NULL if they have no referral
' returns a Collection with name, address, provider_number of referrer,
' and "months": length of referral in months, defaults to 12
' and "indefinite" flag true if indefinite referral
' 
Public Function Find_Referrer(fk_patient As Integer) As Collection
   
   Dim sql As String
   
   sql = "with base as (select title, firstname, surname, provider_number, street1, street2, town, state, postcode, date_created, "
   "comment_on_document ~ 'indefin[ia]te' as indefinite, "
   "coalesce(substring(comment_on_document from '([0-9]+) month')::integer,12) as months "
   "from contacts.vwpersonsemployeesbyoccupation vpe, documents.vwdocuments vd"
   " where vd.fk_sender_person = vpe.fk_person and (vd.fk_sender_branch = vpe.fk_branch or (vpe.fk_branch is null and vd.fk_sender_branch is null)) and "
   " vd.fk_patient = &1 and incoming_referral) "
   "select *,date_created+(months*interval '1 month') as expiry from base order by indefinite desc, expiry desc limit 1 "
   Return modDBConnect.exec_query_first(sql, [fk_patient]) 
   
End


Public Function Get_Billed_Items(invoice As Crow) As Collection
   '-------------------------------------------------------------------
   ' returns a list of billed items for a given invoice, as Collections
   ' CREATE TABLE billing.items_billed
   ' (
   '   pk serial NOT NULL,
   '   fk_fee_schedule integer NOT NULL,
   '   amount money NOT NULL,
   '   fk_invoice integer NOT NULL,
   '   fk_lu_billing_type integer NOT NULL);
   '   ?? we already have this, so why recall from the backend, why not just pass?
   '-------------------------------------------------------------------
   Dim sql As String
   ' " left(coalesce(descriptor_brief,descriptor),400) as descriptor_display, "
   sql = "select coalesce(mbs_item,ama_item) as common_item, "
   "  descriptor_brief As Descriptor_display, "
   " * from billing.items_billed i,billing.fee_schedule s where i.fk_fee_schedule = s.pk and i.fk_invoice = &1"
   Return modDBConnect.exec_query_collection(sql, [invoice!fk_invoice])
   
End

' takes a CRow from billing.invoices, from either from Make_Invoice or Invoices_Get, and prints it
' also updates the row on the DB as appropriate
' ' cc is the current consult object. If not provided a new one will be loaded using th invoices's fk_patient.
Public Sub Print_Invoice(invoice As Crow, Optional bBulkBIll As Boolean = False, Optional cc As Cconsult) As String
   '
   Dim sql As String
   Dim items As Collection
   Dim templ As CTemplate
   Dim doctor As Collection
   Dim i As Collection
   Dim referrer_type As String
   Dim latex As String
 
   If IsNull(cc) Then cc = New CConsult(modContactsDBI.Patient_Get_Using_PK(invoice!fk_patient))
   items = Get_Billed_Items(invoice)
   sql = "select referrer_type, s.* from common.lu_occupations o, admin.vwstaffinclinics s "
   "where o.pk = s.fk_occupation and s.fk_staff = &1 limit 1"
   doctor = modDBConnect.exec_query_first(sql, [invoice!fk_staff_provided_service])
   referrer_type = doctor!referrer_type
   If bBulkBIll Then 
      ' cue scary music: patient is being bulk-billed
      ' FIXME: use HIC PDFs to print vouchers
   Else
      If referrer_type = "s" Then
         ' specialist's account: need to grab referrer's details first
         templ = New CTemplate("templates/invoice-specialist.tex", "tex")
         Load_Template_Specialist(templ, invoice)
      Else
         templ = New CTemplate("templates/invoice-gp.tex", "tex")
         Load_Template_GP(templ, doctor, items, cc)
      End If   
      templ.Subst("date-raised", invoice!date_printed) 'FIXME change backend ?back to date_invoiced.
      latex = templ.GetData()
      modPrinting.Print_latex(latex, const.Paper_Plain, 1)
      Return latex   
   Endif
   'sql = "updatebilling.invoices set fk_who_printed=&1, when_printed=now() where pk=&2"
 '  modDBConnect.exec_query(sql, [modDBConnect.currentUser!fk_staff, invoice!pk])
   
End

' loads info about specialist rinvoices (i.e. info about the referral)
Private Sub Load_Template_Specialist(templ As Ctemplate, invoice As Crow) 
   
   Dim referrer As Collection

   
   referrer = Find_Referrer(invoice!fk_patient)
   If IsNull(referrer) Then
      ' uh-oh, we can't find a referral for this patient
      templ.Subst("referrer-name", templ.Bold("NONE"))
      templ.Subst("referrer-street1", templ.Bold("As no referrer there can be NO rebate on this account"))
      templ.Subst("referrer-street2", "")
      templ.Subst("referrer-town", "")
      templ.Subst("referrer-postcode", "")
      templ.Subst("referrer-provider-number", templ.Bold("NONE"))
      templ.Subst("referral-duration", "")
      templ.Subst("referral-date", "")
   Else
      templ.Subst("referrer-name", referrer!title & " " & referrer!firstname & " " & referrer!surname)
      templ.Subst("referrer-street1", referrer!street1)
      templ.Subst("referrer-street2", referrer!street2)
      templ.Subst("referrer-town", referrer!town)
      templ.Subst("referrer-postcode", referrer!postcode)
      templ.Subst("referrer-provider-number", referrer!provider_number)
      If referrer!indefinite Then
         templ.Subst("referral-duration", "indefinite duration")
      Else
         templ.Subst("referral-duration", referrer!months & " months")
      Endif
      templ.Subst("referral-date", referrer!date_created)
   Endif
   
End

' prepares the template with stuff for GP-type invoices (actually common to specialists too)    
Private Function Load_Template_GP(templ As CTemplate, doctor As Collection, items As Collection, cc As CConsult)
   
   Dim i As Collection
   
   templ.Subst("doctor-name", doctor!title & " " & doctor!firstname & " " & doctor!surname)
   templ.Subst("doctor-street1", doctor!street1)
   templ.Subst("doctor-street2", doctor!street2)
   templ.Subst("doctor-town", doctor!town)
   templ.Subst("doctor-postcode", doctor!postcode)
   templ.Subst("doctor-provider-number", doctor!provider_number)
   templ.Subst("current-time", Format$(Now, "dd/mm/yy hh:nn"))
   ' now do the actual items
   For Each i In items
      templ.Row(i!common_item, i!descriptor_display, i!patient_charge)
   Next
   templ.Table("items")
   templ.Subst_common(cc)
   
End

Public Sub UnitTest(main_form As Form)
   ' 
   ' Dim r As Collection
   ' Dim invoice As CRow
   ' Dim item As Collection
   ' 
   ' item = modUtil.Get_One(Descriptors_Get("306", True, True))
   ' 'modDBConnect.exec_query("truncatebilling.invoices cascade")
   ' Make_Invoice(1, [item], 1, "fake invoice", 1)
   ' invoice = modUtil.Get_One(Invoices_Get(1, 1))
   ' Get_Billed_Items(invoice)
   ' Print_Invoice(invoice)
   
End
