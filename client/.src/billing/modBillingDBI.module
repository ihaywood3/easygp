' Gambas module file

' Copyright (C) 2008-2016 Dr. Richard Terry  rterry@internode.on.net Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'-------------------------------------------------------------------------------
' Billing Stuff
'-------------------------------------------------------------------------------

' searches on the schedule of items
' "descriptor" can be words in the descriptor text
' OR a umber: gets by Medicare item number
' OR letters and numbers together: searches by AMA item number
' use_vwfees: true if uses vwfees view (recommended for most uses below)
' NON BILLING TASKS TO DO - BUT IN BUGS FILE
' - concept (help file) if sole trader have 'fake organisation' eg Dr Haywood's Practice + make them employee to get the PN
' - activate the patient picture popping up for Ian (already an option)
' - fix the slowness of checking existing organisations (just go look for organisation/branch) and put on timer
' - FIXME put in hl7 outgoing dir as /var/lib/easygp/hl7_outgoing, ditto the start options for documents, library, hl7_incoming etc
'
Public Function Fee_Schedule_Import_From_Pracsoft()
   
   'only used by richard during development
   '
   'ItemNo|Description|OpRule|DerivedFee|Deleted|TaxRate|ReportGroup|SchedFee|Rebate85|Rebate75|VetFee|VetLMO|AMAFee|User1|User2|User3|User4|User5|User6|User7|User8|User9|User10|User11|User12|User13|User14|ID
   ' 0            1     2        3        4        5        6           7        8        9        10    11    12       13
   ' field 16 is private
   ' CREATE TABLE billing.prices
   ' (
   '   pk serial NOT NULL,
   '   fk_fee_schedule integer NOT NULL,
   '   price money NOT NULL DEFAULT '$0.00'::money, -- the price to the patient
   '   fk_lu_billing_type integer NOT NULL,
   '   notes text,
   '   CONSTRAINT prices_pkey PRIMARY KEY (pk ),
   '   CONSTRAINT prices_fk_fee_schedule_fkey FOREIGN KEY (fk_fee_schedule)
   '       REFERENCES billing.fee_schedule (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '   CONSTRAINT prices_fk_lu_billing_type_fkey FOREIGN KEY (fk_lu_billing_type)
   '       REFERENCES billing.lu_billing_type (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION
   ' )
   ' WITH (
   '   OIDS=FALSE
   ' );
   
   ' Public Const Billingtype_AMA As Integer = 1
   ' Public Const Billingtype_DVA_Non_LM0 As Integer = 2
   ' Public Const Billingtype_DVA_LM0 As Integer = 3
   ' Public Const Billingtype_Health_Care_Card_Concession As Integer = 4
   ' Public Const Billingtype_Pensioner_Concession As Integer = 5
   ' Public Const Billingtype_Private As Integer = 6
   ' Public Const  set"Billingtype_Transport_Accident_Commision_Victoria As Integer = 7
   ' Public Const Billingtype_Scheduled_Fee As Integer = 8
   '
   
   Dim hFile As File
   Dim soneline As String
   Dim Fee_Info As String[]
   Dim all_Fees As New Collection
   Dim Fields As String[]
   Dim x As Integer
   Dim y As Integer
   Dim item As New CRow
   Dim sql As String
   Dim R As Result
   Dim price As CRow
   Dim fk_fee_schedule As Variant
   Dim unsaved_fees As New Collection
   Dim sql_insert As String
   Dim hSqlFile As File
   
   hFile = Open "/home/richard/FEES.txt" For Read
   hSqlFile = Open "/home/richard/fee_update.sql" For Write Create
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      If x = 0 Then
         Fields = Split(sOneLine, " |")
      Else
         Fee_Info = Split(sOneLine, "|")
         Item!number = Fee_info[0]
         sql = "Select * from billing.fee_schedule where mbs_item = $$" & Trim(Fee_info[0]) & "$$"
         R = modDBConnect.exec_query(sql)
         If R.count Then
            fk_fee_schedule = R!pk
            Item!description = Fee_info[1]
            Item!deleted = Fee_info[4]
            Item!gst = Fee_info[5]
            Item!vet_fee_non_lmo = Fee_info[10]
            Item!vet_fee_lmo = Fee_info[11]
            item!private_fee = Fee_info[16]
            If Fee_Info[0] = 23 Then
               Print Fee_Info
               item!private_fee = Fee_info[16]
            Endif
            '--------------------------
            'Save the private fee level
            '--------------------------
            If Not IsNull(item!private_fee) Then
               price = New CRow
               price!fk_fee_schedule = fk_fee_schedule
               price!price = item!private_fee
               price!fk_lu_billing_type = const.Billingtype_Private
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, item!private_fee, const.Billingtype_Private) & ");"
               Print #hSqlFile, sql
            End If
            '------------------------------
            'Save the dva non LMO fee level
            '------------------------------
            If Not IsNull(Item!vet_fee_non_lmo) Then
               price = New CRow
               price!fk_fee_schedule = fk_fee_schedule
               price!price = Item!vet_fee_non_lmo
               price!fk_lu_billing_type = const.Billingtype_DVA_Non_LM0
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, Item!vet_fee_non_lmo, const.Billingtype_DVA_Non_LM0) & ");"
               Print #hSqlFile, sql
            End If
            '--------------------------
            'Save the dva LMO fee level
            '--------------------------
            If Not IsNull(Item!vet_fee_lmo) Then
               price = New CRow
               price!fk_fee_schedule = fk_fee_schedule
               price!price = Item!vet_fee_lmo
               price!fk_lu_billing_type = const.Billingtype_DVA_LM0
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, Item!vet_fee_lmo, const.Billingtype_DVA_LM0) & ");"
               Print #hSqlFile, sql
            End If
         Else
            unsaved_fees.Add(Fee_Info, unsaved_fees.count)
            sql_insert = "insert into billing.fee_schedule (descriptor, mbs_item, group) values ($$"
            sql_insert &= Fee_info[1] & "$$,$$" & 3 & "$$,$$" & "$$A1$$)"
            ' insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values (currval('billing.fee_schedule_pk_seq'),'16.30',3);
            '
            
         End If
      End If
      all_Fees.Add(Fee_Info, all_Fees.count)
      Inc x
   Wend
   Print unsaved_fees
   ' modDBConnect.CommitTrans()
   Message.Info("Finished")
   Close #hFile
   Close #HsqlFile
   Print all_Fees
   
End

' Public Function Responsible_Payer_Get(fk_patient As Variant) As Collection
'    'fixme this is temporary, only works if the patient has another patient as responsible person
'    'just doing this for development stuff
'
'    Dim R As Result
'
'    R = modDBConnect.exec_query("Select * from clerical.data_patients where pk = " & fk_patient)
'    If r.count Then
'       If r!fk_payer Then
'          Return modContactsDBI.Patient_Get_Using_PK(r!fk_payer)
'       End If
'    End If
'
' End

Public Function Consultations_Not_Charged_Get(on_date As Date) As Collection
   '----------------------------------------------------------------------------
   'Return a collection of consultations marked as seen/gone but were not billed
   '----------------------------------------------------------------------------
   
   Dim sql As String
   
   '  sql = "Select * from clerical.vwAppointments where date(begin) = '" & Format(on_date, "dd/mm/yyyy") & "'"
   ' sql &= " AND fk_lu_reason_not_billed is not null"
   ' Return modDBConnect.exec_query_collection(sql)
   sql = "Select * From clerical.vwAppointments where fk_lu_reason_not_billed Is Null"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Consultation_Ubilled_Get(fk_appointment As Variant) As Collection
   
   Return modDBConnect.exec_query_first("Select * from clerical.vwAppointments where pk= &1", [fk_appointment])
   
End

Public Function Consultations_UnBilled_Get(Optional on_date As Date = Null, Optional fk_patient As Variant = Null) As Collection
   '--------------------------------------------------------------------
   'returns a collection of all unbilled consultations
   'optionally filtered on date and patient
   'A consultation is is determined as unbilled if
   'a) The appointment is marked completed in the waiting room list and
   'b) The invoiced flag is false
   'c) They actually did attend
   'd) They are not flagged as 'no charge'
   '--------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from clerical.vwAppointments where invoiced is not true and did_not_attend is not true and fk_lu_reason_not_billed is null "
   
   If Not IsNull(fk_patient) Then
      sql &= " AND fk_patient = " & fk_patient & " "
   Else
      sql &= "And fk_patient Is Not Null "
   Endif
   sql &= "And fk_lu_appointment_status = " & const.Appointment_Status_Completed
   If Not IsNull(on_date) Then
      sql &= " AND date(begin) = '" & Format(on_date, "dd/mm/yyyy") & "'"
   End If
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Reasons_Not_Billed_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from billing.lu_reasons_not_billed order by reason")
   
End

Public Function Veteran_Card_Types_Get() As Collection
   
   Return modCache.Get("clerical.lu_veteran_card_type")
   
End

Public Function Centrelink_Card_Types_Get() As Collection
   
   Return modCache.Get("clerical.lu_centrelink_card_type")
   
End

Public Function Health_Funds_Get() As Collection
   
   Return modCache.Get("clerical.lu_private_health_funds")
   
End

Public Function Billing_Types_Get() As Collection
   
   'Return modCache.Get("billing.lu_billing_type") 'IAN THIS MUCKS UP MY BILLING MODULE FOR SOME REASON ?THE ORDERING.
   Return modDBConnect.exec_query_collection("Select * from billing.lu_billing_type order by type")  'fixme fix schema to be type
   
End

Public Function Billing_Level_Get() As Collection
   '-------------------------------------------------------------------------------
   'The levels of billing available for a patient eg bulk bill, private, concession
   '-------------------------------------------------------------------------------
   
   Return modCache.Get("billing.lu_default_billing_level")
   
End

Public Function Payments_Recieved_Get_For_Date(the_date As Date, fk_branch As Variant, Optional fk_staff As Variant) As Collection
   
   Dim sql As String
   
   sql = "select * from billing.vwPaymentsReceived where date_trunc('day', date_paid) ='" & Format(the_date, "dd/mm/yyyy") & "' "
   sql &= " AND fk_clinic_branch= " & fk_branch
   If Not IsNull(fk_staff) Then
      sql &= " AND  fk_staff_provided_service = " & fk_staff
   End If
   sql &= " order by fk_payment_received "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Payment_Methods_Get() As Collection
   
   Return modCache.Get("billing.lu_payment_method")
   
End

Public Function Invoice_Comments_Get() As Collection
   
   Return modCache.Get("billing.lu_invoice_comments")
   
End

Public Function Invoice_Payments_For_Get(fk_invoice As Variant) As Collection
   
   Return modDBConnect.exec_query_collection("Select * from billing.vwPayments where fk_invoice = " & fk_invoice)
   
End

Public Function Descriptors_Get(descriptor As String, Optional include_ama As Boolean = True, use_vwfees As Boolean = True, Optional limit As Integer = 500) As Collection
   
   Dim sql As String
   Dim searchcomponents As New String[]
   Dim component As String
   Dim i As Integer
   Dim r As Regexp
   
   If Descriptor = "" Then Return
   If use_vwfees Then
      sql = "billing.vwfees"
   Else
      sql = "billing.fee_schedule"
   Endif
   sql = "Select * from " & sql & " where "
   r = New Regexp(descriptor, "^[0-9]+$")
   If r.Offset <> -1 Then
      sql &= "mbs_item = '" & descriptor & "'"
   Else
      r = New Regexp(descriptor, "^[a-z]+[0-9]+$", Regexp.Caseless)
      If r.Offset <> -1 And include_ama Then
         sql &= "ama_item = '" & descriptor & "' or user_item ILIKE '" & descriptor & "'"
      Else
         searchcomponents = Split(descriptor, ",")
         For i = 0 To searchcomponents.Max
            searchcomponents[i] = "descriptor ILIKE $$%" & Trim$(searchcomponents[i]) & "%$$"
         Next
         sql &= searchcomponents.Join(" AND ")
      End If
   End If
   If Not include_ama Then
      sql &= " and not mbs_item is null"
   End If
   sql &= " order by cast(mbs_item as int), descriptor   LIMIT " & limit
   Print sql
   Return modDBConnect.exec_query_collection(sql)
   
End
' saves a changed schedule descriptor

Public Function Descriptors_Save(old_data As Collection, pk_descriptor As Variant, new_data As Collection)
   
   If IsNull(pk_descriptor) Then
      
   Else
      modDBConnect.update("billing.fee_schedule", old_data[pk_descriptor], new_data)
   End If
   
End

Public Function Fees_Get_With_Brief_Descriptor() As Collection
   'Fees in use in practice probably have a brief descriptor
   
   Dim sql As String
   
   sql = "Select * From Billing.fee_schedule where descriptor_brief Is Not Null "
   sql &= " order by mbs_item::int"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Scheduled_Fees_Item_Numbers_Get(Optional item_number_category As String = "") As Collection
   
   Dim sql As String
   
   sql = "Select * From Billing.fee_schedule "
   If item_number_category <> "" Then
      Select Case item_number_category
            '    Case "mbs item"
            '      sql &= " WHERE mbs_item is not null "
         Case "ama item"
            sql &= " WHERE ama_item is not null "
         Case "user item"
            sql &= " WHERE user_item is not null "
      End Select
   Endif
   ' sql &= " order by descriptor_brief"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Fees_Get_For_Descriptor(fk_fee_schedule As Variant) As Collection
   
   Dim sql As String
   
   sql = "Select * from billing.vwFees where fk_fee_schedule=" & fk_fee_schedule
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function fk_fee_shedule_Get_For_Item_Number(item As String) As Variant
   'this is temporary and will need trashing, IAN DON'T TRASH UNTIL YOU SPEAK TO ME
   'the item can be a 'fake' or 'made up' compound of an item eg 35/1 = nursing home visit/1 patient
   
   Dim R As Result
   Dim sql As String
   Dim compound_item_number As New String[]
   Dim number_of_patients As Integer
   Dim real_item_number As String  'the actual item number minus the number of patients
   
   compound_item_number = Split(item, "/")
   Try number_of_patients = Val(compound_item_number[1])
   real_item_number = UCase(compound_item_number[0])
   
   sql = "Select * From billing.fee_schedule where mbs_item =$$" & real_item_number & "$$ or ama_item =$$" & real_item_number & "$$ or  user_item =$$" & real_item_number & "$$"
   If number_of_patients Then
      sql &= " AND number_of_patients =" & number_of_patients
   Endif
   R = modDBConnect.exec_query(sql)
   If R.count Then
      Return R!pk
   Else
      Message.Info("This should never happen - couldn't find the fee schedule item numbers primary key")
   Endif
   
End

' returns schedule entries searching by brief descriptor
Public Function Descriptors_Brief_Get(searchtext As String, Optional limit As Integer = 100) As Collection
   
   Dim sql As String
   
   sql = "Select * from billing.fee_schedule where descriptor_brief ILIKE $$%" & searchtext
   sql &= "%$$ order by cast(mbs_item as int), descriptor LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End

' Public Function Scheduled_Fee_Get(item As String) As Collection
'    '-----------------------------------------------------------------------------------------------
'    'Returns just the scheduled fee to allow display of the gap's when various fee levels are chosen
'    '-----------------------------------------------------------------------------------------------
'    Dim sql As String
'
'    sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$)"
'    sql &= " and fk_lu_billing_type = " & const.Billingtype_Scheduled_Fee
'    Return modDBConnect.exec_query_first(sql)
'
' End

Public Function Fee_Get_For_Item_And_Billing_Type(item As String, fk_lu_billing_type As Variant) As Collection
   'Returns the billing.price for a particular item number for a particular billing type e.g Private
   
   Dim sql As String
   Dim num_patients As Integer
   
   Try num_patients = Split(item, "/")[1]
   item = Split(item, "/")[0]
   sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$ or user_item ilike  $$" & item & "$$)"
   If num_patients Then
      sql &= " AND number_of_patients = " & num_patients
   Endif
   sql &= " and fk_lu_billing_type = " & fk_lu_billing_type
   sql &= " limit 1"
   Return modDBConnect.exec_query_first(sql)
   
End


Public Function Cheque_Details_Get(fk_patient As Variant) As Collection
   '---------------------------------------------------------------
   'Gets details of patients cheque accounts if previously recorded
   '---------------------------------------------------------------
   
   Return modDBConnect.exec_query("Select * from billing.Cheque_Accounts where fk_patient = " & fk_patient)
   
End

Public Function Area_Of_Need_Fee(item As String, fk_lu_billing_type As Variant) As Collection
   
   Return modDBConnect.exec_query_first("select * From billing.vwFees WHERE mbs_item = $$" & item & "$$ and fk_lu_billing_type = " & fk_lu_billing_type)
   
End

Public Function Item_Exists(item As String) As Boolean
   
   Dim R As Result
   Dim num_patients As Integer
   Dim sql As String
   
   Try num_patients = Split(item, "/")[1]
   item = Split(item, "/")[0]
   sql = "select * From billing.fee_schedule WHERE (mbs_item ILIKE $$" & item & "$$ or ama_item ILIKE $$" & item & "$$ or user_item ilike  $$" & item & "$$) "
   If num_patients Then
      sql &= " AND number_of_patients = " & num_patients
   Endif
   R = modDBConnect.exec_query(sql)
   If R.count > 0 Then Return True
   
End

Public Function Items_Get(item As String, Optional fk_lu_billing_type As Variant = Null, Optional limit As Integer = 100) As Collection
   '---------------------------------------------
   'Gets list of item numbers and associated fees
   '---------------------------------------------
   
   Dim sql As String
   Dim num_patients As Integer
   Dim sa As String[]
   
   sa = Split(item, "/")
   num_patients = 0
   If sa.Length = 2 Then
      item = sa[0]
      Try num_patients = CInt(sa[1])
   Endif
   sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$ or user_item ilike  $$" & item & "$$)"
   If num_patients > 0 Then
      sql &= " AND number_of_patients = " & num_patients
   Endif
   If Not IsNull(fk_lu_billing_type) Then
      sql &= " and fk_lu_billing_type = " & fk_lu_billing_type
   Endif
   sql &= " LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End

' makes a new invoice on the backend
' NOTE: "invoice" is the arbitrary easygp internal term  and is not legally correct
' what gets spit out at the end is technically a "account receipt" for private billing and
' a "voucher" when bulk-billing
' also saves also the items billed
' items: array of Collections. Collections should orginate from billing.vwFees (must have a fk_fee_schedule and price fields)
' if price is changed from what's in the schedule can add a patient_charge field too
' if fk_staff is zero uses current logged in staff as the billing doctor
' fk_lu_billing_type is the billing type (some values in const)
' returns the PK of the new invoice

Public Sub Make_Invoice(pk_patient As Variant, items As Collection[], fk_lu_billing_type As Variant, Optional date_printed As Date, fk_staff As Variant, Optional notes As String) As Integer
   '    ' CREATE TABLE billing.invoices
   '    ' (
   '    '   pk serial NOT NULL,
   '    '   fk_staff_invoicing integer NOT NULL, -- the staff member raising the invoice
   '    '   date_printed timestamp without time zone,
   '    '   notes text,
   '    '   fk_lu_billing_type integer NOT NULL,
   '    '   fk_staff_provided_service integer NOT NULL, -- the staff member who provider the service on which the invoice is based
   '    '   fk_patient integer,
   '    '   date_invoiced timestamp without time zone NOT NULL DEFAULT now(),
   '    '   paid boolean NOT NULL DEFAULT false,
   '    '   CONSTRAINT invoices_pkey PRIMARY KEY (pk ),
   '    '   CONSTRAINT invoices_fk_doctor_raising_fkey FOREIGN KEY (fk_staff_provided_service)
   '    '       REFERENCES admin.staff (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '    '   CONSTRAINT invoices_fk_lu_billing_type_fkey FOREIGN KEY (fk_lu_billing_type)
   '    '       REFERENCES billing.lu_billing_type (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '    '   CONSTRAINT invoices_fk_patient_fkey FOREIGN KEY (fk_patient)
   '    '       REFERENCES clerical.data_patients (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '    '   CONSTRAINT invoices_fk_staff_invoicing_fkey FOREIGN KEY (fk_staff_invoicing)
   '    '       REFERENCES admin.staff (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION
   '    ' )
   '    ' WITH (
   '    '   OIDS=FALSE
   '    ' );
   '
   
   Dim invoice As New Collection
   Dim i As Collection
   Dim new_item As Collection
   '
   If IsNull(fk_staff) Then
      fk_staff = modDBConnect.currentUser!fk_staff
   Endif
   If Not IsNull(date_printed) Then
      invoice!date_printed = date_printed
   Endif
   invoice!fk_staff_invoicing = fk_staff
   invoice!notes = notes
   invoice!fk_lu_billing_type = fk_lu_billing_type
   invoice!fk_patient = pk_patient
   invoice!pk = modDBConnect.insert("billing.invoices", invoice)
   Save_Items(invoice!pk, items, False)
   Return invoice!pk
   
End

' saves a list of items to an existing invoice
' delete_preexisting is a flag to delete any pre-existing items on that invoice
' useful if saving from an invoice editor
' items is a list of Collections that must have the following members
' - patient_charge: the amont to charge the patient
' (if doesn't exist will use "price" instead, such as when collections come from billing.vwFees in search
' functions above)
' - fk_fee_schedule: link to billing.fee_schedule
'
Public Sub Save_Items(fk_invoice As Variant, items As Collection[], Optional delete_preexisting As Boolean = True)
   
   Dim i As Collection
   Dim new_item As Collection
   
   If delete_preexisting Then modDBConnect.exec_query("delete from billing.items_billed where fk_invoice = &1", [fk_invoice])
   For Each i In items
      new_item = New Collection
      new_item!fk_invoice = fk_invoice
      new_item!fk_fee_schedule = i!fk_fee_schedule
      new_item!fk_lu_billing_type = i!fk_lu_billing_type
      If i.Exist("patient_charge") Then
         new_item!amount = i!patient_charge
      Else
         new_item!amount = i!price
         i!patient_charge = i!price
      Endif
      i!pk_item = modDBConnect.insert("billing.items_billed", new_item)
   Next
   
End

Public Function Report_Get(Optional fk_report As Variant = Null) As Collection
   
   If IsNull(fk_report) Then
      Return modDBConnect.exec_query_collection("Select * from billing.lu_reports order by report_title")
   Else
      Return modDBConnect.exec_query_first("select * from billing.lu_reports where pk = &1", [fk_report])
   Endif
   
End

Public Function Bulk_Bill_Batching_Get_Claims(fk_lu_bulk_billing_type As Variant, Optional limit As Integer = 50) As Collection
   '-----------------------------------------------------------------------------------------------------
   'Gets a list of all claims (single table simple list) to be display in billing form for user to select
   '-----------------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   Return
   sql = "SELECT * from billing.bulk_billing_claims "
   If Not IsNull(fk_lu_bulk_billing_type) Then
      sql &= " WHERE fk_lu_bulk_billing_type = " & fk_lu_bulk_billing_type
   Endif
   sql &= " ORDER BY claim_date DESC LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Bulk_Bill_Batching_Get_Claim_Vouchers(fk_claim As Variant) As Collection
   '--------------------------------------------------------------------
   'Gets all the invoices (AKA vouchers (roughly) for a particular claim
   '--------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from billing.vwBulkBilledItems where fk_claim= " & fk_claim & " ORDER BY fk_invoice"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Bulk_Bill_Batching_Get_Vouchers(fk_staff As Variant, fk_branch As Variant, bPaid As Boolean, Optional fk_lu_bulk_billing_type As Integer = const.BulkBilling_Type_Medicare, Optional fk_claim As Variant, Optional limit As Integer = 100) As Collection
   '-------------------------------------------------------------------------------------
   'Returns a list of invoices (vouchers in this case) for a doctor and bulk billing type
   'const.BulkBilling_Type_Medicare or const.BulkBilling_Type_Veteran
   'if fk_claim is null then the medicare or veteran vouchers have not been claimed.
   '-------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from billing.vwBulkBilledItems "
   sql &= " WHERE fk_lu_bulk_billing_type = " & fk_lu_bulk_billing_type & " AND fk_staff_provided_service =" & fk_staff
   sql &= " AND fk_branch = " & fk_branch & ""
   If bPaid Then
      sql &= " AND paid = True "
   Else
      sql &= " And paid = False "
   End If
   If IsNull(fk_claim) Then
      sql &= " AND fk_claim is null "
   End If
   sql &= " ORDER BY fk_invoice,visit_date LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Bulk_Bill_Batching_Get_Vouchers_Total(fk_staff As Variant, fk_branch As Variant, Optional fk_lu_bulk_billing_type As Integer = const.BulkBilling_Type_Medicare, Optional limit As Integer = 50) As Variant
   
   Dim sql As String
   
   sql = " select sum(amount) as grand_total from billing.vwItemsBilled where  fk_lu_bulk_billing_type =" & fk_lu_bulk_billing_type
   sql &= " AND fk_staff_provided_service =" & fk_staff
   sql &= "  AND fk_branch = " & fk_branch & " AND paid = false LIMIT " & limit
   Return modDBConnect.exec_query(sql)!grand_total
   
End

Public Function Day_List_Get(date_seen As Date, fk_branch As Variant, fk_staff As Variant) As Collection
   '---------------------------------------------------------------------------------
   'Returns a collection of patients seen for the Day for a doctor at a clinic branch
   'This will include patient's seen and not billed
   '---------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from billing.vwDayList where date_trunc('day', appointment_date) ='" & Format(date_seen, "dd/mm/yyyy") & "' "
   sql &= " AND fk_branch= " & fk_branch
   sql &= " AND  fk_staff_provided_service = " & fk_staff
   sql &= " ORDER BY appointment_date,fk_items_billed ASC"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Items_Invoices_Get(fk_patient As Variant, iAccount_Display_Mode As Integer, Optional limit As Integer = 100) As Collection
   
   Dim sql As String
   Dim sql_stem As String
   
   sql_stem = "select * from billing.vwitemsandinvoices where fk_patient = " & fk_patient
   
   Select Case iAccount_Display_Mode
      Case const.Billing_Accounts_Unpaid
         sql &= " AND paid = false "
      Case const.Billing_Accounts_Paid
         sql &= " AND paid = true "
      Case const.Billing_Accounts_Paid_Today_And_Unpaid_All
         sql = sql_stem & " AND visit_date = '14/03/2016' and paid is true UNION "
         sql &= sql_stem & " AND paid = false " 
   End Select
   sql &= " ORDER BY visit_date,pk_items_billed  "
   Print sql
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Items_Billed_Get(fk_patient As Variant, iAccount_Display_Mode As Integer, Optional limit As Integer = 100) As Collection
   '-----------------------------------------------------------------------------------------------------------------------------------------
   ' returns a Collection of all invoices for this patient, most recent first, ordered by display mode (see const.Billing_Accounts constants)
   ' ----------------------------------------------------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "select * from billing.vwItemsBilled where fk_patient = " & fk_patient
   Select Case iAccount_Display_Mode
      Case const.Billing_Accounts_Unpaid
         sql &= " AND paid = false "
      Case const.Billing_Accounts_Paid
         sql &= " AND paid = true "
   End Select
   sql &= " ORDER BY date_invoiced desc "
   Return modDBConnect.exec_query_collection(sql)
   
End

' finds a referral for this patient
' returns NULL if they have no referral
' returns a Collection with name, address, provider_number of referrer,
' and "months": length of referral in months, defaults to 12
' and "indefinite" flag true if indefinite referral
'
Public Function Find_Referrer(fk_patient As Variant, Optional consult_date As Date) As Collection
   
   Dim sql As String
   
   sql = "with base as (select title, firstname, surname, vpe.provider_number, street1, street2, town, state, postcode, date_created, "
   "tag_user ~ 'indefin[ia]te' as indefinite, "
   "coalesce(substring(tag_user from '([0-9]+) month')::integer,12) as months "
   "from contacts.vwpersonsemployeesbyoccupation vpe, documents.vwdocuments vd"
   " where ((vd.fk_employee_branch = vpe.fk_employee and vd.fk_sender_branch = vpe.fk_branch"
   " and vd.fk_employee_branch is not null) or (vd.fk_sender_person = vpe.fk_person and vd.fk_employee_branch is not null)) and "
   " vd.fk_patient = &1 and vd.incoming_referral CONSULT )"
   " select *,date_created+(months*interval '1 month') as expiry from base order by date_created desc limit 1 "
   If IsNull(consult_date) Then
      sql = Replace$(sql, "CONSULT", "")
      Return modDBConnect.exec_query_first(sql, [fk_patient])
   Else
      sql = Replace$(sql, "CONSULT", " and vd.date_created < &2")
      Return modDBConnect.exec_query_first(sql, [fk_patient, consult_date])
   Endif
   
End

Public Function Get_Billed_Items(invoice As Crow) As Collection
   '-------------------------------------------------------------------
   ' returns a list of billed items for a given invoice, as Collections
   ' CREATE TABLE billing.items_billed
   ' (
   '   pk serial NOT NULL,
   '   fk_fee_schedule integer NOT NULL,
   '   amount money NOT NULL,
   '   fk_invoice integer NOT NULL,
   '   fk_lu_billing_type integer NOT NULL);
   '   ?? we already have this, so why recall from the backend, why not just pass?
   '-------------------------------------------------------------------
   
   Dim sql As String
   ' " left(coalesce(descriptor_brief,descriptor),400) as descriptor_display, "
   sql = "select * From billing.vwitemsbilled where fk_invoice = &1 "
   Return modDBConnect.exec_query_collection(sql, [invoice!fk_invoice])
   
End

Public Function Get_Payments(invoice As Crow) As Collection
   
   Return modDBConnect.exec_query_collection("select p.*, m.method from billing.payments_received p, billing.lu_payment_method m where p.fk_invoice = &1 and m.pk = p.fk_lu_payment_method", [invoice!fk_invoice])
   
End

Private Sub Load_FDF_Specialist(fdf As String, items As Collection, doctor As Collection, cc As CConsult, invoice As Crow, referrer As Collection) As String
   
   Dim i As Collection
   Dim no_free_item As Integer = 0
   Dim s As String
   Dim j As Integer
   
   ' first clear out pathologist-only info
   fdf = Replace$(fdf, "PathologyDescription", "")
   fdf = Replace$(fdf, "LS1", "")
   fdf = Replace$(fdf, "LS2", "")
   fdf = Replace$(fdf, "LS3", "")
   fdf = Replace$(fdf, "LS4", "")
   fdf = Replace$(fdf, "LS5", "")
   fdf = Replace$(fdf, "LS6", "")
   fdf = Replace$(fdf, "SD1", "")
   fdf = Replace$(fdf, "SD2", "")
   
   ' load item numbers
   For Each i In items
      
      If IsNull(i!descriptor_brief) Then
         s = i!descriptor
      Else
         s = i!descriptor_brief
      Endif
      If Len(s) > 40 Then s = Left$(s, 40)
      s = Upper$(s)
      While Len(i!mbs_item) < 5
         i!mbs_item = " " & i!mbs_item
      Wend
      Select Case no_free_item
         Case 0
            no_free_item = 1
            fdf = Replace$(fdf, "Des1", s)
            fdf = Replace$(fdf, "Item1_1", Mid$(i!mbs_item, 1, 1))
            fdf = Replace$(fdf, "Item1_2", Mid$(i!mbs_item, 2, 1))
            fdf = Replace$(fdf, "Item1_3", Mid$(i!mbs_item, 3, 1))
            fdf = Replace$(fdf, "Item1_4", Mid$(i!mbs_item, 4, 1))
            fdf = Replace$(fdf, "Item1_5", Mid$(i!mbs_item, 5, 1))
            s = Format$(modUtil.MoneyToFloat(i!amount), "000.00")
            fdf = Replace$(fdf, "Ben1_1", Mid$(s, 1, 1))
            fdf = Replace$(fdf, "Ben1_2", Mid$(s, 2, 1))
            fdf = Replace$(fdf, "Ben1_3", Mid$(s, 3, 1))
            fdf = Replace$(fdf, "Ben1_4", Mid$(s, 5, 1))
            fdf = Replace$(fdf, "Ben1_5", Mid$(s, 6, 1))
         Case 1
            no_free_item = 2
            fdf = Replace$(fdf, "Des2", s)
            s = Format$(modUtil.MoneyToFloat(i!amount), "000.00")
            fdf = Replace$(fdf, "Item2_1", Mid$(i!mbs_item, 1, 1))
            fdf = Replace$(fdf, "Item2_2", Mid$(i!mbs_item, 2, 1))
            fdf = Replace$(fdf, "Item2_3", Mid$(i!mbs_item, 3, 1))
            fdf = Replace$(fdf, "Item2_4", Mid$(i!mbs_item, 4, 1))
            fdf = Replace$(fdf, "Item2_5", Mid$(i!mbs_item, 5, 1))
            fdf = Replace$(fdf, "Ben2_1", Mid$(s, 1, 1))
            fdf = Replace$(fdf, "Ben2_2", Mid$(s, 2, 1))
            fdf = Replace$(fdf, "Ben2_3", Mid$(s, 3, 1))
            fdf = Replace$(fdf, "Ben2_4", Mid$(s, 5, 1))
            fdf = Replace$(fdf, "Ben2_5", Mid$(s, 6, 1))
      End Select
   Next
   If no_free_item < 2 Then
      fdf = Replace$(fdf, "Item2_1", "")
      fdf = Replace$(fdf, "Item2_2", "")
      fdf = Replace$(fdf, "Item2_3", "")
      fdf = Replace$(fdf, "Item2_4", "")
      fdf = Replace$(fdf, "Item2_5", "")
      fdf = Replace$(fdf, "Des2", "")
      fdf = Replace$(fdf, "Ben2_1", "")
      fdf = Replace$(fdf, "Ben2_2", "")
      fdf = Replace$(fdf, "Ben2_3", "")
      fdf = Replace$(fdf, "Ben2_4", "")
      fdf = Replace$(fdf, "Ben2_5", "")
   Endif
   If no_free_item = 0 Then
      fdf = Replace$(fdf, "Item1_1", "")
      fdf = Replace$(fdf, "Item1_2", "")
      fdf = Replace$(fdf, "Item1_3", "")
      fdf = Replace$(fdf, "Item1_4", "")
      fdf = Replace$(fdf, "Item1_5", "")
      fdf = Replace$(fdf, "Des2", "")
      fdf = Replace$(fdf, "Ben2_1", "")
      fdf = Replace$(fdf, "Ben2_2", "")
      fdf = Replace$(fdf, "Ben2_3", "")
      fdf = Replace$(fdf, "Ben2_4", "")
      fdf = Replace$(fdf, "Ben2_5", "")
   Endif
   
   ' load referrer info
   If IsNull(referrer) Then
      ' uh-oh, we can't find a referral for this patient
      ' make it all balnk so user can write in by hand later
      fdf = Replace$(fdf, "RefPrac", "")
      For j = 1 To 8
         fdf = Replace$(fdf, "PN" & j, "")
      Next
      fdf = Replace$(fdf, "RefMM1", "")
      fdf = Replace$(fdf, "RefMM2", "")
      fdf = Replace$(fdf, "RefDD2", "")
      fdf = Replace$(fdf, "RefDD1", "")
      fdf = Replace$(fdf, "RefYY1", "")
      fdf = Replace$(fdf, "RefYY2", "")
      fdf = Replace$(fdf, "DurationMM2", "")
      fdf = Replace$(fdf, "DurationMM1", "")
   Else
      fdf = Replace$(fdf, "RefPrac", referrer!title & " " & referrer!firstname & " " & referrer!surname & " " & referrer!street1 & referrer!street2 & " " & referrer!town & " " & referrer!postcode)
      s = referrer!provider_number
      If IsNull(s) Or If s = "" Or If Len(s) < 6 Then
         ' if there is no valid PN, make it blank so we can write it in later
         For j = 1 To 8
            fdf = Replace$(fdf, "PN" & j, "")
         Next
      Else
         While Len(s) < 8
            s = "0" & s
         Wend
         For j = 1 To 8
            fdf = Replace$(fdf, "PN" & j, Mid$(s, j, 1))
         Next
      Endif
      If referrer!indefinite Then
         fdf = Replace$(fdf, "IndefiniteReferral", "Yes")
         fdf = Replace$(fdf, "DurationMM2", "")
         fdf = Replace$(fdf, "DurationMM1", "")
      Else
         fdf = Replace$(fdf, "indefiniteReferral", "No")
         s = Format$(referrer!months, "00")
         fdf = Replace$(fdf, "DurationMM1", Mid$(s, 1, 1))
         fdf = Replace$(fdf, "DurationMM2", Mid$(s, 2, 1))
      Endif
      s = Format$(referrer!date_created, "ddmmyy")
      fdf = Replace$(fdf, "RefDD1", Mid$(s, 1, 1))
      fdf = Replace$(fdf, "RefDD2", Mid$(s, 2, 1))
      fdf = Replace$(fdf, "RefMM1", Mid$(s, 3, 1))
      fdf = Replace$(fdf, "RefMM2", Mid$(s, 4, 1))
      fdf = Replace$(fdf, "RefYY1", Mid$(s, 5, 1))
      fdf = Replace$(fdf, "RefYY2", Mid$(s, 6, 1))
   Endif
   
   Return fdf
   
End

Private Sub Load_FDF_Common(fdf As String, doctor As Collection, cc As CConsult, invoice As Crow) As String
   
   Dim s As String
   Dim initial As String
   
   If IsNull(cc!patient!medicare_number) Then
      cc!patient!medicare_number = "0000000000" 'FIXME PUT THIS IN UNTIL REPAT STUFF SORTED
   End If
   ' Error.Raise("Medicare number can't be NULL here")
   fdf = Replace$(fdf, "MA1", Mid$(cc!patient!medicare_number, 1, 1))
   fdf = Replace$(fdf, "MA2", Mid$(cc!patient!medicare_number, 2, 1))
   fdf = Replace$(fdf, "MA3", Mid$(cc!patient!medicare_number, 3, 1))
   fdf = Replace$(fdf, "MA4", Mid$(cc!patient!medicare_number, 4, 1))
   fdf = Replace$(fdf, "MA5", Mid$(cc!patient!medicare_number, 5, 1))
   fdf = Replace$(fdf, "MA6", Mid$(cc!patient!medicare_number, 6, 1))
   fdf = Replace$(fdf, "MA7", Mid$(cc!patient!medicare_number, 7, 1))
   fdf = Replace$(fdf, "MA8", Mid$(cc!patient!medicare_number, 8, 1))
   fdf = Replace$(fdf, "MA9", Mid$(cc!patient!medicare_number, 9, 1))
   fdf = Replace$(fdf, "MA0", Mid$(cc!patient!medicare_number, 10, 1))
   fdf = Replace$(fdf, "Ref", cc!patient!medicare_ref_number)
   fdf = Replace$(fdf, "Surname", Upper$(cc!patient!surname))
   modUtil.Split_Firstname(cc!patient!firstname, ByRef s, ByRef initial)
   fdf = Replace$(fdf, "Firstname", Upper$(s))
   fdf = Replace$(fdf, "Initial", Upper$(initial))
   fdf = Replace$(fdf, "DOB", Format$(cc!patient!birthdate, "dd/mm/yy"))
   fdf = Replace$(fdf, "Add1", cc!patient!street1 & " " & cc!patient!street2)
   fdf = Replace$(fdf, "Add2", cc!patient!town & " " & cc!patient!postcode)
   s = Format$(invoice!visit_date, "ddmmyy")
   fdf = Replace$(fdf, "DD1", Mid$(s, 1, 1))
   fdf = Replace$(fdf, "DD2", Mid$(s, 2, 1))
   fdf = Replace$(fdf, "MM1", Mid$(s, 3, 1))
   fdf = Replace$(fdf, "MM2", Mid$(s, 4, 1))
   fdf = Replace$(fdf, "YY1", Mid$(s, 5, 1))
   fdf = Replace$(fdf, "YY2", Mid$(s, 6, 1))
   s = doctor!wholename & "\n"
   If IsNull(doctor!provider_number) Then
      s &= doctor!street1
      If Not IsNull(doctor!street2) Then
         s &= "\n" & doctor!street2
      Endif
      s &= "\n" & doctor!town & " " & doctor!postcode
   Else
      s &= doctor!provider_number
   Endif
   fdf = Replace$(fdf, "Provider", s)
   
   Return fdf
   
End

Private Sub Load_FDF_GP(fdf As String, items As Collection) As String
   
   Dim i As Collection
   Dim no_free_item As Integer = 0
   Dim standard_items_cleared As Boolean = False
   Dim s As String
   
   For Each i In items
      Select Case i!mbs_item
         Case "3"
            fdf = Replace$(fdf, "cb3", "Yes")
            fdf = Replace$(fdf, "Ben1", i!amount)
            fdf = Replace$(fdf, "Ben2", "")
            fdf = Replace$(fdf, "Ben3", "")
            fdf = Replace$(fdf, "Ben4", "")
            standard_items_cleared = True
         Case "23"
            fdf = Replace$(fdf, "cb23", "Yes")
            fdf = Replace$(fdf, "Ben2", i!amount)
            fdf = Replace$(fdf, "Ben1", "")
            fdf = Replace$(fdf, "Ben3", "")
            fdf = Replace$(fdf, "Ben4", "")
            standard_items_cleared = True
         Case "36"
            fdf = Replace$(fdf, "cb36", "Yes")
            fdf = Replace$(fdf, "Ben3", i!amount)
            fdf = Replace$(fdf, "Ben2", "")
            fdf = Replace$(fdf, "Ben1", "")
            fdf = Replace$(fdf, "Ben4", "")
            standard_items_cleared = True
         Case "53"
            fdf = Replace$(fdf, "cb53", "Yes")
            fdf = Replace$(fdf, "Ben4", i!amount)
            fdf = Replace$(fdf, "Ben1", "")
            fdf = Replace$(fdf, "Ben3", "")
            fdf = Replace$(fdf, "Ben2", "")
            standard_items_cleared = True
         Case Else
            If IsNull(i!descriptor_brief) Then
               s = i!descriptor
            Else
               s = i!descriptor_brief
            Endif
            If Len(s) > 40 Then s = Left$(s, 40)
            s = Upper$(s)
            While Len(i!mbs_item) < 5
               i!mbs_item = " " & i!mbs_item
            Wend
            Select Case no_free_item
               Case 0
                  no_free_item = 1
                  fdf = Replace$(fdf, "Des5", s)
                  fdf = Replace$(fdf, "Item1_1", Mid$(i!mbs_item, 1, 1))
                  fdf = Replace$(fdf, "Item1_2", Mid$(i!mbs_item, 2, 1))
                  fdf = Replace$(fdf, "Item1_3", Mid$(i!mbs_item, 3, 1))
                  fdf = Replace$(fdf, "Item1_4", Mid$(i!mbs_item, 4, 1))
                  fdf = Replace$(fdf, "Item1_5", Mid$(i!mbs_item, 5, 1))
                  s = Format$(modUtil.MoneyToFloat(i!amount), "000.00")
                  fdf = Replace$(fdf, "Ben5_1", Mid$(s, 1, 1))
                  fdf = Replace$(fdf, "Ben5_2", Mid$(s, 2, 1))
                  fdf = Replace$(fdf, "Ben5_3", Mid$(s, 3, 1))
                  fdf = Replace$(fdf, "Ben5_4", Mid$(s, 5, 1))
                  fdf = Replace$(fdf, "Ben5_5", Mid$(s, 6, 1))
               Case 1
                  no_free_item = 2
                  fdf = Replace$(fdf, "Des6", s)
                  s = Format$(modUtil.MoneyToFloat(i!amount), "000.00")
                  fdf = Replace$(fdf, "Item2_1", Mid$(i!mbs_item, 1, 1))
                  fdf = Replace$(fdf, "Item2_2", Mid$(i!mbs_item, 2, 1))
                  fdf = Replace$(fdf, "Item2_3", Mid$(i!mbs_item, 3, 1))
                  fdf = Replace$(fdf, "Item2_4", Mid$(i!mbs_item, 4, 1))
                  fdf = Replace$(fdf, "Item2_5", Mid$(i!mbs_item, 5, 1))
                  fdf = Replace$(fdf, "Ben6_1", Mid$(s, 1, 1))
                  fdf = Replace$(fdf, "Ben6_2", Mid$(s, 2, 1))
                  fdf = Replace$(fdf, "Ben6_3", Mid$(s, 3, 1))
                  fdf = Replace$(fdf, "Ben6_4", Mid$(s, 5, 1))
                  fdf = Replace$(fdf, "Ben6_5", Mid$(s, 6, 1))
            End Select
      End Select
   Next
   If no_free_item < 2 Then
      fdf = Replace$(fdf, "Item2_1", "")
      fdf = Replace$(fdf, "Item2_2", "")
      fdf = Replace$(fdf, "Item2_3", "")
      fdf = Replace$(fdf, "Item2_4", "")
      fdf = Replace$(fdf, "Item2_5", "")
      fdf = Replace$(fdf, "Des6", "")
      fdf = Replace$(fdf, "Ben6_1", "")
      fdf = Replace$(fdf, "Ben6_2", "")
      fdf = Replace$(fdf, "Ben6_3", "")
      fdf = Replace$(fdf, "Ben6_4", "")
      fdf = Replace$(fdf, "Ben6_5", "")
   Endif
   If no_free_item = 1 Then
      fdf = Replace$(fdf, "Item1_1", "")
      fdf = Replace$(fdf, "Item1_2", "")
      fdf = Replace$(fdf, "Item1_3", "")
      fdf = Replace$(fdf, "Item1_4", "")
      fdf = Replace$(fdf, "Item1_5", "")
      fdf = Replace$(fdf, "Des5", "")
      fdf = Replace$(fdf, "Ben5_1", "")
      fdf = Replace$(fdf, "Ben5_2", "")
      fdf = Replace$(fdf, "Ben5_3", "")
      fdf = Replace$(fdf, "Ben5_4", "")
      fdf = Replace$(fdf, "Ben5_5", "")
   Endif
   If Not standard_items_cleared Then
      fdf = Replace$(fdf, "Ben4", "")
      fdf = Replace$(fdf, "Ben1", "")
      fdf = Replace$(fdf, "Ben3", "")
      fdf = Replace$(fdf, "Ben2", "")
   Endif
   Return fdf
   
End

Public Sub Get_Invoice_PK(fk_invoice As Variant) As CRow
   
   Dim invoice As CRow
   Dim v As CRow
   Dim rows As Collection
   
   rows = modDBConnect.exec_query_row("select * from billing.vwinvoices where fk_invoice = &1", [fk_invoice])
   If IsNull(rows) Then Return Null
   For Each v In rows
      invoice = v
   Next
   Return invoice
   
End

' during testing, we want to be able to print out invoices from the command line
' do bluk-billing
' puts PDF As / tmp / invoice - X.pdf where X Is Invoice PK
Public Sub Print_Bulk_Bill_Direct(pk_invoice As Variant, pdf_output_file As String)
   
   Dim latex As String
   
   latex = Print_Invoice(pk_invoice, False, True)
   modPrinting.Latex_To_PDF(latex, pdf_output_file)
   
End

' do private online billing
' again puts pdf as /tmp/invoice-X.pdf
Public Sub Print_Private_Direct(pk_invoice As Variant, pdf_output_file As String)
   
   Dim latex As String
   
   latex = Generate_Online_Latex(pk_invoice)
   modPrinting.Latex_To_PDF(latex, pdf_output_file)
   
End

' takes a CRow from billing.invoices, from either from Make_Invoice or Invoices_Get, and prints it
' also updates the row on the DB as appropriate
' ' cc is the current consult object. If not provided a new one will be loaded using th invoices's fk_patient.
Public Sub Print_Invoice(invoice_in As Variant, bPrint As Boolean, Optional bBulkBIll As Boolean = False, cc As Cconsult, referrer As Collection) As String
   '
   
   Dim sql As String
   Dim items As Collection
   Dim payments As Collection
   Dim templ As CTemplate
   Dim doctor As Collection
   Dim i As Collection
   Dim referrer_type As String
   Dim latex As String
   Dim pdfname As String
   Dim fdf As String
   Dim tmpfile As String
   Dim pdftk_path As String
   Dim invoice As CRow
   Dim v As Variant
   
   If TypeOf(invoice_in) = gb.Integer Then
      invoice = Get_Invoice_PK(invoice_in)
   Else
      invoice = invoice_in
   Endif
   
   If IsNull(cc) Then cc = New CConsult(modContactsDBI.Patient_Get_Using_PK(invoice!fk_patient), const.consult_type_audit)
   items = Get_Billed_Items(invoice)
   payments = Get_Payments(invoice)
   sql = "select referrer_type, s.* from common.lu_occupations o, admin.vwstaffinclinics s "
   "where o.pk = s.fk_occupation and s.fk_staff = &1  and fk_branch = &2 limit 1"
   doctor = modDBConnect.exec_query_first(sql, [invoice!fk_staff_provided_service, invoice!fk_branch])
   referrer_type = doctor!referrer_type
   If invoice!online Then
      If bBulkBill Then
         If referrer_type = "s" Or If Not IsNull(referrer) Then
            templ = New CTemplate("templates/invoice-online-bb-specialist.tex")
            Load_Template_Specialist(templ, invoice, referrer)
         Else
            templ = New CTemplate("templates/invoice-online-bb-gp.tex")
         Endif
         Load_Template_GP(invoice, templ, doctor, items, payments, cc, False)
         latex = templ.GetData()
         If bPrint Then modPrinting.Print_latex(latex, const.Paper_Plain, 1)
         Return latex
      Else
         If IsNull(invoice!result_code) Or If invoice!result_code = 4005 Then
            Return Null ' we are waiting for a response from the Medicare server, so printing happens later
         Else
            ' we have a response code from the Medicare server
            ' this isn't/shouldn't be where printing normally happens for private online billing
            ' but Print anyway As Per user request
            If referrer_type = "s" Or If Not IsNull(referrer) Then
               templ = New CTemplate("templates/invoice-online-specialist.tex")
               Load_Template_Specialist(templ, invoice, referrer)
            Else
               templ = New CTemplate("templates/invoice-online-gp.tex")
            Endif
            Load_Template_GP(invoice, templ, doctor, items, payments, cc, True)
            latex = templ.GetData()
            If bPrint Then modPrinting.Print_latex(latex, const.Paper_Plain, 1)
            Return latex
         Endif
      Endif
   Else
      ' here's the old manual offline printing code
      If bBulkBIll Then
         ' cue scary music: patient is being bulk-billed
         If referrer_type = "s" Then  'FIXME: reliable way of determinging specialist status
            pdfname = "db2-ot"
         Else
            pdfname = "db2-gp"
         Endif
         fdf = File.Load(modUtil.Find_File("templates" &/ pdfname & ".fdf"))
         If referrer_type = "s" Then
            fdf = Load_FDF_Specialist(fdf, items, doctor, cc, invoice, referrer)
         Else
            fdf = Load_FDF_GP(fdf, items)
         Endif
         fdf = Load_FDF_Common(fdf, doctor, cc, invoice)
         tmpfile = Temp$("bulkbill")
         File.Save(tmpfile & ".fdf", fdf)
         pdftk_path = modUtil.FindProgram("pdftk", "pdftk")
         If IsNull(pdftk_path) Then Return
         Print modUtil.Find_File("templates" &/ pdfname & ".pdf"), "fill_form", tmpfile & ".fdf", "output", tmpfile & ".pdf", "flatten"
         Exec [pdftk_path, modUtil.Find_File("templates" &/ pdfname & ".pdf"), "fill_form", tmpfile & ".fdf", "output", tmpfile & ".pdf", "flatten"] Wait
         If bPrint Then modPrinting.Print_PDF(tmpfile & ".pdf", const.Paper_Plain, 1)
         Try Kill tmpfile & ".pdf"
         Try Kill tmpfile & ".fdf"
         Return Null
      Else
         If referrer_type = "s" Then
            ' specialist's account: need to grab referrer's details first
            templ = New CTemplate("templates/invoice-specialist.tex", "tex")
            Load_Template_Specialist(templ, invoice, referrer)
         Else
            templ = New CTemplate("templates/invoice-gp.tex", "tex")
         End If
         Load_Template_GP(invoice, templ, doctor, items, payments, cc)
         latex = templ.GetData()
         If bPrint Then modPrinting.Print_latex(latex, const.Paper_Plain, 1)
         Return latex
      Endif
   Endif
   
End

' private invoices Medicare Online are not generated on-the-spot but at some later time as we need
' a response form the Medicare server
Public Function Generate_Online_Latex(fk_invoice As Variant) As String
   
   Dim latex As String
   Dim invoice As CRow
   Dim cc As CConsult
   Dim items As Collection
   Dim payments As Collection
   Dim templ As CTemplate
   Dim doctor As Collection
   Dim sql As String
   Dim referrer_type As String
   Dim referrer As Collection
   
   invoice = Get_Invoice_PK(fk_invoice)
   cc = New CConsult(modContactsDBI.Patient_Get_Using_PK(invoice!fk_patient))
   items = Get_Billed_Items(invoice)
   payments = Get_Payments(invoice)
   sql = "select referrer_type, s.* from common.lu_occupations o, admin.vwstaffinclinics s "
   "where o.pk = s.fk_occupation and s.fk_staff = &1 limit 1"
   doctor = modDBConnect.exec_query_first(sql, [invoice!fk_staff_provided_service])
   referrer_type = doctor!referrer_type
   referrer = Find_Referrer(invoice!fk_patient, invoice!visit_date)
   ' logic for determining user is specialist/GP is surprisingly tricky
   ' Medicare testing makes it harder as the fake doctor identities we
   ' are given are GPs, but must be used to test specialist billing also
   ' so go on specialist status and if they have a valid referral in the system
   If referrer_type = "s" Or If Not IsNull(referrer) Then
      templ = New CTemplate("templates/invoice-online-specialist.tex")
      Load_Template_Specialist(templ, invoice, referrer)
   Else
      templ = New CTemplate("templates/invoice-online-gp.tex")
   Endif
   If invoice!result_code <> 0 Then
      templ.Subst("title", "LODGEMENT ADVICE")
   Else
      templ.Subst("title", "STATEMENT OF CLAIM AND BENEFIT PAYMENT")
   Endif
   Load_Template_GP(invoice, templ, doctor, items, payments, cc, True)
   latex = templ.GetData()
   modDBConnect.update("billing.invoices", Null, ["pk": invoice!fk_invoice, "latex": latex, "date_printed": "now()"])
   Return latex
   
End

' loads info about specialist rinvoices (i.e. info about the referral)
Private Sub Load_Template_Specialist(templ As Ctemplate, invoice As Crow, referrer As Collection)
   
   If IsNull(referrer) Then
      ' uh-oh, we can't find a referral for this patient
      templ.Subst("referrer-name", templ.Bold("NONE"))
      templ.Subst("referrer-street1", templ.Bold("As no referrer there can be NO rebate on this account"))
      templ.Subst("referrer-street2", "")
      templ.Subst("referrer-town", "")
      templ.Subst("referrer-postcode", "")
      templ.Subst("referrer-provider-number", templ.Bold("NONE"))
      templ.Subst("referral-duration", "")
      templ.Subst("referral-date", "")
   Else
      templ.Subst("referrer-name", referrer!title & " " & referrer!firstname & " " & referrer!surname)
      templ.Subst("referrer-street1", referrer!street1)
      templ.Subst("referrer-street2", referrer!street2)
      templ.Subst("referrer-town", referrer!town)
      templ.Subst("referrer-postcode", referrer!postcode)
      templ.Subst("referrer-provider-number", referrer!provider_number)
      If referrer!indefinite Then
         templ.Subst("referral-duration", "indefinite duration")
      Else
         templ.Subst("referral-duration", referrer!months & " months")
      Endif
      templ.Subst("referral-date", Format$(referrer!date_created, "dd/mm/yy"))
   Endif
   
End

' little convience fucntion for adding extra rows of data containing further comments on the item
Private Sub Extra_Line(templ As Ctemplate, extra_row_text As String)
   
   Dim s As String
   
   s = "\\multicolumn{6}{p{140mm}}{ \\footnotesize " & extra_row_text & "}"
   templ.Row(s)
   
End

' prepares the template with stuff for GP-type invoices (actually common to specialists too)
Private Sub Load_Template_GP(invoice As Crow, templ As CTemplate, doctor As Collection, items As Collection, payments As Collection, cc As CConsult, Optional mo_result As Boolean = False)
   
   Dim i As Collection
   Dim s As String
   Dim bank_details As Collection
   
   templ.Subst("doctor-name", doctor!title & " " & doctor!firstname & " " & doctor!surname)
   templ.Subst("doctor-address-line1", doctor!street1)
   templ.Subst("organisation", doctor!organisation)
   If IsNull(doctor!street2) Then
      templ.Subst("doctor-address-line2", doctor!town & " " & doctor!postcode)
      templ.Subst("doctor-address-line3", "\\relax")
   Else
      templ.Subst("doctor-address-line2", doctor!street2)
      templ.Subst("doctor-address-line3", doctor!town & " " & doctor!postcode)
   Endif
   templ.Subst("doctor-occupation", modUtil.Ucase_Word_First_Letter(doctor!occupation))
   templ.Subst("doctor-provider-number", doctor!provider_number)
   templ.Subst("current-time", Format$(Now, "dd/mm/yy hh:nn"))
   templ.Subst("invoice-time", Format$(invoice!date_invoiced, "dd/mm/yy hh:nn"))
   templ.Subst("abn", doctor!australian_business_number)
   templ.Subst("hic-location-id", doctor!hic_location_id)
   templ.Subst("invoice-num", invoice!fk_invoice)
   If IsNull(invoice!account_to_name) Then
      templ.Subst("account-to-name", "\\relax")
      Templ.Subst("account-to-address-line1", "\\relax")
      Templ.Subst("account-to-address-line2", "\\relax")
      Templ.Subst("account-to-address-line3", "\\relax")
      Templ.Subst("account-to-medicare-number", "\\relax")
      templ.Subst("account-to-medicare-ref-number", "\\relax")
      templ.Subst("account-to-birthdate", "\\relax")
      templ.Subst("account-to-telephone", "\\relax")
   Else
      Templ.Subst("account-to-name", invoice!account_to_name)
      'have a name - payer could be person/street1/street2/town + postcode
      'have a name - payer could be organisation/branch/street1/street2/town+postcode
      If Not IsNull(invoice!account_to_branch) Then
         Templ.Subst("account-to-address-line1", invoice!account_to_branch)
         Templ.Subst("account-to-address-line2", invoice!account_to_street)
         Templ.Subst("account-to-address-line3", invoice!account_to_town_postcode)
         Templ.Subst("account-to-medicare-number", "\\relax")
         templ.Subst("account-to-medicare-ref-number", "\\relax")
         templ.Subst("account-to-birthdate", "\\relax")
         templ.Subst("account-to-telephone", modContactsDBI.Branch_Telephone(invoice!fk_payer_branch))
      Else 'must be a person
         Templ.Subst("account-to-address-line1", invoice!account_to_street)
         Templ.Subst("account-to-address-line2", invoice!account_to_town_postcode)
         Templ.Subst("account-to-address-line3", "\\relax")
         Templ.Subst("account-to-medicare-number", invoice!account_to_medicare_number)
         templ.Subst("account-to-medicare-ref-number", invoice!account_to_medicare_ref_number)
         templ.Subst("account-to-birthdate", invoice!account_to_birthdate)
         templ.Subst("account-to-telephone", modContactsDBI.person_Telephone(invoice!fk_payer_person))
      End If
   Endif
   If Not IsNull(invoice!reference) Then
      Templ.Subst("invoice-reference", "Reference: " & invoice!reference)
   Else
      Templ.Subst("invoice-reference", "\\relax")
   Endif
   If Not IsNull(invoice!notes) Then
      Templ.Subst("invoice-notes", "Comment: " & invoice!notes)
   Else
      Templ.Subst("invoice-notes", "\\relax")
   Endif
   ' now do the actual items
   For Each i In items
      s = i!descriptor_brief
      If Not s Then
         s = i!descriptor
      Endif
      If Len(s) > 60 Then
         s = Left$(s, 60)
      Endif
      templ.Row(Format$(invoice!visit_date, "dd/mm/yy"), i!common_item, "\\multicolumn{2}{p{6cm}}{" & s & "}", i!amount, "")
      If Not IsNull(i!number_of_patients) And If i!number_of_patients > 0 Then
         Extra_Line(templ, "Number of patients: " & i!number_of_patients)
      Endif
      
      If mo_result Then
         If i!multiple_procedure Then
            Extra_Line(templ, "Multiple Procedures")
         Endif
         If i!separate_sites Then
            Extra_Line(templ, "Procedure at Separate Sites")
         Endif
         If i!aftercare Then
            Extra_Line(templ, "Not Related to Normal Postoperative Aftercare")
         Endif
         If i!not_related Then
            Extra_Line(templ, "Not Related to Care-plan")
         Endif
         If i!procedure_duration And If i!procedure_duration <> 0 Then
            Extra_Line(templ, "Procedure Duration: " & i!procedure_duration & " minutes")
         Endif
         If i!field_quantity And If i!field_quantity > 0 Then
            Extra_Line(templ, "Field Quantity: " & i!field_quantity)
         Endif
         If Not IsNull(i!description) Then
            s = "(" & i!reason_code & ") " & i!description
            If Not IsNull(i!comment) Then
               s &= " " & i!comment
            Endif
            Extra_Line(templ, s)
         Endif
      Endif
   Next
   If Not IsNull(payments) Then
      For Each i In payments
         templ.Row(Format$(i!date_paid, "dd/mm/yy"), "", "\\multicolumn{2}{l}{Payment: " & i!method & " " & i!referent & "}", "", i!amount)
      Next
   Endif
   
   templ.Table("accounts-table")
   
   If mo_result Then
      If invoice!result_code <> 0 Then
         If invoice!result_code = 4006 Then
            s = "This claim has been referred to the Deparment of Human Services."
         Else
            s = "This claim has been referred to the Department of Human Services because: (" & invoice!result_code & ") "
            s &= invoice!description
         Endif
         If Not IsNull(invoice!result_text) Then
            s &= " " & invoice!result_text
         Endif
         templ.Subst("online-result", s)
      Else
         templ.Subst("online-result", "The claim was successful")
      Endif
   Endif
   templ.Subst("due", invoice!due)
   templ.Subst("gst", invoice!total_gst)
   If invoice!due <> "$0.00" Then
      templ.Subst("fully-paid", "NO")
      If mo_result Then
         If invoice!result_code = 0 Then
            templ.Subst("mo-payment-info", "The cheque benefit will be directed to the: ADDRESS HELD BY THE DEPARTMENT OF HUMAN SERVICES")
         Else
            templ.Subst_HTML("mo-payment-info", "<b>NO PAYMENT WILL BE MADE, please take this statement to Department of Human Services.</b>")
         Endif
      Endif
      templ.Subst("bank-details", "")
   Else
      templ.Subst("fully-paid", "YES")
      If mo_result Then
         If invoice!result_code = 0 Then
            templ.Subst("mo-payment-info", "The Medicare benefit will be paid: if your bank account details are stored with the Department of Human Services your payment, via EFT, if not, a cheque will be issued")
         Else
            templ.Subst_HTML("mo-payment-info", "<b>NO PAYMENT WILL BE MADE, please follow up with the Department of Human Services.</b>")
         Endif
      Endif
      bank_details = Get_Bank_Details(invoice!fk_invoice)
      If Not IsNull(bank_details) Then
         templ.Subst("bank-details", "I authorise the payment of my benefits for this claim to be paid directly into the following bank or financial institution account: Name: " & bank_details!account_name & " BSB " & bank_details!bsb & " No. " & bank_details!account_number)
      Else
         templ.Subst("bank-details", "")
      Endif
   Endif
   templ.Subst("total", invoice!total_bill)
   If invoice!total_gst = invoice!total_bill Or invoice!total_gst = "$0.00" Then
      templ.Subst("invoice-name", "Patient Account")
   Else
      templ.Subst("invoice-name", "Tax Invoice")
   Endif
   
   templ.Subst_common(cc)
   
End

Public Sub Receipts_Get_For_Day(D As Date) As Collection
   '----------------------------------------------------------------------
   'Gets receipts for the day (currently all doctors) fixme subdivide this
   '----------------------payments------------------------------------------------
   
   Dim sql As String
   
   sql = "select * from billing.vwpaymentsreceived where date_paid = "   '    "date_paid from billing.vwpayments where date_paid = "
   sql &= "'" & Format$(D, "dd/mm/yyyy") & "'"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub Delete_Invoice_Item(pk As Variant)
   
   modDBConnect.exec_query("delete from billing.items_billed where pk = &1", [pk])
   modDBConnect.CommitTrans()
   
End

Public Sub Delete_Invoice(pk As Variant)
   
   modDBConnect.exec_query("delete from billing.items_billed where fk_invoice = &1", [pk])
   modDBConnect.exec_query("delete from billing.payments_received where fk_invoice = &1", [pk])
   modDBConnect.exec_query("delete from billing.invoices where pk = &1", [pk])
   modDBConnect.CommitTrans()
   
End

Public Function Accounts_Overdue_Find(start_duration As String, end_duration As String) As Collection
   
   Dim sql As String
   
   sql = "select distinct on (fk_patient) p.* from "
   "contacts.vwpatients p, billing.vwinvoices i where"
   " i.total_paid < i.total_bill and i.fk_patient = p. fk_patient and age(i.date_invoiced) > &1 "
   " and age(i.date_invoiced) < &2 and "
   " i.fk_lu_bulk_billing_type is null "
   Return modDBConnect.exec_query_collection(sql, [start_duration, end_duration])
   
End

Public Sub UnitTest(main_form As Form)
   '
   
   Dim r As Collection
   Dim invoice As New CRow
   Dim item1 As Collection
   Dim item2 As Collection
   
   item1 = modUtil.Get_One(Descriptors_Get("23", True, True))
   item2 = modUtil.Get_One(Descriptors_Get("308", True, True))
   modDBConnect.exec_query("truncate billing.invoices cascade")
   invoice!fk_patient = 1
   invoice!fk_staff_invoicing = 1
   invoice!fk_staff_provided_service = 1
   invoice!notes = "this is a fake test invoice"
   invoice!date_invoiced = Now
   invoice.Save("billing.invoices", "fk_invoice")
   Save_Items(invoice!fk_invoice, [item1, item2], False)
   modDBConnect.exec_query("insert into billing.payments_received(fk_lu_payment_method, amount, fk_invoice) values (1,'$100.00', &1)", [invoice!fk_invoice])
   Print_Invoice(invoice!fk_invoice, True)
   
End

' Same Day Delete is a Medicare Online function call
' it allows you to reverse an invoice if it is deleted on the same day

Public Sub Same_Day_Delete(fk_invoice As Variant, reason As String)
   
   modDBConnect.exec_query("NOTIFY '" & fk_invoice & "/" & reason & "'")
   
End

Public Sub Save_Bank_Details(fk_invoice As Variant, nam As String, bsb As String, no As String)
   
   modDBConnect.insert("billing.bank_details", ["fk_invoice": fk_invoice, "account_name": nam, "bsb": bsb, "account_number": no])
   
End

Public Function Get_Bank_Details(fk_invoice As Variant) As Collection
   
   Dim r As Result
   
   r = modDBConnect.exec_query("select * from billing.bank_details where fk_invoice = &1", [fk_invoice])
   If r.count = 1 Then
      modDBConnect.exec_query("delete from billing.bank_details where fk_invoice = &1", [fk_invoice])
      Return ["account_number": r!account_number, "bsb": r!bsb, "account_name": r!account_name]
   Else
      Return Null
   Endif
   
End
