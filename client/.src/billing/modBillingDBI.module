' Gambas module file

' Copyright (C) 2008-2012 Dr. Richard Terry  rterry@pacific.net.au Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'--------------------- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
' Billing Stuff
'-------------------------------------------------------------------------------

' searches on the schedule of items
' "descriptor" can be words in the descriptor text
' OR a umber: gets by Medicare item number
' OR letters and numbers together: searches by AMA item number
' use_vwfees: true if uses vwfees view (recommended for most uses below)
' 
Public Function Fee_Schedule_Import_From_Pracsoft()
   
   'only used by richard during development
   ' 
   'ItemNo|Description|OpRule|DerivedFee|Deleted|TaxRate|ReportGroup|SchedFee|Rebate85|Rebate75|VetFee|VetLMO|AMAFee|User1|User2|User3|User4|User5|User6|User7|User8|User9|User10|User11|User12|User13|User14|ID
   ' 0            1     2        3        4        5        6           7        8        9        10    11    12       13 
   ' field 16 is private
   ' CREATE TABLE billing.prices
   ' (
   '   pk serial NOT NULL,
   '   fk_fee_schedule integer NOT NULL,
   '   price money NOT NULL DEFAULT '$0.00'::money, -- the price to the patient
   '   fk_lu_billing_type integer NOT NULL,
   '   notes text,
   '   CONSTRAINT prices_pkey PRIMARY KEY (pk ),
   '   CONSTRAINT prices_fk_fee_schedule_fkey FOREIGN KEY (fk_fee_schedule)
   '       REFERENCES billing.fee_schedule (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '   CONSTRAINT prices_fk_lu_billing_type_fkey FOREIGN KEY (fk_lu_billing_type)
   '       REFERENCES billing.lu_billing_type (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION
   ' )
   ' WITH (
   '   OIDS=FALSE
   ' );
   
   ' Public Const Billingtype_AMA As Integer = 1
   ' Public Const Billingtype_DVA_Non_LM0 As Integer = 2
   ' Public Const Billingtype_DVA_LM0 As Integer = 3
   ' Public Const Billingtype_Health_Care_Card_Concession As Integer = 4
   ' Public Const Billingtype_Pensioner_Concession As Integer = 5
   ' Public Const Billingtype_Private As Integer = 6
   ' Public Const  set"Billingtype_Transport_Accident_Commision_Victoria As Integer = 7
   ' Public Const Billingtype_Scheduled_Fee As Integer = 8
   ' 
   
   Dim hFile As File
   Dim soneline As String
   Dim Fee_Info As String[]
   Dim all_Fees As New Collection
   Dim Fields As String[]
   Dim x As Integer
   Dim y As Integer
   Dim item As New CRow  
   Dim sql As String
   Dim R As Result
   Dim price As CRow
   Dim fk_fee_schedule As Integer
   Dim unsaved_fees As New Collection 
   Dim sql_insert As String
   Dim hSqlFile As File
   
   hFile = Open "/home/richard/FEES.txt" For Read
   hSqlFile = Open "/home/richard/fee_update.sql" For Write Create
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      If x = 0 Then
         Fields = Split(sOneLine, " |")
      Else   
         Fee_Info = Split(sOneLine, "|")
         Item!number = Fee_info[0]
         sql = "Select * from billing.fee_schedule where mbs_item = $$" & Trim(Fee_info[0]) & "$$"
         R = modDBConnect.exec_query(sql)
         If R.count Then
            fk_fee_schedule = R!pk
            Item!description = Fee_info[1]
            Item!deleted = Fee_info[4]
            Item!gst = Fee_info[5]
            Item!vet_fee_non_lmo = Fee_info[10]
            Item!vet_fee_lmo = Fee_info[11]
            item!private_fee = Fee_info[16]
            If Fee_Info[0] = 23 Then
               Print Fee_Info
               item!private_fee = Fee_info[16]
            Endif  
            '--------------------------
            'Save the private fee level
            '--------------------------
            If Not IsNull(item!private_fee) Then 
               price = New CRow  
               price!fk_fee_schedule = fk_fee_schedule
               price!price = item!private_fee
               price!fk_lu_billing_type = const.Billingtype_Private
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, item!private_fee, const.Billingtype_Private) & ");"
               Print #hSqlFile, sql
            End If   
            '------------------------------
            'Save the dva non LMO fee level
            '------------------------------
            If Not IsNull(Item!vet_fee_non_lmo) Then 
               price = New CRow  
               price!fk_fee_schedule = fk_fee_schedule
               price!price = Item!vet_fee_non_lmo
               price!fk_lu_billing_type = const.Billingtype_DVA_Non_LM0
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, Item!vet_fee_non_lmo, const.Billingtype_DVA_Non_LM0) & ");"
               Print #hSqlFile, sql
            End If  
            '--------------------------
            'Save the dva LMO fee level
            '--------------------------
            If Not IsNull(Item!vet_fee_lmo) Then 
               price = New CRow  
               price!fk_fee_schedule = fk_fee_schedule
               price!price = Item!vet_fee_lmo
               price!fk_lu_billing_type = const.Billingtype_DVA_LM0
               price.Save("billing.prices", "fk_price")
               sql = "Insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values("
               sql &= Subst$("'&1',$$&2$$,'&3'", fk_fee_schedule, Item!vet_fee_lmo, const.Billingtype_DVA_LM0) & ");"
               Print #hSqlFile, sql
            End If   
         Else
            unsaved_fees.Add(Fee_Info, unsaved_fees.count)
            sql_insert = "insert into billing.fee_schedule (descriptor, mbs_item, group) values ($$"
            sql_insert &= Fee_info[1] & "$$,$$" & 3 & "$$,$$" & "$$A1$$)"
            ' insert into billing.prices (fk_fee_schedule, price, fk_lu_billing_type) values (currval('billing.fee_schedule_pk_seq'),'16.30',3);
            ' 
            
         End If  
      End If 
      all_Fees.Add(Fee_Info, all_Fees.count)
      Inc x
   Wend
   Print unsaved_fees
   ' modDBConnect.CommitTrans()
   Message.Info("Finished")
   Close #hFile
   Close #HsqlFile
   Print all_Fees
   
End

' Public Function Responsible_Payer_Get(fk_patient As Integer) As Collection
'    'fixme this is temporary, only works if the patient has another patient as responsible person
'    'just doing this for development stuff
'    
'    Dim R As Result
'    
'    R = modDBConnect.exec_query("Select * from clerical.data_patients where pk = " & fk_patient)
'    If r.count Then
'       If r!fk_payer Then
'          Return modContactsDBI.Patient_Get_Using_PK(r!fk_payer)
'       End If   
'    End If   
'    
' End

Public Function Consultations_UnBilled_Get(Optional on_date As Date = Null) As Collection
   '--------------------------------------------------------------------
   'returns a collection of all unbilled consultations
   'A consultation is is determined as unbilled if
   'a) The appointment is marked completed in the waiting room list and
   'b) The invoiced flag is false
   'c) They actually did attend
   'd) They are not flagged as 'no charge'
   '--------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from clerical.vwAppointments where invoiced = false and did_not_attend = false and fk_lu_reason_not_billed is null "
   sql &= "And fk_patient Is Not Null "
   sql &= "And fk_lu_appointment_status = " & const.Appointment_Status_Completed
   If Not IsNull(on_date) Then
      sql &= " AND date(begin) = '" & Format(on_date, "dd/mm/yyyy") & "'"
   End If   
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Reasons_Not_Billed_Get() As Collection
   
  Return modDBConnect.exec_query_collection("Select * from billing.lu_reasons_not_billed order by reason")
   
End

Public Function Veteran_Card_Types_Get() As Collection
   
   Return modCache.Get("clerical.lu_veteran_card_type")
   
End

Public Function Centrelink_Card_Types_Get() As Collection
   
   Return modCache.Get("clerical.lu_centrelink_card_type")
   
End

Public Function Health_Funds_Get() As Collection
   
   Return modCache.Get("clerical.lu_private_health_funds")
   
End

Public Function Billing_Types_Get() As Collection
   
   'Return modCache.Get("billing.lu_billing_type") 'IAN THIS MUCKS UP MY BILLING MODULE FOR SOME REASON ?THE ORDERING.
   Return modDBConnect.exec_query_collection("Select * from billing.lu_billing_type order by type")  'fixme fix schema to be type
   
End

Public Function Billing_Level_Get() As Collection
   '-------------------------------------------------------------------------------
   'The levels of billing available for a patient eg bulk bill, private, concession
   '-------------------------------------------------------------------------------  
   
   Return modCache.Get("billing.lu_default_billing_level")
   
End

Public Function Payment_Methods_Get() As Collection
   
   Return modCache.Get("billing.lu_payment_method") 
   
End

Public Function Invoice_Comments_Get() As Collection
   
   Return modCache.Get("billing.lu_invoice_comments") 
   
End

Public Function Invoice_Payments_For_Get(fk_invoice As Integer) As Collection
   
   Return modDBConnect.exec_query_collection("Select * from billing.vwPayments where fk_invoice = " & fk_invoice) 
   
End

Public Function Descriptors_Get(descriptor As String, Optional include_ama As Boolean = True, use_vwfees As Boolean = True, Optional limit As Integer = 500) As Collection
   
   Dim sql As String
   Dim searchcomponents As New String[]
   Dim component As String
   Dim i As Integer
   Dim r As Regexp
   
   If use_vwfees Then
      sql = "billing.vwfees"
   Else
      sql = "billing.fee_schedule"
   Endif
   sql = "Select * from " & sql & " where "
   r = New Regexp(descriptor, "^[0-9]+$")
   If r.Offset <> -1 Then 
      sql &= "mbs_item = '" & descriptor & "'"
   Else 
      r = New Regexp(descriptor, "^[a-z]+[0-9]+$", Regexp.Caseless)
      If r.Offset <> -1 And include_ama Then
         sql &= "ama_item = '" & descriptor & "' or user_item ILIKE '" & descriptor & "'"
      Else
         searchcomponents = Split(descriptor, ",")
         For i = 0 To searchcomponents.Max
            searchcomponents[i] = "descriptor ILIKE $$%" & Trim$(searchcomponents[i]) & "%$$"
         Next
         sql &= searchcomponents.Join(" AND ")
      End If
   End If
   If Not include_ama Then
      sql &= " and not mbs_item is null"
   End If
   sql &= " order by cast(mbs_item as int), descriptor   LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End
' saves a changed schedule descriptor

Public Function Descriptors_Save(old_data As Collection, pk_descriptor As Integer, new_data As Collection)
   
   If pk_descriptor = -1 Then
      
   Else
      modDBConnect.update("billing.fee_schedule", old_data[pk_descriptor], new_data)
   End If  
   
End

Public Function Fees_Get_For_Descriptor(fk_fee_schedule As Integer) As Collection
   
   Dim sql As String
   
   sql = "Select * from billing.vwFees where fk_fee_schedule=" & fk_fee_schedule
   Return modDBConnect.exec_query_collection(sql) 
   
End

Public Function fk_fee_shedule_Get_For_Item_Number(item As String) As Integer
   'this is temporary and will need trashing
   
   Dim R As Result
   Dim sql As String
   
   item = UCase(item)
   sql = "Select * From billing.fee_schedule where mbs_item =$$" & item & "$$ or ama_item =$$" & item & "$$ or  user_item =$$" & item & "$$"
   R = modDBConnect.exec_query(sql)
   If R.count Then
      Return R!pk
   Else
      Message.Info("This should never happen - couldn't find the fee schedule item numbers primary key")
   Endif
   
End

' returns schedule entries searching by brief descriptor 
Public Function Descriptors_Brief_Get(searchtext As String, Optional limit As Integer = 100) As Collection 
   
   Dim sql As String
   
   sql = "Select * from billing.fee_schedule where descriptor_brief ILIKE $$%" & searchtext
   sql &= "%$$ order by cast(mbs_item as int), descriptor LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
   
End

' Public Function Scheduled_Fee_Get(item As String) As Collection
'    '-----------------------------------------------------------------------------------------------
'    'Returns just the scheduled fee to allow display of the gap's when various fee levels are chosen
'    '-----------------------------------------------------------------------------------------------
'    Dim sql As String
'    
'    sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$)" 
'    sql &= " and fk_lu_billing_type = " & const.Billingtype_Scheduled_Fee
'    Return modDBConnect.exec_query_first(sql)
'    
' End

Public Function Fee_Get_For_Item_And_Billing_Type(item As String, fk_lu_billing_type As Integer) As Collection
   'Returns the billing.price for a particular item number for a particular billing type e.g Private
   
   Dim sql As String
   
   sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$ or user_item ilike  $$" & item & "$$)" 
   sql &= " and fk_lu_billing_type = " & fk_lu_billing_type
   Return modDBConnect.exec_query_first(sql)
   
End

Public Function Cheque_Details_Get(fk_patient As Integer) As Collection
   '--------------------------------------------------------------- 
   'Gets details of patients cheque accounts if previously recorded
   '--------------------------------------------------------------- 
   
   Return modDBConnect.exec_query("Select * from billing.Cheque_Accounts where fk_patient = " & fk_patient)
   
End

Public Function Items_Get(item As String, Optional fk_lu_billing_type As Integer = -1, Optional limit As Integer = 100) As Collection
   '---------------------------------------------
   'Gets list of item numbers and associated fees
   '---------------------------------------------
   
   Dim sql As String
   
   sql = "select * From billing.vwFees WHERE (mbs_item = $$" & item & "$$ or ama_item = $$" & item & "$$ or user_item ilike  $$" & item & "$$)"
   If fk_lu_billing_type <> -1 Then
      sql &= " and fk_lu_billing_type = " & fk_lu_billing_type
   Endif
   sql &= " LIMIT " & limit   
   Return modDBConnect.exec_query_collection(sql)
   
End

' makes a new invoice on the backend
' NOTE: "invoice" is the arbitrary easygp internal term  and is not legally correct
' what gets spit out at the end is technically a "account receipt" for private billing and 
' a "voucher" when bulk-billing
' also saves also the items billed
' items: array of Collections. Collections should orginate from billing.vwFees (must have a fk_fee_schedule and price fields)
' if price is changed from what's in the schedule can add a patient_charge field too
' if fk_staff is zero uses current logged in staff as the billing doctor
' fk_lu_billing_type is the billing type (some values in const)
' returns the PK of the new invoice

Public Sub Make_Invoice(pk_patient As Integer, items As Collection[], fk_lu_billing_type As Integer, Optional date_printed As Date, fk_staff As Integer = 0, Optional notes As String) As Integer
   '    ' CREATE TABLE billing.invoices
   '    ' (
   '    '   pk serial NOT NULL,
   '    '   fk_staff_invoicing integer NOT NULL, -- the staff member raising the invoice
   '    '   date_printed timestamp without time zone,
   '    '   notes text,
   '    '   fk_lu_billing_type integer NOT NULL,
   '    '   fk_staff_provided_service integer NOT NULL, -- the staff member who provider the service on which the invoice is based
   '    '   fk_patient integer,
   '    '   date_invoiced timestamp without time zone NOT NULL DEFAULT now(),
   '    '   paid boolean NOT NULL DEFAULT false,
   '    '   CONSTRAINT invoices_pkey PRIMARY KEY (pk ),
   '    '   CONSTRAINT invoices_fk_doctor_raising_fkey FOREIGN KEY (fk_staff_provided_service)
   '    '       REFERENCES admin.staff (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '    '   CONSTRAINT invoices_fk_lu_billing_type_fkey FOREIGN KEY (fk_lu_billing_type)
   '    '       REFERENCES billing.lu_billing_type (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '    '   CONSTRAINT invoices_fk_patient_fkey FOREIGN KEY (fk_patient)
   '    '       REFERENCES clerical.data_patients (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '    '   CONSTRAINT invoices_fk_staff_invoicing_fkey FOREIGN KEY (fk_staff_invoicing)
   '    '       REFERENCES admin.staff (pk) MATCH SIMPLE
   '    '       ON UPDATE NO ACTION ON DELETE NO ACTION
   '    ' )
   '    ' WITH (
   '    '   OIDS=FALSE
   '    ' );
   '    
   
   Dim invoice As New Collection
   Dim i As Collection
   Dim new_item As Collection
   '    
   If fk_staff = 0 Then
      fk_staff = modDBConnect.currentUser!fk_staff
   Endif
   If Not IsNull(date_printed) Then
      invoice!date_printed = date_printed 
   Endif
   invoice!fk_staff_invoicing = fk_staff
   invoice!notes = notes
   invoice!fk_lu_billing_type = fk_lu_billing_type
   invoice!fk_patient = pk_patient
   invoice!pk = modDBConnect.insert("billing.invoices", invoice)
   Save_Items(invoice!pk, items, False)
   Return invoice!pk
   
End

' saves a list of items to an existing invoice
' delete_preexisting is a flag to delete any pre-existing items on that invoice
' useful if saving from an invoice editor
' items is a list of Collections that must have the following members
' - patient_charge: the amont to charge the patient
' (if doesn't exist will use "price" instead, such as when collections come from billing.vwFees in search
' functions above)
' - fk_fee_schedule: link to billing.fee_schedule
' 
Public Sub Save_Items(fk_invoice As Integer, items As Collection[], Optional delete_preexisting As Boolean = True)
   
   Dim i As Collection
   Dim new_item As Collection
   
   If delete_preexisting Then modDBConnect.exec_query("delete from billing.items_billed where fk_invoice = &1", [fk_invoice])
   For Each i In items
      new_item = New Collection
      new_item!fk_invoice = fk_invoice
      new_item!fk_fee_schedule = i!fk_fee_schedule
      new_item!fk_lu_billing_type = i!fk_lu_billing_type
      If i.Exist("patient_charge") Then
         new_item!amount = i!patient_charge
      Else
         new_item!amount = i!price
         i!patient_charge = i!price
      Endif
      i!pk_item = modDBConnect.insert("billing.items_billed", new_item)
   Next 
   
End

Public Function Report_Titles_Get() As Collection

Return modDBConnect.exec_query_collection("Select * from billing.reports order by report_title")
   
   
   
End

Public Function Bulk_Bill_Batching_Get_Claims(fk_lu_bulk_billing_type As Integer, Optional limit As Integer = 50) As Collection 
   '-----------------------------------------------------------------------------------------------------
   'Gets a list of all claims (single table simple list) to be display in billing form for user to select
   '-----------------------------------------------------------------------------------------------------

   Dim sql As String
   
   sql = "SELECT * from billing.bulk_billing_claims "
   If fk_lu_bulk_billing_type Then
      sql &= " WHERE fk_lu_bulk_billing_type = " & fk_lu_bulk_billing_type
   Endif
   sql &= " ORDER BY claim_date DESC LIMIT " & limit
   Return modDBConnect.exec_query_collection(sql)
  
   
End

Public Function Bulk_Bill_Batching_Get_Claim_Vouchers(fk_claim As Integer) As Collection
   '--------------------------------------------------------------------
   'Gets all the invoices (AKA vouchers (roughly) for a particular claim
   '--------------------------------------------------------------------   
   
   Dim sql As String

   sql = "Select * from billing.vwClaims where fk_bulk_billing_claim=" & fk_claim & " ORDER BY fk_invoice"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Bulk_Bill_Batching_Get_Vouchers(fk_staff As Integer, fk_branch As Integer, Optional fk_lu_bulk_billing_type As Integer = const.BulkBilling_Type_Medicare, Optional fk_claim As Integer = 0, Optional limit As Integer = 50) As Collection
   '-------------------------------------------------------------------------------------
   'Returns a list of invoices (vouchers in this case) for a doctor and bulk billing type
   'const.BulkBilling_Type_Medicare or const.BulkBilling_Type_Veteran 
   'if fk_claim is null then the medicare or veteran vouchers have not been claimed.
   '-------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "SELECT pk_items_billed, fk_invoice,patient_wholename, date_invoiced as visit_date, mbs_item,amount  from billing.vwItemsBilled "
   sql &= " WHERE fk_lu_bulk_billing_type = " & fk_lu_bulk_billing_type & " AND fk_staff_provided_service =" & fk_staff
   sql &= " AND fk_branch = " & fk_branch & " and paid = false" 
   If fk_claim = 0 Then 
      sql &= " AND fk_claim is null "
   End If
   sql &= " ORDER BY fk_invoice, visit_date LIMIT " & limit
   Print sql
   
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Bulk_Bill_Batching_Get_Vouchers_Total(fk_staff As Integer, fk_branch As Integer, Optional fk_lu_bulk_billing_type As Integer = const.BulkBilling_Type_Medicare, Optional limit As Integer = 50) As Variant
   
   Dim sql As String
   
   sql = " select sum(amount) as grand_total from billing.vwItemsBilled where  fk_lu_bulk_billing_type =" & fk_lu_bulk_billing_type
   sql &= " AND fk_staff_provided_service =" & fk_staff
   sql &= "  AND fk_branch = " & fk_branch & " AND paid = false LIMIT " & limit 
   Return modDBConnect.exec_query(sql)!grand_total
   
End   

Public Function Day_List_Get(date_seen As Date, fk_branch As Integer, fk_staff As Integer) As Collection
   
   Dim sql As String

   sql = "Select * from billing.vwItemsAndInvoices where visit_date ='" & Format(date_seen, "dd/mm/yyyy") & "' "
   sql &= " AND fk_branch= " & fk_branch
   sql &= " AND  fk_staff_provided_service = " & fk_staff  
   sql &= " ORDER BY appointment_time ASC"
   Print sql
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Items_Invoices_Get(fk_patient As Integer, iAccount_Display_Mode As Integer, Optional limit As Integer = 100) As Collection
   
     Dim sql As String
     Dim c As Collection
     
   sql = "select * from billing.vwitemsandinvoices where fk_patient = " & fk_patient
   Select Case iAccount_Display_Mode
      Case const.Billing_Accounts_Unpaid
         sql &= " AND paid = false "
      Case const.Billing_Accounts_Paid
         sql &= " AND paid = true "
   End Select
   sql &= " ORDER BY date_invoiced desc "
   c = modDBConnect.exec_query_collection(sql)
   Print sql
   Return c
   Return modDBConnect.exec_query_collection(sql)
   
   
End

Public Function Items_Billed_Get(fk_patient As Integer, iAccount_Display_Mode As Integer, Optional limit As Integer = 100) As Collection
   '-----------------------------------------------------------------------------------------------------------------------------------------
   ' returns a Collection of all invoices for this patient, most recent first, ordered by display mode (see const.Billing_Accounts constants)
   ' ----------------------------------------------------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "select * from billing.vwItemsBilled where fk_patient = " & fk_patient
   Select Case iAccount_Display_Mode
      Case const.Billing_Accounts_Unpaid
         sql &= " AND paid = false "
      Case const.Billing_Accounts_Paid
         sql &= " AND paid = true "
   End Select
   sql &= " ORDER BY date_invoiced desc "
   Return modDBConnect.exec_query_collection(sql)
   
End

' finds a referral for this patient
' returns NULL if they have no referral
' returns a Collection with name, address, provider_number of referrer,
' and "months": length of referral in months, defaults to 12
' and "indefinite" flag true if indefinite referral
' 
Public Function Find_Referrer(fk_patient As Integer) As Collection
   
   Dim sql As String
   
   sql = "with base as (select title, firstname, surname, provider_number, street1, street2, town, state, postcode, date_created, "
   "comment_on_document ~ 'indefin[ia]te' as indefinite, "
   "coalesce(substring(comment_on_document from '([0-9]+) month')::integer,12) as months "
   "from contacts.vwpersonsemployeesbyoccupation vpe, documents.vwdocuments vd"
   " where vd.fk_sender_person = vpe.fk_person and (vd.fk_sender_branch = vpe.fk_branch or (vpe.fk_branch is null and vd.fk_sender_branch is null)) and "
   " vd.fk_patient = &1 and incoming_referral) "
   "select *,date_created+(months*interval '1 month') as expiry from base order by indefinite desc, expiry desc limit 1 "
   Return modDBConnect.exec_query_first(sql, [fk_patient]) 
   
End

Public Function Get_Billed_Items(invoice As Crow) As Collection
   '-------------------------------------------------------------------
   ' returns a list of billed items for a given invoice, as Collections
   ' CREATE TABLE billing.items_billed
   ' (
   '   pk serial NOT NULL,
   '   fk_fee_schedule integer NOT NULL,
   '   amount money NOT NULL,
   '   fk_invoice integer NOT NULL,
   '   fk_lu_billing_type integer NOT NULL);
   '   ?? we already have this, so why recall from the backend, why not just pass?
   '-------------------------------------------------------------------
   
   Dim sql As String
   ' " left(coalesce(descriptor_brief,descriptor),400) as descriptor_display, "
   sql = "select coalesce(mbs_item,ama_item,user_item) as common_item, "
   "  descriptor_brief As descriptor_display, "
   " * from billing.items_billed i,billing.fee_schedule s where i.fk_fee_schedule = s.pk and i.fk_invoice = &1"
   Return modDBConnect.exec_query_collection(sql, [invoice!fk_invoice])
   
End

Public Function Get_Payments(invoice As Crow) As Collection
   
   Return modDBConnect.exec_query_collection("select p.*, m.method from billing.payments_received p, billing.lu_payment_method m where p.fk_invoice = &1 and m.pk = p.fk_lu_payment_method", [invoice!fk_invoice]) 
   
End

Private Sub Load_FDF_Specialist(fdf As String, invoice As CRow) As String
   
   Return fdf
   
End

Private Sub Load_FDF_GP(fdf As String, doctor As Collection, items As Collection, cc As CConsult, invoice As CRow) As String
   
   Dim s As String
   Dim initial As String
   Dim i As Collection
   Dim no_free_item As Integer = 0
   
   If IsNull(cc!patient!medicare_number) Then 
      cc!patient!medicare_number = "0000000000" 'FIXME PUT THIS IN UNTIL REPAT STUFF SORTED
   End If   
   ' Error.Raise("Medicare number can't be NULL here")
   fdf = Replace$(fdf, "MA1", Mid$(cc!patient!medicare_number, 1, 1))
   fdf = Replace$(fdf, "MA2", Mid$(cc!patient!medicare_number, 2, 1))
   fdf = Replace$(fdf, "MA3", Mid$(cc!patient!medicare_number, 3, 1))
   fdf = Replace$(fdf, "MA4", Mid$(cc!patient!medicare_number, 4, 1))
   fdf = Replace$(fdf, "MA5", Mid$(cc!patient!medicare_number, 5, 1))
   fdf = Replace$(fdf, "MA6", Mid$(cc!patient!medicare_number, 6, 1))
   fdf = Replace$(fdf, "MA7", Mid$(cc!patient!medicare_number, 7, 1))
   fdf = Replace$(fdf, "MA8", Mid$(cc!patient!medicare_number, 8, 1))
   fdf = Replace$(fdf, "MA9", Mid$(cc!patient!medicare_number, 9, 1)) 
   fdf = Replace$(fdf, "MA0", Mid$(cc!patient!medicare_number, 10, 1))
   fdf = Replace$(fdf, "Ref", cc!patient!medicare_ref_number)
   fdf = Replace$(fdf, "Surname", Upper$(cc!patient!surname))
   modUtil.Split_Firstname(cc!patient!firstname, ByRef s, ByRef initial)
   fdf = Replace$(fdf, "Firstname", Upper$(s))
   fdf = Replace$(fdf, "Initial", Upper$(initial))
   fdf = Replace$(fdf, "DOB", Format$(cc!patient!birthdate, "dd/mm/yy"))
   fdf = Replace$(fdf, "Add1", cc!patient!street1 & " " & cc!patient!street2)
   fdf = Replace$(fdf, "Add2", cc!patient!town & " " & cc!patient!postcode)
   s = Format$(invoice!date_invoiced, "ddmmyy")
   fdf = Replace$(fdf, "DD1", Mid$(s, 1, 1))
   fdf = Replace$(fdf, "DD2", Mid$(s, 2, 1))
   fdf = Replace$(fdf, "MM1", Mid$(s, 3, 1))
   fdf = Replace$(fdf, "MM2", Mid$(s, 4, 1))
   fdf = Replace$(fdf, "YY1", Mid$(s, 5, 1))
   fdf = Replace$(fdf, "YY2", Mid$(s, 6, 1))
   fdf = Replace$(fdf, "Provider", doctor!wholename & "\n" & doctor!provider_number)
   For Each i In items
      Select Case i!mbs_item
         Case "3"
            fdf = Replace$(fdf, "cb3", "Yes")
            fdf = Replace$(fdf, "Ben1", i!amount)
            fdf = Replace$(fdf, "Ben2", "")
            fdf = Replace$(fdf, "Ben3", "")
            fdf = Replace$(fdf, "Ben4", "")
         Case "23"
            fdf = Replace$(fdf, "cb23", "Yes")
            fdf = Replace$(fdf, "Ben2", i!amount)
            fdf = Replace$(fdf, "Ben1", "")
            fdf = Replace$(fdf, "Ben3", "")
            fdf = Replace$(fdf, "Ben4", "") 
         Case "36"
            fdf = Replace$(fdf, "cb36", "Yes")
            fdf = Replace$(fdf, "Ben3", i!amount)
            fdf = Replace$(fdf, "Ben2", "")
            fdf = Replace$(fdf, "Ben1", "")
            fdf = Replace$(fdf, "Ben4", "")
         Case "53"
            fdf = Replace$(fdf, "cb53", "Yes")
            fdf = Replace$(fdf, "Ben4", i!amount)
            fdf = Replace$(fdf, "Ben1", "")
            fdf = Replace$(fdf, "Ben3", "")
            fdf = Replace$(fdf, "Ben2", "")
         Case Else
            If IsNull(i!descriptor_brief) Then
               s = i!descriptor
            Else
               s = i!descriptor_brief
            Endif
            If Len(s) > 40 Then s = Left$(s, 40)
            s = Upper$(s)
            While Len(i!mbs_item) < 5 
               i!mbs_item = " " & i!mbs_item
            Wend 
            Select Case no_free_item
               Case 0
                  no_free_item = 1
                  fdf = Replace$(fdf, "Des5", s)
                  fdf = Replace$(fdf, "Item1_1", Mid$(i!mbs_item, 1, 1))
                  fdf = Replace$(fdf, "Item1_2", Mid$(i!mbs_item, 2, 1))
                  fdf = Replace$(fdf, "Item1_3", Mid$(i!mbs_item, 3, 1))
                  fdf = Replace$(fdf, "Item1_4", Mid$(i!mbs_item, 4, 1))
                  fdf = Replace$(fdf, "Item1_5", Mid$(i!mbs_item, 5, 1))
                  s = Format$(modUtil.MoneyToFloat(i!amount), "000.00")
                  fdf = Replace$(fdf, "Ben5_1", Mid$(s, 1, 1))
                  fdf = Replace$(fdf, "Ben5_2", Mid$(s, 2, 1))
                  fdf = Replace$(fdf, "Ben5_3", Mid$(s, 3, 1))
                  fdf = Replace$(fdf, "Ben5_4", Mid$(s, 5, 1))
                  fdf = Replace$(fdf, "Ben5_5", Mid$(s, 6, 1))
               Case 1
                  no_free_item = 2
                  fdf = Replace$(fdf, "Des6", s)
                  s = Format$(modUtil.MoneyToFloat(i!amount), "000.00")
                  fdf = Replace$(fdf, "Item2_1", Mid$(i!mbs_item, 1, 1))
                  fdf = Replace$(fdf, "Item2_2", Mid$(i!mbs_item, 2, 1))
                  fdf = Replace$(fdf, "Item2_3", Mid$(i!mbs_item, 3, 1))
                  fdf = Replace$(fdf, "Item2_4", Mid$(i!mbs_item, 4, 1))
                  fdf = Replace$(fdf, "Item2_5", Mid$(i!mbs_item, 5, 1))
                  fdf = Replace$(fdf, "Ben6_1", Mid$(s, 1, 1))
                  fdf = Replace$(fdf, "Ben6_2", Mid$(s, 2, 1))
                  fdf = Replace$(fdf, "Ben6_3", Mid$(s, 3, 1))
                  fdf = Replace$(fdf, "Ben6_4", Mid$(s, 5, 1))
                  fdf = Replace$(fdf, "Ben6_5", Mid$(s, 6, 1))
            End Select
      End Select
   Next
   If no_free_item < 2 Then
      fdf = Replace$(fdf, "Item2_1", "")
      fdf = Replace$(fdf, "Item2_2", "")
      fdf = Replace$(fdf, "Item2_3", "")
      fdf = Replace$(fdf, "Item2_4", "")
      fdf = Replace$(fdf, "Item2_5", "")
      fdf = Replace$(fdf, "Des6", "")
      fdf = Replace$(fdf, "Ben6_1", "")
      fdf = Replace$(fdf, "Ben6_2", "")
      fdf = Replace$(fdf, "Ben6_3", "")
      fdf = Replace$(fdf, "Ben6_4", "")
      fdf = Replace$(fdf, "Ben6_5", "")    
   Endif
   If no_free_item = 1 Then
      fdf = Replace$(fdf, "Item1_1", "")
      fdf = Replace$(fdf, "Item1_2", "")
      fdf = Replace$(fdf, "Item1_3", "")
      fdf = Replace$(fdf, "Item1_4", "")
      fdf = Replace$(fdf, "Item1_5", "")
      fdf = Replace$(fdf, "Des5", "")
      fdf = Replace$(fdf, "Ben5_1", "")
      fdf = Replace$(fdf, "Ben5_2", "")
      fdf = Replace$(fdf, "Ben5_3", "")
      fdf = Replace$(fdf, "Ben5_4", "")
      fdf = Replace$(fdf, "Ben5_5", "")    
   Endif
   fdf = Replace$(fdf, "Ben4", "")
   fdf = Replace$(fdf, "Ben1", "")
   fdf = Replace$(fdf, "Ben3", "")
   fdf = Replace$(fdf, "Ben2", "") 
   Return fdf 
   
End

' takes a CRow from billing.invoices, from either from Make_Invoice or Invoices_Get, and prints it
' also updates the row on the DB as appropriate
' ' cc is the current consult object. If not provided a new one will be loaded using th invoices's fk_patient.
Public Sub Print_Invoice(invoice_in As Variant, bPrint As Boolean, Optional bBulkBIll As Boolean = False, Optional cc As Cconsult) As String
   '
   
   Dim sql As String
   Dim items As Collection
   Dim payments As Collection
   Dim templ As CTemplate
   Dim doctor As Collection
   Dim i As Collection
   Dim referrer_type As String
   Dim latex As String
   Dim pdfname As String
   Dim fdf As String
   Dim tmpfile As String
   Dim pdftk_path As String
   Dim invoice As CRow
   
   If TypeOf(invoice_in) = gb.Integer Then
      invoice = modUtil.Get_One(modDBConnect.exec_query_row("select * from billing.vwinvoices where fk_invoice = &1", [invoice_in]))
   Else
      invoice = invoice_in
   Endif
   
   If IsNull(cc) Then cc = New CConsult(modContactsDBI.Patient_Get_Using_PK(invoice!fk_patient))
   items = Get_Billed_Items(invoice)
   payments = Get_Payments(invoice)
   sql = "select referrer_type, s.* from common.lu_occupations o, admin.vwstaffinclinics s "
   "where o.pk = s.fk_occupation and s.fk_staff = &1 limit 1"
   doctor = modDBConnect.exec_query_first(sql, [invoice!fk_staff_provided_service])
   referrer_type = doctor!referrer_type
   If bBulkBIll Then 
      ' cue scary music: patient is being bulk-billed
      If referrer_type = "s" Then
         pdfname = "db2-gp"
      Else
         pdfname = "db2-gp"
      Endif
      fdf = File.Load(modUtil.Find_File("templates" &/ pdfname & ".fdf"))
      If referrer_type = "s" Then fdf = Load_FDF_Specialist(fdf, invoice)
      fdf = Load_FDF_GP(fdf, doctor, items, cc, invoice)
      tmpfile = Temp$("bulkbill")
      File.Save(tmpfile & ".fdf", fdf)
      pdftk_path = modUtil.FindProgram("pdftk", "pdftk")
      If IsNull(pdftk_path) Then Return
      Exec [pdftk_path, modUtil.Find_File("templates" &/ pdfname & ".pdf"), "fill_form", tmpfile & ".fdf", "output", tmpfile & ".pdf", "flatten"] Wait
      If bPrint Then modPrinting.Print_PDF(tmpfile & ".pdf", const.Paper_Plain, 1)
      Try Kill tmpfile & ".pdf"
      Try Kill tmpfile & ".fdf"
      Return Null
   Else
      If False Then ' referrer_type = "s" Then  DONT USE SPECIALIST INVOICE FOR A BIT
         ' specialist's account: need to grab referrer's details first
         templ = New CTemplate("templates/invoice-specialist.tex", "tex")
         Load_Template_Specialist(templ, invoice)
      Else
         templ = New CTemplate("templates/invoice-gp.tex", "tex")
      End If   
      Load_Template_GP(invoice, templ, doctor, items, payments, cc)
      latex = templ.GetData()
      Print latex
      If bPrint Then modPrinting.Print_latex(latex, const.Paper_Plain, 1)
      Return latex   
   Endif
   
End

' loads info about specialist rinvoices (i.e. info about the referral)
Private Sub Load_Template_Specialist(templ As Ctemplate, invoice As Crow) 
   
   Dim referrer As Collection
   
   referrer = Find_Referrer(invoice!fk_patient)
   If IsNull(referrer) Then
      ' uh-oh, we can't find a referral for this patient
      templ.Subst("referrer-name", templ.Bold("NONE"))
      templ.Subst("referrer-street1", templ.Bold("As no referrer there can be NO rebate on this account"))
      templ.Subst("referrer-street2", "")
      templ.Subst("referrer-town", "")
      templ.Subst("referrer-postcode", "")
      templ.Subst("referrer-provider-number", templ.Bold("NONE"))
      templ.Subst("referral-duration", "")
      templ.Subst("referral-date", "")
   Else
      templ.Subst("referrer-name", referrer!title & " " & referrer!firstname & " " & referrer!surname)
      templ.Subst("referrer-street1", referrer!street1)
      templ.Subst("referrer-street2", referrer!street2)
      templ.Subst("referrer-town", referrer!town)
      templ.Subst("referrer-postcode", referrer!postcode)
      templ.Subst("referrer-provider-number", referrer!provider_number)
      If referrer!indefinite Then
         templ.Subst("referral-duration", "indefinite duration")
      Else
         templ.Subst("referral-duration", referrer!months & " months")
      Endif
      templ.Subst("referral-date", referrer!date_created)
   Endif
   
End

' prepares the template with stuff for GP-type invoices (actually common to specialists too)    
Private Function Load_Template_GP(invoice As Crow, templ As CTemplate, doctor As Collection, items As Collection, payments As Collection, cc As CConsult)
   
   Dim i As Collection
   
   templ.Subst("doctor-name", doctor!title & " " & doctor!firstname & " " & doctor!surname)
   templ.Subst("doctor-address-line1", doctor!street1)
   If IsNull(doctor!street2) Then
       templ.Subst("doctor-address-line2", doctor!town & " " & doctor!postcode)
       templ.Subst("doctor-address-line3", "\\relax")
   Else
      templ.Subst("doctor-address-line2", doctor!street2)
      templ.Subst("doctor-address-line2", doctor!town & " " & doctor!postcode)
   Endif
   templ.Subst("doctor-provider-number", doctor!provider_number)
   templ.Subst("current-time", Format$(Now, "dd/mm/yy hh:nn"))
   If IsNull(invoice!account_to_name) Then
       templ.Subst("account-to-name", "\\relax")
       Templ.Subst("account-to-address-line1", "\\relax")
       Templ.Subst("account-to-address-line2", "\\relax") 
       Templ.Subst("account-to-address-line3", "\\relax")
      
   Else
      Templ.Subst("account-to-name", invoice!account_to_name)
      'have a name - payer could be person/street1/street2/town + postcode
      'have a name - payer could be organisation/branch/street1/street2/town+postcode
      If Not IsNull(invoice!account_to_branch) Then
         Templ.Subst("account-to-address-line1", invoice!account_to_branch)
         Templ.Subst("account-to-address-line2", invoice!account_to_street)
         Templ.Subst("account-to-address-line3", invoice!account_to_town_postcode) 
      Else 'must be a person
         Templ.Subst("account-to-address-line1", invoice!account_to_street)
         Templ.Subst("account-to-address-line2", invoice!account_to_town_postcode)
         Templ.Subst("account-to-address-line3", "\\relax")
      End If   
   Endif


   ' now do the actual items
   For Each i In items
      templ.Row(Format$(invoice!date_invoiced, "dd/mm/yy"), i!common_item, "\\multicolumn{2}{l}{" & i!descriptor_display & "}", i!amount, "")
   Next
   If Not IsNull(payments) Then
      For Each i In payments 
         templ.Row(Format$(i!date_paid, "dd/mm/yy"), "", "\\multicolumn{2}{l}{Payment: " & i!method & " " & i!referent & "}", "", i!amount)
      Next
   Endif
   
   templ.Table("accounts-table")
   templ.Subst("due", invoice!due)
   templ.Subst("gst", invoice!total_gst)
   templ.Subst("total", invoice!total_bill)
   If invoice!total_gst = invoice!total_bill Then
      templ.Subst("invoice-name", "Patient Account")
   Else
      templ.Subst("invoice-name", "Tax Invoice")
   Endif
   templ.Subst_common(cc)
   
End
Private Function Load_Template_GP_old(invoice As Crow, templ As CTemplate, doctor As Collection, items As Collection, payments As Collection, cc As CConsult)
   
   Dim i As Collection
   
   templ.Subst("doctor-name", doctor!title & " " & doctor!firstname & " " & doctor!surname)
   templ.Subst("doctor-street1", doctor!street1)
   templ.Subst("doctor-street2", doctor!street2)
   templ.Subst("doctor-town", doctor!town)
   templ.Subst("doctor-postcode", doctor!postcode)
   templ.Subst("doctor-provider-number", doctor!provider_number)
   templ.Subst("current-time", Format$(Now, "dd/mm/yy hh:nn"))
   If Not IsNull(invoice!account_to_name) Then
      Templ.Subst("account-to-name", invoice!account_to_name)
   Else
      templ.Subst("account-to-name", "\\relax")
   End If
   If Not IsNull(invoice!account_to_branch) Then
      Templ.Subst("account-to-branch", invoice!account_to_branch)
   Else
      templ.Subst("account-to-branch", "\\relax")
   End If
   If Not IsNull(invoice!account_to_street) Then
      templ.Subst("account-to-street", invoice!account_to_street)
   Else
      templ.Subst("account-to-street", "\\relax")
   Endif
   If Not IsNull(invoice!account_to_town_postcode) Then
      templ.Subst("account-to-town-postcode", invoice!account_to_town_postcode)
   Else
      templ.Subst("account-to-town-postcode", "\\relax")
   Endif
   ' now do the actual items
   For Each i In items
      templ.Row(Format$(invoice!date_invoiced, "dd/mm/yy"), i!common_item, "\\multicolumn{2}{l}{" & i!descriptor_display & "}", i!amount, "")
   Next
   If Not IsNull(payments) Then
      For Each i In payments 
         templ.Row(Format$(i!date_paid, "dd/mm/yy"), "", "\\multicolumn{2}{l}{Payment: " & i!method & " " & i!referent & "}", "", i!amount)
      Next
   Endif
   
   templ.Table("accounts-table")
   templ.Subst("due", invoice!due)
   templ.Subst("gst", invoice!total_gst)
   templ.Subst("total", invoice!total_bill)
   If invoice!total_gst = invoice!total_bill Then
      templ.Subst("invoice-name", "Patient Account")
   Else
      templ.Subst("invoice-name", "Tax Invoice")
   Endif
   templ.Subst_common(cc)
   
End
Public Sub Receipts_Get_For_Day(D As Date) As Collection 
   '----------------------------------------------------------------------
   'Gets receipts for the day (currently all doctors) fixme subdivide this
   '----------------------payments------------------------------------------------   

   Dim sql As String
   
   ' sql = "select pk_payments_received, fk_invoice, payer_details, patient_wholename,method as payment_method, amount as amount_paid, "
   sql = "select * from billing.vwpayments where date_paid = "
   '    "date_paid from billing.vwpayments where date_paid = "
   sql &= "'" & Format$(D, "dd/mm/yyyy") & "'" 
   Return modDBConnect.exec_query_collection(sql) 
   
End

Public Sub UnitTest(main_form As Form)
   ' 
   
   Dim r As Collection
   Dim invoice As New CRow
   Dim item1 As Collection
   Dim item2 As Collection
   
   item1 = modUtil.Get_One(Descriptors_Get("23", True, True))
   item2 = modUtil.Get_One(Descriptors_Get("308", True, True))
   modDBConnect.exec_query("truncate billing.invoices cascade")
   invoice!fk_patient = 1
   invoice!fk_staff_invoicing = 1
   invoice!fk_staff_provided_service = 1
   invoice!notes = "this is a fake test invoice"
   invoice!date_invoiced = Now
   invoice.Save("billing.invoices", "fk_invoice")
   Save_Items(invoice!fk_invoice, [item1, item2], False)
   modDBConnect.exec_query("insert into billing.payments_received(fk_lu_payment_method, amount, fk_invoice) values (1,'$100.00', &1)", [invoice!fk_invoice])
   Print_Invoice(invoice!fk_invoice, True)
   
End


