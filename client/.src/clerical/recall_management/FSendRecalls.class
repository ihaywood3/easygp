' Gambas class file

' Copyright (C) 2008-2012 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'
' A module for administering logged recalls
'----------------------------------------------------------------------
'TODO      
'           put the audit trail in for notified by phone
'----------------------------------------------------------------------
Private recalls_due As Collection
Private bexit As Boolean
Private patient As Collection
Private currentconsult As CConsult
Private templates As Collection
Private currentRecall As Collection
Private Results As Collection
Private Letters As Collection
Private CurrentObservations As Collection
Private synonyms As Collection

Public Sub form_Open()
   
   Init()
   
End

Public Sub Init()
   
   With cvwRecallsDue
      .columns.count = 10
      .Columns[0].Text = "Date Due"
      .Columns[1].Text = "Firstname"
      .Columns[2].Text = "Surname"
      .Columns[3].Text = "Street"
      .Columns[4].Text = "Reason"
      .Columns[5].Text = "Urgency"
      .Columns[6].Text = "By"
      .Columns[7].Text = "Last Done"
      .Columns[8].Text = "# Sent"
      .Columns[9].Text = "Template"
      
   End With
   With cvwRecallsPatient             
      .Clear()
      .Columns.count = 2
      .Columns[0].width = 60
      .Columns[1].width = 200
   End With
   cmbRecallsDue.Add("All Overdue Recalls")
   cmbRecallsDue.Add("Due in 2 Weeks")
   cmbRecallsDue.Add("Due in 3 Weeks")
   cmbRecallsDue.Add("Due in Next Month")
   cvwRecallsDue_Refresh(0, True)              'days overdue and overdue
   Try Settings_Load()
   
End

Public Sub Consult_Check_Created()
   '------------------------------------------------------------
   'probably should live elsewhere ?cConsult and pass parameters
   'see const for types of consult
   '------------------------------------------------------------

   If IsNull(currentconsult) Then   
      CurrentConsult = New CConsult(patient)
      currentconsult.Set(const.cAuditAction_ReminderSent, "recall")
   End If
   
End

Public Sub cvwRecallsDue_Refresh(Optional days_due As Integer = 0, Optional bOverdue As Boolean = False)
   '----------------------------
   'Refresh the recalls due list
   '----------------------------   

   Dim x As Integer
   Dim recall As Collection
   
   cvwRecallsDue.Clear()
   templates = modRecallsDBI.Templates_Get()           'could have been updated
   recalls_due = modRecallsDBI.Recalls_Due_Get()       'always refresh collection
   For Each recall In recalls_due
      If bOverdue Then
         If recall!days_due < 0 Then
            cvwRecallsPatient_Add(recall)
         End If
      Else
         If recall!days_due < days_due And recall!days_due > 0 Then
            cvwRecallsPatient_Add(recall)
         Endif
      End If   
   Next
   
End

Public Sub cvwRecallsPatient_Add(recall As Collection)
   
   Dim x As Integer
   
   x = recall!pk_recall
   cvwRecallsDue.add(x, 0)
   cvwRecallsDue[x][0] = Format(recall!due, "dd/mm/yyyy")
   cvwRecallsDue[x][1] = recall!firstname
   cvwRecallsDue[x][2] = recall!surname
   cvwRecallsDue[x][3] = Trim(recall!street1 & " " & recall!street2) & " " & recall!town & " " & recall!postcode 
   cvwRecallsDue[x][4] = recall!reason
   cvwRecallsDue[x][5] = recall!urgency
   cvwRecallsDue[x][6] = recall!contact_method
   Try cvwRecallsDue[x][7] = Format(recall!date_reminder_sent, "dd/mm/yyyy") 'may not exist
   cvwRecallsDue[x][8] = recall!num_reminders
   cvwRecallsDue[x][9] = recall!name                  'of the template
   
End

Public Sub cmbRecallsDue_Click()
   '---------------------------------------------------------------
   'User has clicked the combo with options for time recalls due in
   '---------------------------------------------------------------   

   Select Case cmbRecallsDue.Text
      Case "All Overdue Recalls"
         cvwRecallsDue_Refresh(0, True)
      Case "Due in 2 Weeks"
         cvwRecallsDue_Refresh(15, False)
      Case "Due in 3 Weeks"
         cvwRecallsDue_Refresh(22, False)
      Case "Due in Next Month"
         cvwRecallsDue_Refresh(29, False)
   End Select
   
End

Public Sub Settings_Save()
   '-----------------------
   'Called from parent form
   '-----------------------   

   Settings[Me.Name & "/Vsplit.Layout"] = Vsplit1.Layout
   Settings[Me.Name & "/Hsplit.Layout"] = Hsplit1.Layout
   
End

Private Sub Settings_Load()
   '-------------------------------------------------------------------
   'Load settings, the fonts are saved in the relevant mnu_click events
   '-------------------------------------------------------------------
   
   Vsplit1.Layout = Settings[Me.Name & "/Vsplit.Layout"]
   Hsplit1.Layout = Settings[Me.Name & "/Hsplit.Layout"]
   Try cvwResults.Font = Font[Settings[Me.Name & "/cvwResults.font"]]
   Try cvwLettersReceived.font = Font[Settings[Me.Name & "/cvwLettersReceived.font"]]
   Try cvwRecallsDue.font = Font[Settings[Me.Name & "/cvwRecallsDue.font"]]
   
End

Public Sub mnuRecallManagement_Click()
   '----------------------------------------
   'The popup menu over the recalls due list
   '----------------------------------------   

   Dim x As Integer
   
   Select Case Last.tag
         
      Case "arranged by phone"
         modUtil.NotImplemented("Arranging by phone") 
         Return 
      Case "select all and print"
          cvwRecallsDue.SelectAll()
          Print()
          Return 
      Case "print for mailing"
         cvwRecallsDue.MoveFirst() 
         For x = 0 To cvwRecallsDue.count - 1
            If cvwRecallsDue.Item.Selected = True Then
               Print()
            Endif
            cvwRecallsDue.MoveNext()
         Next
         cvwRecallsDue.UnselectAll()
         cvwRecallsDue_Refresh(0, True)
      Case "font"
         modUtil.Columnview_SetFont(cvwRecallsDue, Me.Name) 
         Return 
      Case "help"
         modUtil.NotImplemented("Help for the recalls maintenance module") 
         Return 
      Case "exit"
         Return  
      Case Else      'tag is numerical
         modRecallsMenu.Process(currentrecall, Last.tag, currentconsult)
   End Select
   cmbRecallsDue_Click()

End

Public Sub cvwRecallsDue_Menu()
   '----------------------------------------
   'The popup menu over the recalls due list
   '----------------------------------------

   If Not Last.count Then Return
   cvwRecallsDue.MoveCurrent()
   currentRecall = recalls_due[cvwRecallsDue.Item.Key]
   mnuRecallManagement_RepeatSameInterval.caption = "Mark Completed Repeat in " & currentrecall!interval & currentrecall!abbrev_text
   mnuRecallManagement.Popup()
   
End

Public Sub Print()
   '--------------------------------------------------------------------
   'Print the recall letter
   '   pk serial NOT NULL,
   '   fk_recall integer NOT NULL, -- key to clin_recalls.recall table
   '   date date NOT NULL, -- the date the reminder for the recall was processed
   '   latex text NOT NULL, -- the latex definition of the recall reminder sent
   '   fk_contact_method integer NOT NULL, -- key to contacts.lu_contact_type table e.g could point to letter/phone
   '   contact_value text, -- if not null contact via this text eg mobile phone, voip, email
   '   fk_staff integer, -- key to admin.staff table staff member who prepared the letter
   '   memo text, -- memo added by staff at the time e.g could have called patient who said they would make appointment
   '---------------------------------------------------------------------------

   Dim laTex As String                                                'LaTex definition of the letter
   Dim sent As New Collection
   Dim audit_notes As String
  
   currentRecall = recalls_due[cvwRecallsDue.Item.Key] 
   currentconsult = Null
   patient = currentRecall
   Consult_Check_Created()
   laTex = RecallLetter_LaTex_Construct().GetData()                     'get the letter definition
   '---------------------------------------------------------------
   'get the data together about how reminder was sent and save this  
   '---------------------------------------------------------------   
   sent!fk_recall = currentRecall!pk_recall                                                                                '
   sent!date = Now()
   sent!latex = laTex
   sent!fk_contact_method = const.ContactMethodLetter
   sent!fk_staff = modDBConnect.currentUser!fk_staff
   sent!pk = modDBConnect.insert("clin_recalls.sent", sent) 
   '-------------------------------------------------------------------------------------
   'Now update the actual recall so that it knows the last fk_sent and incr num_reminders
   '------------------------------------------------------------------------------------- 
   modDBConnect.update("clin_recalls.recalls", Null, ["pk": currentRecall!pk_recall, "fk_sent": sent!pk])
   modDBConnect.update("clin_recalls.recalls", Null, ["pk": currentRecall!pk_recall, "num_reminders": recalls_due[cvwRecallsDue.Item.Key]!num_reminders + 1])
   '---------------------------------------------------------------------------------------------------------------------------
   'Now the audit trail this will always be linked to the recall, so viewable e.g in FClinical using menu over the recalls list
   '---------------------------------------------------------------------------------------------------------------------------
   audit_notes = "letter sent to " & Trim(currentconsult!patient!street1 & " " & currentconsult!patient!street2) & " " & currentconsult!patient!town & " " & currentconsult!patient!postcode
   
   If modAudit.MakeAudit(currentconsult, const.sAuditAction[const.cAuditAction_ReminderSent], "clin_recalls.recalls", currentrecall!pk_recall, const.cSection_Recalls, audit_notes) Then 
      modDBConnect.CommitTrans()
      modPrinting.Print_latex(RecallLetter_LaTex_Construct().GetData(), const.Paper_Plain, 1)
   Else
      modDBConnect.RollBack()
   End If    
   
End

Public Sub RecallLetter_LaTex_Construct() As CTemplate
   '------------------------------------------
   'Construct the LaTex to send to the printer
   '------------------------------------------
   
   Dim sName As String
   Dim sAddress As String
   Dim sString As String
   Dim comm As Collection 
   Dim templ As New CTemplate("recall", "tex")
   Dim sStafftosee As String 
   
   templ.Subst_common(currentconsult)
   sString = UCase(Left(currentRecall!reason)) & Right(currentRecall!reason, Len(currentRecall!reason) - 1) & " (" & currentRecall!urgency & ")"
   templ.Subst("recall_details", sSTring)
   If Not IsNull(currentRecall!additional_text) Then
      templ.Subst("additional_text", currentRecall!additional_text)
   Else
      templ.Subst("additional_text", "\\relax")
   Endif
   
   sStafftosee = Trim(currentRecall!staff_to_see_title & " " & currentRecall!staff_to_see_firstname & " " & currentRecall!staff_to_see_surname)
   templ.Subst("staff_to_see", sStafftosee)
   '--------------------------------------------------------------------
   'Template appointment length, over-rides the recall appointment lengh
   'it's more likely the doctor just forgot the right length
   '--------------------------------------------------------------------
   ' templ.Subst("consult_length", currentRecall!appointment_length)
   If Not IsNull(currentRecall!fk_template) Then
      If currentRecall!fk_template <> 1 Then   '1= set back to no template
         templ.Subst_html("template", Templates[currentRecall!fk_template]!template) 'currently have fudged html see FRecallLetterTemplate.Save()
         templ.Subst("consult_length", Templates[currentRecall!fk_template]!length) 
      Else
         templ.Subst("consult_length", currentRecall!appointment_length)  
         templ.Subst("template", "\\relax") 
      End If  
   Else   
      templ.Subst("consult_length", currentRecall!appointment_length) 
      templ.Subst("template", "\\relax") 
   Endif
     templ.Subst("staff_logged_on", modDBConnect.currentUser_FullName())
   Return templ
   
End


Public Sub cvwRecallsDue_Select()
   '-------------------------------------------------------------------------------------
   'User has selected one of the overdue recalls
   'show any letters/results for the user to aid staff in seeing if sending recall needed
   '-------------------------------------------------------------------------------------   
   
   Dim x As Integer
   Dim Selected As Integer
   
   Inc Application.Busy
   currentconsult = Null
   
   txtInboxResults_Exclude.text = ""
   txtInboxResults_filter.text = ""
   txtLetterFilterAuthor.text = ""
   txtLetterFilterTag.text = ""
   cvwResults.Clear()                            'yes duplicated but don't remove
   cvwLettersReceived.Clear()
   cvwRecallsDue.MoveCurrent()
   currentRecall = recalls_due[cvwRecallsDue.Item.Key]
   patient = currentRecall                       'contains fk_patient, fk_person, name/address
   Consult_Check_Created()                       'create consult if not yet done
   lblpatient.text = "  " & patient!wholename
   cvwResults_Refresh()
   cvwLettersReceived_Refresh()
   cvwRecallsPatient_Refresh()
   Dec Application.Busy 
   
End

Public Sub cvwRecallsPatient_Refresh()
   Dim x As Integer
   
   currentconsult.Refresh("recalls_logged")
   cvwRecallsPatient.Clear()
   For Each currentconsult!recalls_logged
      x = currentconsult!recalls_logged.Key                        'readability
      '---------------------------------------------------------
      'Display in the recalls list on the tabstrip_lists control
      '---------------------------------------------------------
      cvwRecallsPatient.Add(x, 0)
      cvwRecallsPatient[x][0] = Format(currentconsult!recalls_logged[x]!due, "dd/mm/yyyy")
      cvwRecallsPatient[x][1] = currentconsult!recalls_logged[x]!reason 
   Next
End

Public Sub cvwResults_Refresh(Optional bRefresh As Boolean = False)
   '-------------------------------------------
   'Shows any results received for this patient
   '-------------------------------------------   
   Dim x As Integer                      'for readability = key
   Dim results_received As Collection 
   Dim filter As String
   Dim exclude As String 
   Dim result_received As String 
   Dim guessed_user_Name As Collection 
   Dim colsizes As String[]
   
  
   If txtInboxResults_filter.text <> "" Then
      filter = txtInboxResults_filter.text
   End If
   If txtInboxResults_Exclude.text <> "" Then
      exclude = txtInboxResults_Exclude.text & ";"
   Endif
   cvwResults.Clear()
   With cvwResults
      .Columns.count = 3
      .Columns[0].width = 80
    End With
   
   For Each results_received In currentconsult!results_received
      result_received = ""
      If filter = "" And exclude = "" Then
         If IsNull(results_received!tag_user) Then                         'not user tag = document not filed
            'attempt to guess the user tag
            CurrentObservations = modDBConnect.exec_query_collection("Select  * from documents.observations where fk_document =" & results_received!pk_document & " ORDER BY observations.observation_date, set_id")
            guessed_user_Name = modParseDocument.Guess_UserName(currentconsult, const.synonyms(), results_received, CurrentObservations)
            If Not IsNull(guessed_user_Name!name) Then
               result_received = "** UNFILED **:" & guessed_user_Name!name
            Else
               result_received = "** UNFILED RESULT **:"
            End If
         Else
            result_received = results_received!tag_user
         End If
      Else
         If exclude Then
            If Lower(results_received!tag_user) <> Lower(exclude) Then 
               result_received = results_received!tag_user
            Endif
         Else
            If results_received!tag_user = "" And InStr("unfiled", Lower(filter)) Then
               result_received = "** UNFILED **:"
            Else
               If InStr(Lower(results_received!tag_user), filter) Then 
                  result_received = results_received!tag_user
               Endif
            End If
         End If
      End If
      If result_received <> "" Then 
         x = results_received!pk_document
         cvwResults.Add(x, 0)
         cvwResults[x][0] = Format(results_received!date_created, "dd/mm/yyyy")
         cvwResults[x][1] = result_received 
      End If   
   Next
   
End

Public Sub cvwLettersReceived_Refresh(Optional bRefresh As Boolean = False)
   '------------------------------------------------------------------------------
   'Show all letters received
   'If appropriate, filter display according to the document tag or letter author
   'IAN FIXME: REPLACE ME WITH A RELATIVE ONE-LINER.
   '-----------------------------------------------------------------------------
   
   Dim x As Integer                      'for readability = key
   Dim letters_received As Collection 
   Dim bSkip As Boolean
   Dim tag As String
   Dim author As String
   
   Consult_Check_Created()                                              'check consult created
   With cvwLettersReceived                   
      .Clear()
      .Columns.count = 3
      .Columns[0].Width = 80
      .Columns[1].Width = 150 
   End With 
   '--------------------------------------------------------------
   'Loop through the collection, the key of the columnview becomes
   'the primary key of clin_requests.inbox_general 
   'When documents have been filed - user could have inadvertantly
   'pasted in an invisible CR \n line, which causes the list to
   'span muliple lines, so fix this 
   '-------------------------------------------------------------- 
   If bRefresh Then currentconsult.Refresh("letters_received")   
   For Each letters_received In currentconsult!letters_received  
      bSkip = False                 
      x = letters_received!pk_document 
      '---------------------------------------
      'Does the user want to filter on author?
      '---------------------------------------
      If txtLetterFilterAuthor.text <> "" Then  'Or txtDocumentFilterTag.text <> "" Then
         '---------------------------------------------------------------------------------------------
         ' Yes: User wants to filter by author, if what they are looking for not found, skip the record  
         '---------------------------------------------------------------------------------------------
         If Not InStr(Lower(letters_received!originator), Trim(Lower(txtLetterFilterAuthor.text))) Then
            bskip = True
         Else
            '---------------------------------------------------------------------
            'Have found the author bit, now do they want a particular tag as well?
            '---------------------------------------------------------------------
            If txtLetterFilterTag.text <> "" Then
               If Not InStr(Lower(letters_received!tag_user), Trim(Lower(txtLetterFilterTag.text))) Then
                  bskip = True
               Else
                  bskip = False 
               End If
            Else
               bskip = False 
            Endif
            
         End If
      Else
         '------------------------------------------------------------------
         'User dosn't want to filter on author - how about just on user tag?
         '------------------------------------------------------------------
         If txtLetterFilterTag.text <> "" Then
            If letters_received!tag_user = "" Then
               If Not InStr(Lower("unfiled"), Trim(Lower(txtLetterFilterTag.text))) Then
                  bskip = True
               Else
                  bskip = False
               End If
            Else
               If Not InStr(Lower(letters_received!tag_user), Trim(Lower(txtLetterFilterTag.text))) Then
                  bskip = True
               Else
                  bskip = False 
               End If
            End If
         Endif
      End If
      
      If bskip = False Then 
         cvwLettersReceived.Add(x, 0)
         If IsNull(letters_received!date_created) Then   'fixme remove me when bug fixed in FMetadata
            Message.info("This letter has no date - there is a bug in EasyGP as it should not have been possible to file this,\n\nPlease contact the developers with details")
         Else
            cvwLettersReceived[x][0] = Format(letters_received!date_created, "dd/mm/yyyy")
         End If   
         If letters_received!tag_user = "" Then
            cvwLettersReceived[x][1] = "** UNFILED LETTER **"
         Else
            cvwLettersReceived[x][1] = Replace$(letters_received!tag_user, "\n", "")
         End If
         cvwLettersReceived[x][2] = letters_received!originator
      End If   
   Next
   If cvwLettersReceived.count = 0 Then
      'If have run out of letters, eg could have just been filing unfiled ones,reload the list
      If txtLetterFilterAuthor.text <> "" Or txtLetterFilterTag.text <> "" Then 
         txtLetterFilterAuthor.text = ""
         txtLetterFilterTag.text = ""
         cvwLettersReceived_Refresh() 'try again
      End If
   Endif
   
End

Public Sub DocumentFilter_KeyRelease()
   '-------------------------------------------------------------------------
   'User wants to filter document on either tag or who sent them 'originator'
   '-------------------------------------------------------------------------
   If IsNull(currentconsult) Or bExit Then Return 
   Select Case Last.tag
      Case "tag"
         cvwLettersReceived_Refresh()
      Case "author"
         cvwLettersReceived_Refresh()
   End Select  
   
End

Public Sub InboxResults_KeyRelease()
   '-----------------------------------------------------------------------
   'User has typed in one of the two textboxes underneath the results inbox
   'fixme duplicated in Fclinical as are the cvwRecalls/Letters
   'needs moving out
   '-----------------------------------------------------------------------
   
   If Bexit Then Return 
   Select Case Last.tag
      Case "exclude"
         bExit = True
         txtInboxResults_filter.text = ""
         bexit = False
      Case "filter"
         bExit = True
         txtInboxResults_Exclude.text = ""
         bexit = False
   End Select
   cvwResults_Refresh()
   
End

Public Sub cvwResults_Menu()
      
   If Last.count Then
      mnuResults.Popup() 
   Endif
   
End

Public Sub mnuResults_Click()
   
   Select Case Last.tag
      Case "view"
         Result_View() 
      Case "font"
         modUtil.Columnview_SetFont(cvwResults, Me.name)
   End Select 
   
End

Public Sub Result_View()
   
   modUtil.NotImplemented("Viewing results")
   
End

Public Sub cvwLettersReceived_Menu()
   
   If Last.count Then
      mnuLetters.Popup() 
   Endif
   
End

Public Sub mnuLetters_Click()
   
   Select Case Last.tag
      Case "view"
         Letter_View() 
      Case "font"
         modUtil.Columnview_SetFont(cvwLettersReceived, Me.name)
   End Select 
   
End

Public Sub Letter_View()
   
   modUtil.NotImplemented("Viewing letters")
   
End
