' Gambas module file

' Copyright (C) 2008-2011 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'----------------------------------------------------------------------
'
Private $hConn As Connection
Private $Result As Result
Private sql As String
Private aCollection As Collection
Private x As Integer

Public Function Letters_Received_Get(fk_patient As Integer) As Collection ', Optional user_tag As String = "", Optional originator As String = "", Optional fk_sending_entity As Integer = 0)
   '------------------------------------------------------------------------------------------------------
   'Return a collection of all documents received for this patient 
   'which are not a result, order newest to oldest, whether filed or not
   'orginator = the sender eg Dr Joe Blogs
   'tag_user = the users document tag e.g 'Assessment of IHD i.e that entered when the document was filed
   '-----------------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from documents.vwDocuments where fk_patient = " & fk_patient
   sql &= " AND fk_lu_display_as = " & const.Document_Display_As_Letter & " AND deleted = false" 
   sql &= " ORDER BY date_created desc"
   Return modDBConnect.exec_query_collection(sql)
   
End
' Public Function Referral_Delete(cons As cConsult, ref As cReferral, audit As cAudit) As Boolean
'  '------------------------------------------------------------------------
'  'Deletes a referral, keeps the referral_pk on the referral_undelete stack
'  'TODO THIS FIX ME   
'  '------------------------------------------------------------------------
'    
'    If ref.fk_consult = cons.pk_consult Then
'       modDBConnect.BeginTrans()
'       sql = "Update  clin_referrals.referrals "
'       sql &= "SET deleted = 't' WHERE pk = "
'       sql &= ref.pk
'       modDBConnect.exec_query(sql)
'       modConsultDBI.Audit_Save(audit)
'    Else
'    
'    End If
'    
'    Return modDBConnect.CommitTrans()
'  
' End

Public Function Referrals_Written_This_Consult_Get(fk_patient As Integer) As Collection
   '----------------------------------------------------------------------------------------------------------
   'Returns collection of letters on same date by same doctor - this allows editing of mis-printed letters
   '---------------------------------------------------------------------------------------------------------- 
   
   Dim sql As String
   
   sql = "Select * from clin_referrals.vwReferrals WHERE fk_patient = " & fk_patient
   sql &= " AND fk_staff = " & modDBConnect.currentUser!fk_staff 
   sql &= " AND date(consult_date) = '" & Format(Now, "dd/mm/yyyy") & "'::date "
   sql &= " AND deleted = False"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Referrals_written_get(fk_patient As Integer) As Collection
   '-------------------------------------------------------------------
   'PURPOSE: Gets all referral  letters or other outgoing letters
   '         but not recall letters for the patient
   'EXPECTS: key to consult.patients table
   'RETURNS: A collection of referrals written in newest to oldest order
   '
   '--------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from clin_referrals.vwReferrals where fk_patient = " & fk_patient
   sql &= " AND fk_type <>" & const.ReferralType_Recall
   sql &= " AND fk_type <>" & const.ReferralType_ImportedRecall
   sql &= " AND deleted = False"
   sql &= " ORDER BY date_referral DESC"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Referral_Get_Types() As Collection 
   '-------------------------------------------------------------
   'Gets a list of types of referrals e.g 'Opinion', 'Management'
   'Do not want these ordered alphabetically
   'I've put the most commonly used types in order
   '-------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * From clin_referrals.lu_type")
   
End

Public Function UnDelete(pk_referral As Integer)
   '--------------------------------------------------
   'Marks as not deleted a previously deleted referral
   'Quicker than using Save()
   '-------------------------------------------------- 
   
   modDBConnect.exec_query("Update clin_referrals.referrals set deleted = False where pk = " & pk_referral)
   
End

Public Function Inclusions_Get(fk_patient As Integer, Optional bdeleted As Boolean = False, Optional bThisConsult As Boolean = False, Optional fk_referral As Integer = 0) As Collection 
  '-----------------------------------------------------------------------------------------------------------------------
  'Gets inclusions for patients referrals, either the entire collection or optionally only for current day of consultation
  '-----------------------------------------------------------------------------------------------------------------------
  Dim sql As String

  sql = "Select * from clin_referrals.vwInclusions where fk_patient = " & fk_patient & "  AND deleted = " 
  If bdeleted Then
    sql &= "True"
  Else
     sql &= "False" 
  Endif
  If bThisConsult Then
      sql &= " AND date(consult_date) = '" & Format(Now, "dd/mm/yyyy") & "'::date "
  Endif
  If fk_referral Then   'limit inclusions to a single referral
     sql &= " AND fk_referral = " & fk_referral  
  Endif
  Return modDBConnect.exec_query_collection(sql)
End


Public Function Save(currentconsult As CConsult, old_pk As Integer, referral As Collection, inclusions As Collection) As Integer 
   '----------------------
   'Saves a referral letter
   'FIXME - USE REFERRAL-SAVE_OLD TO WRITE INTO PROGRESS NOTE
   '-----------------------

   Dim inclusion As Collection
   
   If old_pk < 0 Then
      referral!fk_consult = currentconsult.GetPK()
      referral!pk_referral = modDBConnect.insert("clin_referrals.referrals", referral)
   Else
      modDBConnect.update("clin_referrals.referrals", currentconsult!referrals_written[old_pk], referral, "pk_referral")
   End If
   
   For Each inclusion In inclusions
      inclusion!fk_referral = referral!pk_referral
      If IsNull(inclusion!pk_inclusion) Then
         inclusion!pk_inclusion = modDBConnect.insert("clin_referrals.inclusions", inclusion)
      Else
         modDBConnect.update("clin_referrals.inclusions", inclusions[inclusion!pk_inclusion], inclusion, "pk_inclusion") 
      Endif
   Next
   Return referral!pk_referral
   
End

Public Function Organisations_Get_For_Employee(fk_person As Integer) As Collection
   '--------------------------------------------------------------------------------------
   'Gets a list of all organsisations the chosen person is in in vwOrganisationsEmployees
   'note we use the fk_person, not the fk_employee as fk_person is unique, but
   'same person could be employed in multiple places, and have multiple fk_employee's
   '-------------------------------------------------------------------------------------
   ' Dim $CommsResult As result
   ' Dim comm As cComm
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwOrganisationsEmployees WHERE fk_person = " & fk_person)
   
End

' Public Function Person_Get_Distinct(txtName As String, Optional bPatient As Boolean = False) As Collection
'    '------------------------------
'    'return a collection of persons
'    '------------------------------
' 
'    Dim bits As New String[]
'    Dim sql As String    
'    
'    bits = Split(txtName, ",")
'    sql = "Select * from contacts.vwPersonsOrEmployees_By_Occupation WHERE  " 
'    If bits.count = 2 Then
'       sql &= "surname ILIKE $$%" & bits[0] & "%$$ AND firstname ILIKE $$%" & bits[1] & "%$$ " 
'    Else
'       sql &= " surname  ILIKE $$%" & txtName & "%$$ "
'    Endif
'    sql &= " LIMIT 20"
'    Return modDBConnect.exec_query_collection(sql)
' 
' End

Public Function Persons_Addresses_Get(fk_person As Integer) As Collection
   '---------------------------------------------------------------------
   'Get collection of addresses for person either when the contacts entry
   'is as an employee of organisation, or as a person at an address which
   'does not belong to a company
   '----------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from contacts.vwPersonsAndEmployeesAddresses where fk_person = " & fk_person
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Person_Get_By_Surname(txtName As String) As Collection
   '-------------------------------------------------------------------------
   'return a collection of persons by surname, either employee or sole trader
   '-------------------------------------------------------------------------
   
   Dim bits As New String[]
   Dim sql As String    
   
   bits = Split(txtName, ",")
   sql = "Select * from contacts.vwPersonsEmployeesByOccupation WHERE  " 
   If bits.count = 2 Then
      sql &= "surname ILIKE $$%" & bits[0] & "%$$ AND firstname ILIKE $$%" & bits[1] & "%$$ " 
   Else
      sql &= " surname  ILIKE $$%" & txtName & "%$$ "
   Endif
   sql &= " LIMIT 40"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Persons_Get_By_Occupation(occupation As String) As Collection
   '--------------------------------------------------------
   'Gets a list of people by occupation either employee or person
   '---------------------------------------------------------
   
   sql = "Select * from contacts.vwPersonsEmployeesByOccupation where occupation ILIKE $$%" 
   sql &= occupation & "%$$ LIMIT 40"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Comms_Get(fk_employee As Integer) As Result
   'FIX ME USE THE ONE ON CONTACTSDBI AND REMOVE THIS
   
   Dim sql As String
   Dim $Result As Result
   
   sql = "Select " 
   " COMMS.pk,"
   " COMMS.value,"
   " COMMS.note,"
   " COMMS.preferred_method,"
   " COMMS.confidential,"
   " COMMS.deleted,"
   " COMMS.fk_type, "
   " TYPES.type"
   " From "
   " contacts.data_communications COMMS "
   " INNER JOIN contacts.links_employees_comms ON(COMMS.pk = contacts.links_employees_comms.fk_comm) "
   "  INNER JOIN contacts.lu_contact_type TYPES ON(COMMS.fk_type = TYPES.pk) "
   "WHERE "
   sql = sql & "contacts.links_employees_comms.fk_employee = " & fk_employee
   $Result = modDBConnect.exec_query(sql)
   
   Return $Result
   
End

Public Sub Referral_Print_AS_HTML(currentconsult As CConsult, referral As Collection, bPrintCopies As Boolean, Optional Inclusions As Collection)
   '-----------------------------------------------------------------------------------------------------------------
   'Print the referral letter, appropriate copies, inclusions - may be null e.g none - or only re-printing the letter
   '-----------------------------------------------------------------------------------------------------------------
   
   Dim inclusion As Collection
   Dim x As Integer
   Dim num_copies As Integer   
   Dim Document As Collection
   Dim file_extension As String
   Dim extra_copies As Integer
   num_copies = 1                      'always want single copy
   If bPrintCopies Then 
      extra_copies = Max(Split(referral!copyto, "|").Count, 0) 
      If extra_copies Then
         num_copies = num_copies + extra_copies                 'plus the extra copies we need
      End If
   End If   
    
   For x = 1 To num_copies 
      modPrinting.PrintHtml(referral!letter_html, const.Paper_Plain)
      If referral!include_healthsummary = True Then
         modPrinting.PrintHtml(modProgressNotes.Health_Summary_Construct_html(currentconsult), const.Paper_Plain)
      End If
      If referral!include_careplan = True Then
         modPrinting.PrintHtml(modProgressNotes.Care_Plan_Construct_html(currentconsult), const.Paper_Plain)
      End If  
      '------------------------------------------------------------------------------------
      'Now print any included documents which were dragged'n dropped to the inclusions list
      'FIXME: just first go, need to take into account document type in more thorough way
      'At moment, I'm only allowing drag and drop of letters recieved or hl7 recieved
      '------------------------------------------------------------------------------------
      If Not IsNull(inclusions) Then 
         For Each inclusion In Inclusions
            Try Document = currentconsult!results_received[inclusion!fk_document]         '? a result??
            If IsNull(document) Then                                                      'it wasn't a result             
               Try Document = currentconsult!letters_received[inclusion!fk_document]      '? a letter ??   
            End If  
            '---------------------------------------------------------------------------
            'If it was a valid document, print - at moment we only handle pdf's and html
            'but hey, that's our perogative
            '---------------------------------------------------------------------------   
            If Not IsNull(Document) Then 
               file_extension = Lower(File.Ext(document!source_file))
               Select Case file_extension
                  Case "pdf"
                     modPrinting.Print_PDF(modAdminDBI.Config_Get("document_archiving_directory", "/var/easygp/documents/") &/ document!source_file)
                  Case Else
                     If Not IsNull(document!html) Then modPrinting.PrintHtml(document!html, const.Paper_Plain)
               End Select
            End If
         Next
      End If   
   Next
   
End

Public Sub Referral_Print(currentconsult As CConsult, referral As Collection, bPrintCopies As Boolean, inclusions As Collection)
   '-----------------------------------------------
   'Print the referral letter, appropriate copies, inclusions
   '-----------------------------------------------
   
   Dim inclusion As Collection
   Dim x As Integer
   Dim num_copies As Integer   
   Dim Document As Collection
   Dim file_extension As String
   Dim latex As String
   Dim templ As CTemplate
   
   num_copies = 1                      'always want single copy
   If bPrintCopies Then num_copies += Max(Split(referral!copyto, "|").Count, 0) 
    
   For x = 1 To num_copies 
     templ = New CTemplate("templates/referral.tex") 
     Construct_Letter(templ, currentconsult, referral, inclusions) 
     modPrinting.Print_latex(templ.GetData(), const.Paper_Plain)
     If referral!include_healthsummary = True Then
       modPrinting.PrintHtml(modProgressNotes.Health_Summary_Construct_html(currentconsult), const.Paper_Plain)
     End If
     If referral!include_careplan = True Then
       modPrinting.PrintHtml(modProgressNotes.Care_Plan_Construct_html(currentconsult), const.Paper_Plain)
     End If  
     '------------------------------------------------------------------------------------
     'Now print any included documents which were dragged'n dropped to the inclusions list
     'FIXME: just first go, need to take into account document type in more thorough way
     'At moment, I'm only allowing drag and drop of letters recieved or hl7 recieved
     '------------------------------------------------------------------------------------
     If Not IsNull(inclusions) Then 
       For Each inclusion In Inclusions
         Try Document = currentconsult!results_received[inclusion!fk_document]         '? a result??
         If IsNull(document) Then                                                      'it wasn't a result             
           Try Document = currentconsult!letters_received[inclusion!fk_document]      '? a letter ??   
         End If  
         '---------------------------------------------------------------------------
         'If it was a valid document, print - at moment we only handle pdf's and html
         'but hey, that's our perogative
         '---------------------------------------------------------------------------   
         If Not IsNull(Document) Then 
           file_extension = Lower(File.Ext(document!source_file))
           Select Case file_extension
             Case "pdf"
               modPrinting.Print_PDF(modAdminDBI.Config_Get("document_archiving_directory", "/var/easygp/documents/") &/ document!source_file)
             Case Else
               If Not IsNull(document!html) Then modPrinting.PrintHtml(document!html, const.Paper_Plain)
             End Select
           End If
         Next
      End If   
   Next
   
End

' constructs a referral letter from a collection using the provided template.
' note that it is expected that the collection comes from clin_referral.vwreferral,
' including all the extra fields for addresses, organisations etc, even for new referrals.
Public Sub Construct_Letter(templ As CTemplate, currentconsult As CConsult, referral As Collection, inclusions As Collection)
   
   Dim sPatient As String
   Dim to_address As String[]
   Dim i As String
   Dim comm As Collection
   
   templ.Subst_common(currentconsult)
   
   ' the Re: line at the start of the letter
   i = currentconsult!patient!firstname & " " & currentconsult!patient!surname & ", " & currentconsult!patient!street1 
   If Not IsNull(currentconsult!patient!street2) Then i &= currentconsult!patient!street2 & " "
   i &= " " & currentconsult!patient!town & " " & currentconsult!patient!postcode & ", DOB: " & Format(currentconsult!patient!birthdate, "dd/mm/yyyy")
   i &= " Aged: " & currentconsult!patient!age 
   templ.Subst("patient-line", i)
   
   ' recipient address, which as lots of bits that can be NULL
   Let to_address = New String[]
   For Each i In ["wholename", "organisation", "branch", "street1", "street2"]
     If Not IsNull(referral[i]) Then to_address.Add(referral[i])
   Next
   If Not IsNull(referral!town) Then to_address.Add(referral!town & " " & referral!postcode)
   ' with LaTeX the templater will turn <br> into the apropriate separator
   templ.Subst_HTML("to-address", to_address.Join("<br>"))
   
   If IsNull(referral!wholename) Then
     templ.Subst("salutation", "Dear Sir/Madam")
     templ.Subst("finish", "Yours faithfully,")
   Else
     templ.Subst("salutation", "Dear " & referral!wholename)
     templ.Subst("finish", "Yours sincerely,") 
   Endif
   ' TODO: move these to the new system
   'sLetterHtml = Replace(sLetterHtml, "%inclusions%", sHtml_Inclusions)
   'sLetterHtml = Replace(sLetterHtml, "%cc%", sHtml_CopyTo)
   
   Let i = ""
   For Each comm In currentconsult!comms
     i &= const.CommModalityTextFull[comm!fk_type] & ":" & comm!value & "<br>"
   Next
   templ.Subst_HTML("comms", i)
   If referral!fk_type <> 13 Then ' other than "Non-Medicare" 
      templ.Subst_HTML("type", "<b>Type of referral:</b> " & referral!type)
   Else
      templ.Subst("type", "")
   End If
   
   ' the body itself
   templ.Subst_HTML("body", referral!body_html)

   
End Sub

