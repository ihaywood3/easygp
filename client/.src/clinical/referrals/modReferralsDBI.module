' Gambas module file

' Copyright (C) 2008-2014 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'----------------------------------------------------------------------

Public Function Letters_Received_Get(fk_patient As Integer, Optional sort_order As String = "desc", Optional bSorted_Originator As Boolean = False) As Collection 
   '------------------------------------------------------------------------------------------------------
   'Return a collection of all documents received for this patient 
   'which are not a result, order newest to oldest, whether filed or not
   'orginator = the sender eg Dr Joe Blogs
   'tag_user = the users document tag e.g 'Assessment of IHD i.e that entered when the document was filed
   '-----------------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from documents.vwDocuments where fk_patient = " & fk_patient
   sql &= " AND fk_lu_display_as = " & const.Document_Display_As_Letter & " AND deleted = false" 
   sql &= " ORDER BY " 
   If bSorted_Originator Then
      sql &= "originator, " 
   Endif
   sql &= "date_created " & sort_order
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub Templates_Save(template As CRow)
   
   ''  If IsNull(template!pk) Then
   '    modDBConnect.insert("clin_referrals.lu_referral_letter_templates", template)
   ' Else
   '   
   ' End If
   template.Save("clin_referrals.lu_referral_letter_templates", "pk_template")
   
End

Public Function Templates_Get() As Collection 
   
   Return modDBConnect.exec_query_collection("Select * from clin_referrals.lu_referral_letter_templates where fk_staff = " & modDBConnect.currentUser!fk_staff)
   
End

Public Function Priority_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from clin_referrals.lu_urgency") 
   
End

Public Function Referral_Delete(currentconsult As CConsult, Referral As Collection) As Boolean
   '-------------------------------------------------------------------------------------
   'User has clicked on a letter over the tabbed list referral's and decided to delete it
   '-------------------------------------------------------------------------------------
   
   Dim sHtml As String
   Dim fk_progressnote As Integer
   Dim fk_referral As Integer
   Dim pn As Collection
   Dim fk_reason As Integer
   Dim reason As String
   Dim audit_notes As String
   
   If Message.Warning("Are you sure you wish to delete this referral", "Yes", "No") = 2 Then Return
   fk_progressnote = referral!fk_progressnote
   fk_referral = referral!pk_referral
   sHtml = referral!letter_html
   For Each PN In currentconsult!progress_notes
      If PN!pk_progressnote = fk_progressnote Then
         '---------------------------------------------------------
         'if this progress note was put in today, just mark deleted
         '----------------------------------------------------------
         If PN!fk_consult = currentconsult.GetPK() Then           'probabably a reversal, don't need to audit just visually remove from the notes
            modDBConnect.update("clin_consult.progressnotes", Null, ["pk": fk_progressnote, "deleted": True])
         Else
            pn!notes = Replace$(pn!notes, "<TABLE", "<TABLE BGCOLOR='#CFCFCF' ")
            pn!notes = Replace$(pn!notes, "<small>", "<strike><small>", gb.IgnoreCase)
            pn!notes = Replace$(pn!notes, "</small>", "</strike></small>", gb.IgnoreCase)
            audit_notes = "A referral letter dated " & Format(referral!date_referral, "dd/mm/yyyy") & " written to "
            If Not IsNull(referral!organisation) Then
               audit_notes &= referral!organisation
               If referral!branch <> "HEAD OFFICE" Then
                  audit_notes &= referral!branch
               Endif
               If referral!fk_employee Then
                  audit_notes &= " " & referral!wholename  
               Endif
            Else
               audit_notes &= " " & referral!wholename
            Endif
            audit_notes &= " about '" & referral!tag & "'"
            audit_notes &= " was deleted."
            pn!notes = Replace(pn!notes, "</TABLE>", "</TABLE><small><B><I>Audit note:</B> this referral letter was deleted by " & modDBConnect.currentUser!wholename & " on " & Format(Now, "dd/mm/yyyy") & ". See audit trail on that date for the reason.</I></small>")
            modDBConnect.update("clin_consult.progressnotes", Null, ["pk": fk_progressnote, "notes": pn!notes])             'strike through the letter in progress notes
         End If
         modDBConnect.update("clin_referrals.referrals", Null, ["pk": fk_referral, "deleted": True])                        'mark the referral as deleted
         modDBConnect.exec_query("update clin_referrals.inclusions set deleted = True WHERE fk_referral = " & fk_referral)  'Mark the inclusions as deleted
         If Not modAudit.MakeAudit(currentconsult, "mark deleted", "clin_referrals.referrals", fk_referral, const.cSection_Referrals, audit_notes) Then
            modDBConnect.RollBack
            Return
         Else
            modDBConnect.CommitTrans
            Return True
         End If   
      Endif
   Next
   
Catch
   Return 
   
End

Public Function Referrals_Written_This_Consult_Get(fk_patient As Integer, consult_date As Date) As Collection
   '----------------------------------------------------------------------------------------------------------
   'Public Function Referrals_Written_This_Consult_Get(fk_patient As Integer) As Collection
   'changed experimentally 31july14 to allow editing of past consultations
   'Returns collection of letters on same date by same doctor - this allows editing of mis-printed letters
   'Include any non-finalised letters
   '---------------------------------------------------------------------------------------------------------- 
   
   Dim sql As String
   
   sql = "Select * from clin_referrals.vwReferrals WHERE fk_patient = " & fk_patient
   sql &= " AND fk_staff = " & modDBConnect.currentUser!fk_staff
   If IsNull(consult_date) Then 
      sql &= " AND (finalised is not true OR date(consult_date) = '" & Format(Now, "dd/mm/yyyy") & "'::date) "
   Else
      sql &= " AND (finalised is not true OR date(consult_date) = '" & Format(consult_date, "dd/mm/yyyy") & "'::date) "
   End If   
   sql &= " AND deleted is not true "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Referrals_written_get(fk_patient As Integer) As Collection
   '-------------------------------------------------------------------
   'PURPOSE: Gets all referral  letters or other outgoing letters
   '         but not recall letters for the patient
   'EXPECTS: key to consult.patients table
   'RETURNS: A collection of referrals written in newest to oldest order
   '
   '--------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from clin_referrals.vwReferrals where fk_patient = " & fk_patient
   sql &= " AND fk_type <>" & const.ReferralType_Recall
   sql &= " AND fk_type <>" & const.ReferralType_ImportedRecall
   sql &= " AND deleted is not true "
   sql &= " ORDER BY date_referral DESC"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Referrals_Get_By_PK(pk_referral As Integer) As Collection
   
   Dim sql As String
   
   sql = "select * from clin_referrals.vwReferrals where pk_referral = &1"
   Return modDBConnect.exec_query_collection(sql, [pk_referral])[pk_referral]
   
End

Public Function Referral_Get_Types() As Collection 
   '-------------------------------------------------------------
   'Gets a list of types of referrals e.g 'Opinion', 'Management'
   'Do not want these ordered alphabetically
   'I've put the most commonly used types in order
   '-------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * From clin_referrals.lu_type")
   
End

Public Function UnDelete(pk_referral As Integer)
   '--------------------------------------------------
   'Marks as not deleted a previously deleted referral
   'Quicker than using Save()
   '-------------------------------------------------- 
   
   modDBConnect.exec_query("Update clin_referrals.referrals set deleted = False where pk = " & pk_referral)
   
End

Public Function Inclusions_Get(fk_patient As Integer, Optional bdeleted As Boolean = False, Optional bThisConsult As Boolean = False, Optional fk_referral As Integer = 0) As Collection 
   '-----------------------------------------------------------------------------------------------------------------------
   'Gets inclusions as keys for patients referrals, either the entire collection or optionally only for current day of consultation
   '-----------------------------------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select pk_inclusion, fk_document, fk_referral from clin_referrals.vwInclusions where fk_patient = " & fk_patient & "  AND deleted = " 
   If bdeleted Then
      sql &= "True"
   Else
      sql &= "False" 
   Endif
   If bThisConsult Then
      sql &= " AND date(consult_date) = '" & Format(Now, "dd/mm/yyyy") & "'::date "
   Endif
   If fk_referral Then   'limit inclusions to a single referral
      sql &= " AND fk_referral = " & fk_referral  
   Endif
   Return modDBConnect.exec_query_collection(sql)
   
End
' 
' Public Function Inclusions_Get(fk_patient As Integer, Optional bdeleted As Boolean = False, Optional bThisConsult As Boolean = False, Optional fk_referral As Integer = 0) As Collection 
'    '-----------------------------------------------------------------------------------------------------------------------
'    'Gets inclusions for patients referrals, either the entire collection or optionally only for current day of consultation
'    '-----------------------------------------------------------------------------------------------------------------------
'    
'    Dim sql As String
'    
'    sql = "Select * from clin_referrals.vwInclusions where fk_patient = " & fk_patient & "  AND deleted = " 
'    If bdeleted Then
'       sql &= "True"
'    Else
'       sql &= "False" 
'    Endif
'    If bThisConsult Then
'       sql &= " AND date(consult_date) = '" & Format(Now, "dd/mm/yyyy") & "'::date "
'    Endif
'    If fk_referral Then   'limit inclusions to a single referral
'       sql &= " AND fk_referral = " & fk_referral  
'    Endif
'    Return modDBConnect.exec_query_collection(sql)
'    
' End

Public Function Save(currentconsult As CConsult, old_pk As Integer, referral As Collection, inclusions As Collection) As Integer 
   '----------------------
   'Saves a referral letter
   '-----------------------
   
   Dim inclusion As Collection
   
   If old_pk <= 0 Then
      referral!fk_consult = currentconsult.GetPK()
      referral.Remove("pk_referral")
      referral!pk_referral = modDBConnect.insert("clin_referrals.referrals", referral)
   Else
      modDBConnect.update("clin_referrals.referrals", currentconsult!referrals_written[old_pk], referral, "pk_referral")
   End If
   
   If Not IsNull(inclusions) Then
      For Each inclusion In inclusions
         inclusion!fk_referral = referral!pk_referral
         If IsNull(inclusion!pk_inclusion) Then
            inclusion!pk_inclusion = modDBConnect.insert("clin_referrals.inclusions", inclusion)
         Else
            modDBConnect.update("clin_referrals.inclusions", inclusions[inclusion!pk_inclusion], inclusion, "pk_inclusion") 
         Endif
      Next
   Endif
   Return referral!pk_referral
   
End

Public Function Organisations_Get_For_Employee(fk_person As Integer) As Collection
   '--------------------------------------------------------------------------------------
   'Gets a list of all organsisations the chosen person is in in vwOrganisationsEmployees
   'note we use the fk_person, not the fk_employee as fk_person is unique, but
   'same person could be employed in multiple places, and have multiple fk_employee's
   '-------------------------------------------------------------------------------------
   ' Dim $CommsResult As result
   ' Dim comm As cComm
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwOrganisationsEmployees WHERE fk_person = " & fk_person)
   
End

Public Function Persons_Addresses_Get(fk_person As Integer) As Collection
   '---------------------------------------------------------------------
   'Get collection of addresses for person either when the contacts entry
   'is as an employee of organisation, or as a person at an address which
   'does not belong to a company
   '----------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from contacts.vwPersonsAndEmployeesAddresses where fk_person = " & fk_person
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Person_Get_By_Surname(txtName As String, Optional bExcludeLeftAddress As Boolean = False, Optional bExcludeRetired As Boolean = False, Optional bExcludeDead As Boolean = False) As Collection
   '-------------------------------------------------------------------------
   'return a collection of persons by surname, either employee or sole trader
   'Called by FQuickContact, FReferrals
   'Excludes persons where are retired, deceased or left organisation
   'fixme the hard coded limit
   '-------------------------------------------------------------------------
   
   Dim bits As New String[]
   Dim sql As String    
   
   bits = Split(txtName, ",")
   sql = "Select * from contacts.vwPersonsEmployeesByOccupation WHERE  " 
   If bits.count = 2 Then
      sql &= "surname ILIKE $$%" & bits[0] & "%$$ AND firstname ILIKE $$%" & bits[1] & "%$$ " 
   Else
      sql &= " surname  ILIKE $$%" & txtName & "%$$ "
   Endif
   If bExcludeLeftAddress Then
      sql &= " And fk_status <> " & const.StaffStatus_LeftOrganisation & " " 'fixme notice the mixup between left address and left organisation
   Endif
   If bExcludeRetired = True Then
      sql &= " AND retired is False "
   Endif
   If bExcludeDead = True Then
      sql &= " AND deceased is False "
   Endif
   sql &= " LIMIT 60"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Persons_Get_By_Occupation(occupation As String) As Collection
   '-----------------------------------------------------------------
   'Gets a list of people by occupation either employee or person
   'Called by FQuickContact and FReferrals
   'Excludes persons where are retired, deceased or left organisation
   '-----------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from contacts.vwPersonsEmployeesByOccupation where occupation ILIKE $$%" 
   sql &= occupation & "%$$ LIMIT 60"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Comms_Get(fk_employee As Integer) As Result
   'FIX ME USE THE ONE ON CONTACTSDBI AND REMOVE THIS
   
   Dim sql As String
   Dim $Result As Result
   
   sql = "Select " 
   " COMMS.pk,"
   " COMMS.value,"
   " COMMS.note,"
   " COMMS.preferred_method,"
   " COMMS.confidential,"
   " COMMS.deleted,"
   " COMMS.fk_type, "
   " TYPES.type"
   " From "
   " contacts.data_communications COMMS "
   " INNER JOIN contacts.links_employees_comms ON(COMMS.pk = contacts.links_employees_comms.fk_comm) "
   "  INNER JOIN contacts.lu_contact_type TYPES ON(COMMS.fk_type = TYPES.pk) "
   "WHERE "
   sql = sql & "contacts.links_employees_comms.fk_employee = " & fk_employee
   $Result = modDBConnect.exec_query(sql)
   
   Return $Result
   
End

Public Sub Referral_Print(currentconsult As CConsult, referral As Collection, bPrintCopies As Boolean, bSingleCopyInclusionsOnly As Boolean, Optional Inclusions As Collection)
   
   If modAdminDBI.Config_Get("use_ozefax", False) Then
      Referral_Print_Fax(currentconsult, referral, bPrintCopies)  'currently copies always sent and inclusions not supported
   Else
      Referral_Print_Only(currentconsult, referral, bPrintCopies, bSingleCopyInclusionsOnly, Inclusions)
   Endif
   
End

Public Sub Referral_Print_Only(currentconsult As CConsult, referral As Collection, bPrintCopies As Boolean, bSingleCopyInclusionsOnly As Boolean, Optional Inclusions As Collection, Optional bDoNotReprintHealthSummary As Boolean = False)
   '-----------------------------------------------------------------------------------------------------------------
   'Print the referral letter, appropriate copies, inclusions - may be null e.g none - or only re-printing the letter
   'If bPrintInclusionss_for_ccd = True then any cc'd person/organisation will also have all the inclusions printed.
   '-----------------------------------------------------------------------------------------------------------------
   
   Dim inclusion As Collection
   Dim x As Integer
   Dim num_copies As Integer   
   Dim Document As Collection
   Dim file_extension As String
   Dim extra_copies As Integer
   
   num_copies = 1                      'always want single copy
   If bPrintCopies Then 
      extra_copies = Max(Split(referral!copyto, "|").Count, 0) 
      If extra_copies Then
         num_copies = num_copies + extra_copies                 'plus the extra copies we need
      End If
   End If   
   '----------------------------------------------------------
   'Print the actual letter for the recipient, and anyone cc'd
   '---------------------------------------------------------
   For x = 1 To num_copies 
      If Left$(referral!letter_html, 14) = "\\documentclass" Then
         modPrinting.Print_latex(referral!letter_html, const.Paper_Plain)
      Else
         modPrinting.PrintHtml(referral!letter_html, const.Paper_Plain)
      Endif
      
      If referral!include_healthsummary = True Then
         modPrinting.Print_PDF(modPrinting.Latex_To_PDF(modProgressNotes.Health_Summary_Construct_LaTex(currentconsult).GetData())) 'gives the filename
      End If
      If referral!include_careplan = True And bDoNotReprintHealthSummary = False Then
         modPrinting.Print_latex(modProgressNotes.Health_Summary_Construct_LaTex(currentconsult, currentconsult!patient!gp_management_plan).GetData())
      End If  
   Next
   '------------------------------------------------------------------------------------
   'Now print any included documents which were dragged'n dropped to the inclusions list
   'FIXME: just first go, need to take into account document type in more thorough way
   'At moment, I'm only allowing drag and drop of letters recieved or hl7 recieved
   'If user dosn't want to print document copies for cc'd don't do that.
   '------------------------------------------------------------------------------------
   If bSingleCopyInclusionsOnly = True Then num_copies = 1
   For x = 1 To num_copies
      If Not IsNull(inclusions) Then 
         For Each inclusion In Inclusions
            Try Document = currentconsult!results_received[inclusion!fk_document]         '? a result??
            If IsNull(document) Then                                                      'it wasn't a result             
               Try Document = currentconsult!letters_received[inclusion!fk_document]      '? a letter ??   
            End If  
            '---------------------------------------------------------------------------
            'If it was a valid document, print - at moment we only handle pdf's and html
            'but hey, that's our perogative
            '---------------------------------------------------------------------------   
            If Not IsNull(Document) Then 
               file_extension = Lower(File.Ext(document!source_file))
               Select Case file_extension
                  Case "pdf"
                     modPrinting.Print_PDF(modAdminDBI.Config_Get("document_archiving_directory", "/var/easygp/documents/") &/ document!source_file)
                  Case Else
                     ' If Not IsNull(document!html) Then modPrinting.PrintHtml(document!html, const.Paper_Plain)
                     If Not IsNull(document!data) Then 
                        Select Case Document!fk_lu_data_content_type
                           Case const.cData_Type_Latex 
                              modPrinting.Print_latex(document!data, const.Paper_Plain)
                           Case const.cData_Type_HTML
                              modPrinting.PrintHtml(Document!data, const.Paper_Plain)
                           Case Else
                              Message.Info("Unknown document data type - please notify the developers")
                        End Select
                     End If   
               End Select
            End If
         Next
      End If   
   Next
   
End

Public Sub Referral_Print_Fax(currentconsult As CConsult, referral As Collection, bPrintCopies As Boolean)
   '-----------------------------------------------------------------------------------------------------------------
   ' print or fax as appropriate, using new cPrintTask structures.
   '-----------------------------------------------------------------------------------------------------------------
   
   Dim s As String
   Dim num_print_copies As Integer  
   Dim destination_faxes As New String[] 
   Dim coll As Collection
   Dim fax_pdf_path As String
   Dim print_ps_path As String
   Dim re As Regexp
   Dim task As New CPrintTask
   
   num_print_copies = 0                      'maybe we can fax the lot
   ' first question: does the main recipient have a fax?
   If Not IsNull(referral!fk_employee) Then
      For Each coll In modContactsDBI.Employee_Comms_Get(referral!fk_employee)
         If coll!fk_type = const.CommModalityFax Then
            destination_faxes.Add(coll!value)
         Endif
      Next
   Else
      If Not IsNull(referral!fk_person) Then
         For Each coll In modContactsDBI.person_comms_get(referral!fk_person)
            If coll!fk_type = const.CommModalityFax Then
               destination_faxes.Add(coll!value)
            Endif
         Next
      Else 
         If Not IsNull(referral!fk_branch) Then
            For Each coll In modContactsDBI.Branch_Comms_Get(referral!fk_branch)
               If coll!fk_type = const.CommModalityFax Then
                  destination_faxes.Add(coll!value)
               Endif
            Next
         Endif
      Endif
   Endif
   If destination_faxes.Length = 0 Then num_print_copies = 1 ' no fax, so print
   '----------------------------------------------------------
   ' now let's see which of the CCs we can fax to
   '---------------------------------------------------------
   re = New Regexp("x", "Fax *: *([0-9]+)")
   For Each s In Split(referral!copyto, "|")
      re.Exec(s)
      If re.Offset <> -1 Then
         destination_faxes.Add(re[1].Text)
      Else
         If bPrintCopies Then Inc num_print_copies
      Endif
   Next
   
   '-----------------------------------------------------------
   ' now print if we have to
   ' -----------------------------------------------------------
   If num_print_copies > 0 Then
      If Left$(referral!letter_html, 14) = "\\documentclass" Then
         s = Replace(referral!letter_html, "% signature", "\\vspace{12mm}")
         print_ps_path = task.Latex_To_Ps(referral!letter_html, const.Paper_Plain)
      Else
         print_ps_path = task.Html_To_Pdf(referral!letter_html)
      Endif
      task.Print_PDF(print_ps_path, const.Paper_Plain, num_print_copies)
   Endif
   '---------------------------------------------------------------
   ' now fax if we have to
   ' ---------------------------------------------------------------
   If destination_faxes.Length > 0 Then
      If Left$(referral!letter_html, 14) = "\\documentclass" Then
         If Exist(User.Home &/ "signature.jpg") Then
            s = Replace(referral!letter_html, "% signature", "\\includegraphics[height=12mm]{" & User.Home &/ "signature.jpg" & "}")
         Else
            s = Replace(referral!letter_html, "% signature", "\\vspace{12mm}")
         Endif
         fax_pdf_path = task.Latex_To_Pdf(s)
      Else
         If Not IsNull(print_ps_path) Then
            fax_pdf_path = task.Html_To_Pdf(referral!letter_html)
         Else
            fax_pdf_path = print_ps_path ' will be the same as no signature for HTML letters
         Endif
      Endif
      For Each s In destination_faxes
         task.Send_Fax(s, fax_pdf_path)
      Next
      task.Kill(fax_pdf_path)
   Endif
   If Not IsNull(print_ps_path) Then task.Kill(print_ps_path)
   task.Close()
   
End

Public Sub UnitTest(form_main As FMain)
   
   Dim referral As New Collection
   Dim cc As New CConsult(modContactsDBI.Patient_Get_Using_PK(7)) ' Jim Bloggs
   
   referral!fk_employee = 164 ' Richard Terry
   referral!letter_html = File.Load("/home/ian/test-referral.tex")
   referral!copyto = "Some Random Address, Somewhere 1234 Fax: 0312345678"
   Referral_Print_Fax(cc, referral, True)
   
End
