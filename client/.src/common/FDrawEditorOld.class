' Gambas class file
' Copyright (C) 2008,2009 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'Note: FconsultNotes overides the save button on this form
Public sPicturePath As String
Private Name As String
Public Path As String
Public bEditing As Boolean

Property Read ReadOnly As Boolean

Public $hImage As Image 'to be able to reach into this module and use this
Private $iScale As Integer
Private $iScale1 As Integer

Private $bModify As Boolean
Private $bReadOnly As Boolean

Private $X As Integer
Private $Y As Integer
Private $X2 As Integer
Private $Y2 As Integer
Private $iColor As Integer

Private $bGhost As Boolean

Private Const MAX_UNDO As Integer = 32
Private $hUndo[32] As Image
Private $iUndo As Integer

Private Const WIDTH_SEL As Integer = 4

Private $bSelect As Boolean
Private $bPrivate As Boolean
Private $XS As Integer
Private $YS As Integer
Private $WS As Integer
Private $HS As Integer

Private $hPaste As Image

Private Const COORD_HIDE As Integer = 1048576
Private $XD As Integer
Private $YD As Integer

Static Private $aZoom As Integer[]
Static Private $iMaxW As Integer
Static Private $iMaxH As Integer
Static Private $hTile As Picture

Static Private $cColor As New Integer[]

'PRIVATE $hCurrent AS FIconEditor

Private $sTool As String

Private $hTool As ToolButton
Private $hLast As ToolButton
Private $hMode As ToolButton
Private $hTrans As ToolButton
Private $bIgnoreClick As Boolean

Private $iForeground As Integer
Private $iBackground As Integer
Private $iMode As Integer
Private $bTrans As Boolean

Private $iMouse As Integer

Private $iBeginUndo As Integer

Private $bNoPreview As Boolean

Static Public Sub _init()

  Dim sColor As String

  $aZoom = [1, 2, 4, 6, 8, 12, 16, 24]
  $hTile = Picture["img/16/tile.png"]

  For Each sColor In Split("000000,FFFFFF,0000FF,00FF00,FF0000,00FFFF,FFFF00,FF00FF,7F7F7F,BFBFBF,00007F,007F00,7F0000,007F7F,7F7F00,7F007F,3F3F3F,FF8000,43C7FF")
    $cColor.Add(Val("&H" & sColor & "&"))
  Next

End



Public Sub _New1(sPath As String)

'   Dim sText As String
'   Dim iScale As Integer
'   Dim iColor As Integer
'   Dim hColor As DrawingArea
'   Dim hCtrl As Control
'   
'   ' Print "1: The path is", sPath
'   Path = sPath                        'path here is the fully qualified path/filename.png
' ''  Name = Mid$(sPath, Len(File.Dir(Project.Path)) + 1)
' ' ' Print "Name is ", Name
'   $iMaxW = Me.Width
'   $iMaxH = Me.Height
' 
'   For Each iScale In $aZoom
' '    cmbZoom.Add(iScale & " x")
'   Next
' 
'   Reload
'   
'   $iScale = 1  
'  ' For Each iScale In $aZoom
'    ' If ($hImage.Width * iScale) > (Project.Workspace.ClientWidth * 0.75) Or ($hImage.Height * iScale) > (Project.Workspace.ClientHeight * 0.75) Then Break
'  '   $iScale = iScale
'  ' Next
' 
'   SetBackground(Color.White)
'   SetForeground(Color.Black)
' 
'   SetTransparent(True)
'   SetMode(0)
' '  SetTool(btnMove)
'   SetReadOnly
 
End

Private Sub SetReadOnly()

  Dim hCtrl As Control  
  Return
'  $bReadOnly = Project.ReadOnly Or Project.Running Or Stat(Path).Type = gb.Link

  For Each hCtrl In panToolbar.Children
    If hCtrl.Name = "tlbMove" Then Continue
    hCtrl.Visible = Not $bReadOnly
  Next

End

' Public Sub Load()
' 
'  'Return
' ' Print "loading"
' 
' '  dwgPreview.Resize($hImage.W + 8, $hImage.H + 8)
'   'panPreview.Dimension = dwgPreview.W + 8
'   
'   'refreshZoom
' 
' End


Public Sub dwgIcon_Draw()

  Dim X As Integer
  Dim Y As Integer
  Dim XR As Integer
  Dim YR As Integer
  Dim SX As Integer
  Dim SY As Integer
  Dim DX As Integer
  Dim DY As Integer
  Dim C As Integer
  Dim W As Integer

  Dim hZoom As Image

  If Not $hImage Then Return

  Draw.LineStyle = Line.None
  'Draw.FillStyle = Fill.CrossDiagonal
  'Draw.FillColor = 0
  'Draw.Rect(Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)
  Draw.FillStyle = Fill.Solid
  'Draw.Tile($hTile, Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)

  SX = Draw.Clip.X \ $iScale
  SY = Draw.Clip.Y \ $iScale
  DX = (Draw.Clip.X + Draw.Clip.W - 1) \ $iScale
  DY = (Draw.Clip.Y + Draw.Clip.H - 1) \ $iScale

  SX = Max(0, SX)
  DX = Min($hImage.Width - 1, DX)

  SY = Max(0, SY)
  DY = Min($hImage.Height - 1, DY)

  If $iScale > 5 Then
    Draw.LineStyle = Line.Solid
    Draw.Foreground = &H989898
  Else
    Draw.LineStyle = Line.None
  Endif

  Draw.Zoom($hImage, $iScale, SX * $iScale, SY * $iScale, SX, SY, DX - SX + 1, DY - SY + 1)

  If $bGhost Then DrawGhost(True)

End


Public Sub dwgPaste_Draw()

  Dim X As Integer
  Dim Y As Integer
  Dim XR As Integer
  Dim YR As Integer
  Dim SX As Integer
  Dim SY As Integer
  Dim DX As Integer
  Dim DY As Integer
  Dim C As Integer
  Dim CP As Integer
  Dim W As Integer
  Dim hTemp As Image

  If Not $hPaste Then Return

  Draw.FillX = Draw.FillX - $XS * $iScale
  Draw.FillY = Draw.FillY - $YS * $iScale

  Draw.LineStyle = LINE.None
  'Draw.FillStyle = Fill.CrossDiagonal
  'Draw.FillColor = 0
  'Draw.Rect(Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)
  Draw.FillStyle = Fill.Solid

  'Draw.Tile($hTile, Draw.Clip.X, Draw.Clip.Y, Draw.Clip.W, Draw.Clip.H)

  If $iScale > 5 Then
    Draw.LineStyle = Line.Solid
    Draw.Foreground = &H989898
    W = $iScale1
  Else
    Draw.LineStyle = LINE.None
    W = $iScale
  Endif

  SX = Draw.Clip.X \ $iScale
  SY = Draw.Clip.Y \ $iScale
  DX = (Draw.Clip.X + Draw.Clip.W - 1) \ $iScale
  DY = (Draw.Clip.Y + Draw.Clip.H - 1) \ $iScale

  SX = Max(0, SX)
  DX = Min($hPaste.Width - 1, DX)

  SY = Max(0, SY)
  DY = Min($hPaste.Height - 1, DY)

  If $bTrans Then

    hTemp = $hImage.Copy($XS, $YS, $hPaste.Width, $hPaste.Height)
    hTemp.Draw($hPaste, 0, 0)
    'Draw.Zoom($hImage, $iScale, SX * $iScale, SY * $iScale, SX + $XS, SY + $YS, DX - SX + 1, DY - SY + 1)
    Draw.Zoom(hTemp, $iScale, SX * $iScale, SY * $iScale, SX, SY, DX - SX + 1, DY - SY + 1)

  Else

    Draw.Zoom($hPaste, $iScale, SX * $iScale, SY * $iScale, SX, SY, DX - SX + 1, DY - SY + 1)

  Endif

  Draw.FillStyle = Fill.None
  Draw.LineStyle = Line.Dot
  Draw.LineWidth = 3
  Draw.Foreground = Color.Black
  Draw.Background = Color.White
  Draw.Transparent = False
  'Draw.Invert = TRUE
  Draw.Rect(1, 1, dwgPaste.Width - 2, dwgPaste.Height - 2)

End


Private Sub DrawTitle()

'  Project.DrawTitle(Me)

End


Private Sub RefreshCoord(X As Integer, Y As Integer)

  ' If X <> $XD Or Y <> $YD Then
  '   $XD = X
  '   $YD = Y
  '   'DrawTitle
  '   If $XD <> COORD_HIDE And $YD <> COORD_HIDE Then
  '     lblCoord.Text = $XD & ":" & $YD
  '   Else 
  '     lblCoord.Text = ""
  '   Endif 
  ' Endif

End

Private Sub HideCoord()
  
  RefreshCoord(COORD_HIDE, COORD_HIDE)
  
End


Public Function IsModified() As Boolean

  Return $bModify

End


Public Sub Rename(sNewName As String, sNewPath As String)

  Name = sNewName
  Path = sNewPath 'File.Dir(Path) &/ sNewName '& "." & File.Ext(Path)
  DrawTitle

End


Public Function Save() As Boolean

'  If Project.ReadOnly Then Return
  If $bReadOnly Then Return
  If Not $bModify Then Return

  '' Print "Picture not saved"

  HideSelection

'  Save.Begin(Path)

  $hImage.Save(Path)

  'Project.RefreshKey(Path)

  $bModify = False
  DrawTitle
'  Save.End()

Catch

'  Return Save.Error()

End

Public Sub dwgIcon_MouseDown()

  Dim X As Integer
  Dim Y As Integer
 'If Not $hImage Then Return
  X = Mouse.X
  Y = Mouse.Y

  'WITH FIconTool

    Select $sTool

      Case "move"
        $X = Mouse.ScreenX + svwIcon.ScrollX
        $Y = Mouse.ScreenY + svwIcon.ScrollY

      Case "pen"
        SetUndo
        $X = -1
        $Y = -1
        $iColor = GetColor(Mouse.Button)
        dwgIcon_MouseMove()

      Case "line", "rect", "circle", "fill", "fill-alt"
        SetUndo
        $X = X \ $iScale
        $Y = Y \ $iScale
        $X2 = $X
        $Y2 = $Y
        $iColor = GetColor(Mouse.Button)

      Case "select"

        BeginUndo
        $X = X \ $iScale
        $Y = Y \ $iScale
        $X2 = $X
        $Y2 = $Y

        '$bSelect = FALSE
        'RefreshSelect

      Case "pipette"
        X = X \ $iScale
        Y = Y \ $iScale

        If Mouse.Left Then SetForeground($hImage[X, Y])
        If Mouse.Right Then SetBackground($hImage[X, Y])

    End Select

    DrawGhost

    Select $sTool

      Case "line", "rect", "circle"
        dwgIcon_MouseMove()

    End Select

  'END WITH

End

Public Sub dwgIcon_MouseMove()

  Dim C As Integer
  Dim X As Integer
  Dim Y As Integer
  Dim NX As Integer
  Dim NY As Integer
  If Not $hImage Then Return
  X = Mouse.X
  Y = Mouse.Y

  'WITH FIconTool

    RefreshCoord(X \ $iScale, Y \ $iScale)

    If Not (Mouse.Left Or Mouse.Right) Then Return

    DrawGhost

    If $sTool <> "move" Then

      UpdateScroll(X, Y)

    Endif

    X = X \ $iScale
    Y = Y \ $iScale

    Select $sTool

      Case "move"
        svwIcon.Scroll($X - Mouse.ScreenX, $Y - Mouse.ScreenY)

      Case "pen"
        If X <> $X Or Y <> $Y Then
          If $X < 0 And $Y < 0 Then
            DrawPoint(X, Y, $iColor)
          Else
            DrawLine($X, $Y, X, Y, $iColor)
          Endif
          $X = X
          $Y = Y
        Endif

      Case "line", "rect", "circle", "select"
        If X <> $X2 Or Y <> $Y2 Then
          $X2 = X
          $Y2 = Y
          If $sTool = "select" Then
            HideSelection
            $bSelect = True
          Endif
        Endif

    End Select

    DrawGhost

  'END WITH

End


Public Sub dwgIcon_MouseUp()

  'WITH FIconTool

    DrawGhost

    Select Case $sTool

      Case "pipette"
        RevertTool

      Case "line"
        DrawLine($X, $Y, $X2, $Y2, $iColor)

      Case "rect"
        DrawRect(Min($X, $X2), Min($Y, $Y2), Abs($X - $X2) + 1, Abs($Y - $Y2) + 1, $iColor)

      Case "circle"
        DrawEllipse(Min($X, $X2), Min($Y, $Y2), Abs($X - $X2) + 1, Abs($Y - $Y2) + 1, $iColor)

      Case "select"
        If $X2 <> $X Or $Y2 <> $Y Then
          $X = Max(0, Min($hImage.Width - 1, $X))
          $Y = Max(0, Min($hImage.Height - 1, $Y))
          $X2 = Max(0, Min($hImage.Width - 1, $X2))
          $Y2 = Max(0, Min($hImage.Height - 1, $Y2))

          $XS = Min($X, $X2)
          $YS = Min($Y, $Y2)
          $WS = Abs($X - $X2) + 1
          $HS = Abs($Y - $Y2) + 1
          $bPrivate = True
          ShowSelection
        Else
          'IF NOT $bPrivate THEN DoPaste
          DoPaste
          HideSelection
        Endif
        EndUndo

      Case "fill"
        FloodFill($X, $Y, $iColor, 0)

      Case "fill-alt"
        FloodFill($X, $Y, $iColor, 1)

    End Select

  'END WITH

End


Private Sub RefreshZoom()

  Dim iIndex As Integer
  
  iIndex = $aZoom.Find($iScale)

'  If cmbZoom.Index <> iIndex Then cmbZoom.Index = iIndex

  'ME.Resize(Min($iMaxW, $hImage.Width * $iScale + (ME.Width - ME.ClientW) + 8), Min($iMaxH, $hImage.Height * $iScale + (ME.Height - ME.ClientH) + 8))
  $iScale1 = $iScale + 1

  'dwgIcon.Hide
  dwgIcon.Resize($hImage.Width * $iScale, $hImage.Height * $iScale)
  'RefreshSelect
  RefreshAllImage

  If dwgPaste.Visible Then
    dwgPaste.Move($XS * $iScale, $YS * $iScale, $hPaste.Width * $iScale, $hPaste.Height * $iScale)
  Endif

  DrawTitle

End


Private Sub RefreshImage(X As Integer, Y As Integer, W As Integer, H As Integer)

  X = X * $iScale
  Y = Y * $iScale
  W = W * $iScale
  H = H * $iScale

  dwgIcon.Refresh(X - 1, Y - 1, W + 2, H + 2)
'rt  If Not $bNoPreview Then dwgPreview.Refresh(X - 1 + 4, Y - 1 + 4, W + 2, H + 2)

End


Private Sub RefreshAllImage()

  dwgIcon.Refresh(svwIcon.ScrollX, svwIcon.ScrollY, svwIcon.ClientW, svwIcon.ClientH)
'rt  If Not $bNoPreview Then dwgPreview.Refresh

End



Public Sub Modify(Optional bReset As Boolean)

'  If Project.ReadOnly Or $bReadOnly Then Return
  If $bModify <> bReset Then Return

  $bModify = Not bReset
  DrawTitle
'  If $bModify Then Inc Project.TimeStamp

End


Public Sub dwgIcon_Leave()

  HideCoord

End


Private Sub SetPixel(X As Integer, Y As Integer, C As Integer)
   'If Not $hImage Then Return
  If $bTrans Then
    $hImage[X, Y] = Color.Blend(C, $hImage[X, Y])
  Else
    $hImage[X, Y] = C
  Endif
  'Modify

End

Private Sub SetPixelAlt(X As Integer, Y As Integer, C As Integer, C2 As Integer)
  'If Not $hImage Then Return
  If (X + Y) And 1 Then
    C = C2
  Endif 
  
  If $bTrans Then
    $hImage[X, Y] = Color.Blend(C, $hImage[X, Y])
  Else
    $hImage[X, Y] = C
  Endif
  'Modify

End


Private Sub DrawPoint(X As Integer, Y As Integer, C As Integer)
'If Not $hImage Then Return
  SetPixel(X, Y, C)
  RefreshImage(X, Y, 1, 1)
  Modify

End


Private Sub DrawLine(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer, C As Integer)

  Dim X As Integer
  Dim Y As Integer
  Dim DX As Float
  Dim DY As Float
  Dim D As Integer
  Dim XX As Float
  Dim YY As Float
  Dim LX As Integer
  Dim LY As Integer
  Dim bCalc As Boolean
'If Not $hImage Then Return
  $bNoPreview = True

  D = Max(Abs(X2 - X1), Abs(Y2 - Y1))
  D = Max(D, 1)

  DX = (X2 - X1) / D
  DY = (Y2 - Y1) / D

  '' Print "-------"
  '' Print "D ="; D; " DX ="; DX; " "; Sgn(DX); " DY ="; DY; " "; Sgn(DY)

  X = X1
  Y = Y1

  Do
    '' Print "X ="; X; " Y ="; Y

    DrawPoint(X, Y, C)

    If X = X2 And Y = Y2 Then Break

    bCalc = False

    Do

      XX = XX + DX
      YY = YY + DY

      If Abs(XX) > 0.5 Then
        X = X + Sgn(DX)
        XX = XX - Sgn(DX)
        bCalc = True
      Endif

      If Abs(YY) > 0.5 Then
        Y = Y + Sgn(DY)
        YY = YY - Sgn(DY)
        bCalc = True
      Endif

    Loop Until bCalc

  Loop
  
  $bNoPreview = False
'rt  dwgPreview.Refresh

End

Private Sub DrawRect(X As Integer, Y As Integer, W As Integer, H As Integer, C As Integer, Optional iMode As Integer = -1)

  Dim XX As Integer
  Dim YY As Integer
'If Not $hImage Then Return
  'WITH FIconTool

    If iMode < 0 Then iMode = $iMode

    If iMode > 0 Then

      If iMode = 2 Then C = OtherColor(C)

      For XX = X To X + W - 1
        For YY = Y To Y + H - 1
          SetPixel(XX, YY, C)
        Next
      Next

    Endif

    If iMode <> 1 Then

      If iMode = 2 Then C = OtherColor(C)

      For XX = X To X + W - 1
        SetPixel(XX, Y, C)
        SetPixel(XX, Y + H - 1, C)
      Next

      For YY = Y + 1 To Y + H - 2
        SetPixel(X, YY, C)
        SetPixel(X + W - 1, YY, C)
      Next

    Endif

    RefreshImage(X, Y, W, H)
    
    Modify

  'END WITH

End


Private Sub DrawEllipse(X As Integer, Y As Integer, W As Integer, H As Integer, C As Integer)

  Dim hTemp As New Picture
  Dim hImage As Image
  Dim XX As Integer
  Dim YY As Integer
  Dim C2 As Integer
'If Not $hImage Then Return
  'WITH FIconTool

    'hTemp.Type = Picture.Bitmap
    hTemp.Resize(W, H)
    hTemp.Fill(0)

    Draw.Begin(hTemp)

    Select Case $iMode

      Case 0
        Draw.LineStyle = LINE.Solid
        Draw.Foreground = 1
        Draw.FillStyle = Fill.None

      Case 1
        Draw.LineStyle = LINE.None
        Draw.FillStyle = Fill.Solid
        Draw.FillColor = 1

      Case 2
        Draw.LineStyle = LINE.Solid
        Draw.Foreground = 1
        Draw.FillStyle = Fill.Solid
        Draw.FillColor = 2

    End Select

    Draw.Ellipse(0, 0, W, H)
    Draw.End

    hImage = hTemp.Image
    C2 = OtherColor(C)

    For XX = 0 To W - 1
      For YY = 0 To H - 1
        Select Case hImage[XX, YY]
          Case 1
            SetPixel(X + XX, Y + YY, C)
          Case 2
            SetPixel(X + XX, Y + YY, C2)
        End Select
      Next
    Next

    Modify

    RefreshImage(X, Y, W, H)

  'END WITH

End


Private Sub DrawGhost(Optional bNoBegin As Boolean)

  Dim iS2 As Integer
  Dim iSH As Integer
  Dim iWH As Integer
'If Not $hImage Then Return
  'WITH FIconTool

    If $sTool = "select" And Not $bSelect Then Return

    iS2 = $iScale \ 2
    iSH = $iScale
    iWH = iSH * 2 + 1

    If Not bNoBegin Then Draw.Begin(dwgIcon)

    Select Case $sTool

      Case "line"

        Draw.Invert = True
        Draw.LineStyle = Line.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Line($X * $iScale + iS2, $Y * $iScale + iS2, $X2 * $iScale + iS2, $Y2 * $iScale + iS2)
        Draw.Rect($X * $iScale, $Y * $iScale - 1, $iScale1, $iScale1)
        Draw.Rect($X2 * $iScale, $Y2 * $iScale - 1, $iScale1, $iScale1)

      Case "select"

        Draw.Invert = True
        Draw.LineStyle = Line.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Rect(Min($X, $X2) * $iScale, Min($Y, $Y2) * $iScale, (Abs($X - $X2) + 1) * $iScale + 1, (Abs($Y - $Y2) + 1) * $iScale + 1)

      Case "rect"

        Draw.Invert = True
        Draw.LineStyle = Line.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Rect(Min($X, $X2) * $iScale, Min($Y, $Y2) * $iScale, (Abs($X - $X2) + 1) * $iScale + 1, (Abs($Y - $Y2) + 1) * $iScale + 1)
        If $iMode = 0 Then
          If Abs($X - $X2) > 1 And Abs($Y - $Y2) > 1 Then
            Draw.Rect((Min($X, $X2) + 1) * $iScale, (Min($Y, $Y2) + 1) * $iScale, (Abs($X - $X2) - 1) * $iScale + 1, (Abs($Y - $Y2) - 1) * $iScale + 1)
          Endif
        Endif

      Case "circle"

        Draw.Invert = True
        Draw.LineStyle = LINE.Solid
        Draw.LineWidth = 3
        Draw.FillStyle = Fill.None
        Draw.Foreground = Color.White
        Draw.Ellipse(Min($X, $X2) * $iScale, Min($Y, $Y2) * $iScale, (Abs($X - $X2) + 1) * $iScale + 1, (Abs($Y - $Y2) + 1) * $iScale + 1)
        If $iMode = 0 Then
          If Abs($X - $X2) > 1 And Abs($Y - $Y2) > 1 Then
            Draw.Ellipse((Min($X, $X2) + 1) * $iScale, (Min($Y, $Y2) + 1) * $iScale, (Abs($X - $X2) - 1) * $iScale + 1, (Abs($Y - $Y2) - 1) * $iScale + 1)
          Endif
        Endif

    End Select

    If Not bNoBegin Then
      Draw.End
      $bGhost = Not $bGhost
    Endif

  'END WITH

End


Private Sub BeginUndo()
  If Not $hImage Then Return  'commented out temp 03aug09
  If $iBeginUndo = 0 Then
    $hUndo[$iUndo] = $hImage.Copy()
    $iUndo = ($iUndo + 1) Mod MAX_UNDO
  Endif
  Inc $iBeginUndo

End

Private Sub EndUndo()
  
  Dec $iBeginUndo
  
End

Private Sub SetUndo()
  
  BeginUndo
  EndUndo
  
End



Public Sub Undo()
 'If Not $hImage Then Return
  If HasSelection() Then
    HideSelection
    Return
  Endif

  Inc Application.Busy

  Dec $iUndo
  If $iUndo < 0 Then $iUndo = MAX_UNDO - 1
  If $hUndo[$iUndo] Then
    $hImage = $hUndo[$iUndo]
    $hUndo[$iUndo] = Null
    'PRINT svwICon.ClientX; svwIcon.ClientY; svwIcon.ClientW, svwIcon.ClientH
    'PRINT svwICon.ScrollX; svwIcon.ScrollY
    'dwgIcon.Refresh(svwIcon.ScrollX, svwIcon.ScrollY, svwIcon.ClientW, svwIcon.ClientH)
    'svwIcon.Refresh
    RefreshZoom
    If dwgPaste.Visible Then dwgPaste.Refresh
    Modify
  Endif

  Dec Application.Busy

End


' PRIVATE SUB RefreshSelect()
'
'   DIM X AS Integer
'   DIM Y AS Integer
'   DIM X2 AS Integer
'   DIM Y2 AS Integer
'   DIM W AS Integer
'   DIM H AS Integer
'
'   IF $bSelect THEN
'
'     panSelectN.Visible = FALSE
'     panSelectS.Visible = FALSE
'     panSelectW.Visible = FALSE
'     panSelectE.Visible = FALSE
'
'     X = $XS * $iScale
'     Y = $YS * $iScale
'     X2 = ($XS + $WS) * $iScale
'     Y2 = ($YS + $HS) * $iScale
'     W = $WS * $iScale
'     H = $HS * $iScale
'
'     panSelectN.Move(X - WIDTH_SEL, Y - WIDTH_SEL, W + WIDTH_SEL * 2, WIDTH_SEL)
'     panSelectS.Move(X - WIDTH_SEL, Y2, W + WIDTH_SEL * 2, WIDTH_SEL)
'
'     panSelectW.Move(X - WIDTH_SEL, Y, WIDTH_SEL, H)
'     panSelectE.Move(X2, Y, WIDTH_SEL, H)
'
'   ENDIF
'
'   panSelectN.Visible = $bSelect
'   panSelectS.Visible = $bSelect
'   panSelectW.Visible = $bSelect
'   panSelectE.Visible = $bSelect
'
' END

Public Function HasSelection() As Boolean

  Return dwgPaste.Visible

End



Public Sub HideSelection()

  If Not dwgPaste.Visible Then Return

  If $bPrivate Then
    DoPaste
    $bPrivate = False
  Endif

  $bSelect = False
  $XS = 0
  $YS = 0
  dwgPaste.Visible = False

End


Private Sub ShowSelection()

  $bSelect = True
  CopySelection
  ShowPaste
  If $bPrivate Then 
    DeleteSelection
    RefreshPaste
  Endif
  Wait

End


Private Sub FloodFill(X As Integer, Y As Integer, C As Integer, iMode As Integer)

  Dim aStack As New Integer[]
  Dim aNextStack As New Integer[]
  Dim C2 As Integer
  Dim CS As Integer
  Dim X1 As Integer
  Dim Y1 As Integer
  Dim X2 As Integer
  Dim Y2 As Integer
 'If Not $hImage Then Return
  'WITH FIconTool

    If iMode = 1 Then
      C2 = OtherColor(C)
    Else
      C2 = C
    Endif

  'END WITH

  CS = $hImage[X, Y]
  If CS = C Or CS = C2 Then Return

  Inc Application.Busy

  X1 = X
  Y1 = Y
  X2 = X
  Y2 = Y

  aNextStack.Push(X)
  aNextStack.Push(Y)
  SetPixelAlt(X, Y, C, C2)
  

  While aNextStack.Count

    aStack = aNextStack
    aNextStack = New Integer[]

    While aStack.Count

      Y = aStack.Pop()
      X = aStack.Pop()
      
      X1 = Min(X1, X)
      Y1 = Min(Y1, Y)
      X2 = Max(X2, X)
      Y2 = Max(Y2, Y)
  
      If X > 0 Then
        If $hImage[X - 1, Y] = CS Then
          aNextStack.Push(X - 1)
          aNextStack.Push(Y)
          SetPixelAlt(X - 1, Y, C, C2)
        Endif
      Endif
  
      If Y > 0 Then
        If $hImage[X, Y - 1] = CS Then
          aNextStack.Push(X)
          aNextStack.Push(Y - 1)
          SetPixelAlt(X, Y - 1, C, C2)
        Endif
      Endif
  
      If X < ($hImage.Width - 1) Then
        If $hImage[X + 1, Y] = CS Then
          aNextStack.Push(X + 1)
          aNextStack.Push(Y)
          SetPixelAlt(X + 1, Y, C, C2)
        Endif
      Endif
  
      If Y < ($hImage.Height - 1) Then
        If $hImage[X, Y + 1] = CS Then
          aNextStack.Push(X)
          aNextStack.Push(Y + 1)
          SetPixelAlt(X, Y + 1, C, C2)
        Endif
      Endif
      
    Wend

  Wend

  Modify
  RefreshImage(X1, Y1, X2 - X1 + 1, Y2 - Y1 + 1)

  Dec Application.Busy

End


Private Sub CopySelection()
 'If Not $hImage Then Return
  'IF dwgPaste.Visible THEN RETURN

  If $bSelect Then
    Clipboard.Copy($hImage.Copy($XS, $YS, $WS, $HS))
  Else
    Clipboard.Copy($hImage)
  Endif

End


Private Sub DeleteSelection()

  SetUndo
  If HasSelection() Then
    DrawRect($XS, $YS, $WS, $HS, -1, 1)
  Else
    $hImage.Fill(-1)
    RefreshAllImage()
    Modify
  Endif

End



Public Sub RefreshPaste()

  If Not $hPaste Then Return

  dwgPaste.Move($XS * $iScale, $YS * $iScale, $hPaste.Width * $iScale, $hPaste.Height * $iScale)
  If Not dwgPaste.Visible Then
    dwgPaste.Show
  Else
    dwgPaste.Refresh
  Endif

  ' IF dwgPaste.Visible THEN dwgPaste.Refresh

End



Public Sub ShowPaste(Optional bReset As Boolean)
  If Not $hImage Then Return 'I put this in 03Aug09
  If Clipboard.Type <> Clipboard.Image Then Return

  $hPaste = Clipboard.Paste()
  $WS = $hPaste.Width
  $HS = $hPaste.Height

  If bReset Then
    $XS = ($hImage.Width - $WS) \ 2
    $YS = ($hImage.Height - $HS) \ 2
    svwIcon.Scroll($XS * $iScale, $YS * $iScale)
  Endif

  RefreshPaste

  $bSelect = True

End


Private Sub HidePaste()

  dwgPaste.Hide

End

Private Sub PrintColor(C As Integer)
  
  ' Print "("; Color[C].Red; ","; Color[C].Green; ","; Color[C].Blue; ","; Color[C].Alpha; ") ";
  
End

Private Sub past_rt()
  
  Dim X As Integer
  Dim Y As Integer
  Dim C As Integer
 'If Not $hImage Then Return
   $hpaste = Clipboard.Paste() 'temp inserted 03Aug09
   $hImage = New Image
' $hpaste = Clipboard.Image
  If $bTrans Then

    For X = 0 To $hPaste.Width - 1
      For Y = 0 To $hPaste.Height - 1
        'C = $hPaste[X, Y]
        'IF C < 0 THEN CONTINUE
        ' PrintColor(C)
        ' PrintColor($hImage[X + $XS, Y + $YS])
        ' ' Print "-> ";
        ' PrintColor(Color.Blend(C, $hImage[X + $XS, Y + $YS]))
        ' PRINT
        $hImage[X + $XS, Y + $YS] = Color.Blend($hPaste[X, Y], $hImage[X + $XS, Y + $YS])
      Next
    Next

  Else

    For X = 0 To $hPaste.Width - 1
      For Y = 0 To $hPaste.Height - 1
        $hImage[X + $XS, Y + $YS] = $hPaste[X, Y]
      Next
    Next

  Endif

  Modify

  
  
End

Private Sub PasteSelection()

  Dim X As Integer
  Dim Y As Integer
  Dim C As Integer
 'If Not $hImage Then Return
 If Clipboard.Type <> Clipboard.Image Then Return
 
 $hpaste = Clipboard.Paste()
  If $bTrans Then

    For X = 0 To $hPaste.Width - 1
      For Y = 0 To $hPaste.Height - 1
        'C = $hPaste[X, Y]
        'IF C < 0 THEN CONTINUE
        ' PrintColor(C)
        ' PrintColor($hImage[X + $XS, Y + $YS])
        ' ' Print "-> ";
        ' PrintColor(Color.Blend(C, $hImage[X + $XS, Y + $YS]))
        ' PRINT
        $hImage[X + $XS, Y + $YS] = Color.Blend($hPaste[X, Y], $hImage[X + $XS, Y + $YS])
      Next
    Next

  Else

    For X = 0 To $hPaste.Width - 1
      For Y = 0 To $hPaste.Height - 1
        $hImage[X + $XS, Y + $YS] = $hPaste[X, Y]
      Next
    Next

  Endif

  Modify

End



Public Sub DoPaste()

  Dim bTrans As Boolean
 'If Not $hImage Then Return
  ' If Not dwgPaste.Visible Then
  '   ShowPaste(True)
  '   $bPrivate = False
  '   Return
  ' Endif
  ' 
  ' Inc Application.Busy 'put all this back in commented out temorarily 03aug09 whilst
  'mucking around with pasting external images.

  SetUndo
  PasteSelection

  Dec Application.Busy

End


Public Sub dwgPaste_MouseDown()

  $X = Mouse.ScreenX - dwgPaste.ScreenX
  $Y = Mouse.ScreenY - dwgPaste.ScreenY

End

Public Sub dwgPaste_MouseMove()

  Dim XP As Integer
  Dim YP As Integer

  RefreshCoord(Mouse.X \ $iScale + $XS, Mouse.Y \ $iScale + $YS)
  
  If Not Mouse.Left Then Return

  XP = (Mouse.ScreenX - $X - dwgIcon.ScreenX) \ $iScale
  YP = (Mouse.ScreenY - $Y - dwgIcon.ScreenY) \ $iScale

  If XP = $XS And YP = $YS Then Return

  $XS = XP
  $YS = YP

  dwgPaste.Refresh
  dwgPaste.Move($XS * $iScale, $YS * $iScale)
  'dwgPaste.Show

  UpdateScroll(Mouse.X + dwgPaste.X, Mouse.Y + dwgPaste.Y)

End

Private Sub UpdateScroll(X As Integer, Y As Integer)

  Dim NX As Integer
  Dim NY As Integer

  If X >= (svwIcon.ScrollX + svwIcon.ClientW) Then
    NX = X - svwIcon.ClientW + 1
  Else If X < svwIcon.ScrollX Then
    NX = Max(0, X)
  Else
    NX = svwIcon.ScrollX
  Endif

  If Y >= (svwIcon.ScrollY + svwIcon.ClientH) Then
    NY = Y - svwIcon.ClientH + 1
  Else If Y < svwIcon.ScrollY Then
    NY = Max(0, Y)
  Else
    NY = svwIcon.ScrollY
  Endif

  svwIcon.Scroll(NX, NY)

End


Public Sub dwgPaste_MouseUp()

  If Mouse.Right Then
    DoPaste
  Endif

End

Public Sub DoFlip(iMode As Integer)
 
  Dim iAngle As Float
 If Not $hImage Then Return
  If dwgPaste.Visible Then

    Select Case iMode

      Case 0
        $hPaste = $hPaste.Flip()

      Case 1
        $hPaste = $hPaste.Mirror()

      Case 2
        $hPaste = $hPaste.Rotate(Rad(-90))

      Case 3
        $hPaste = $hPaste.Rotate(Rad(90))

    End Select

    RefreshPaste

  Else

    SetUndo

    Select Case iMode

      Case 0
        $hImage = $hImage.Flip()

      Case 1
        $hImage = $hImage.Mirror()

      Case 2
        $hImage = $hImage.Rotate(Rad(-90))
        DrawTitle

      Case 3
        $hImage = $hImage.Rotate(Rad(90))
        DrawTitle

    End Select

    RefreshZoom
    Modify

  Endif

End

Public Sub SelectAll()
 'If Not $hImage Then Return
  HideSelection
  $XS = 0
  $YS = 0
  $WS = $hImage.Width
  $HS = $hImage.Height
  ShowSelection

End


Public Sub Form_KeyPress()

  If Key.Control Then
    If Key.Code = Key["Z"] Then
      Undo
    Else If Key.Code = Key["A"] Then
      If $sTool = "select" Then
        SelectAll
      Endif
    Else If Key.Code = Key["S"] Then
      Save
    Endif
  Else
    If Key.Code = Key["Esc"] Then
      HideSelection
    Endif
  Endif

End


Public Sub Clear()
   'If Not $hImage Then Return
  If Message.Delete(("Do you want to clear the image ?"), ("Clear"), ("Cancel")) <> 1 Then Return

  SetUndo
  $hImage.Fill(-1)
  RefreshAllImage()
  Modify

End

Public Sub dwgIcon_DblClick()

  DrawGhost

End
Public Sub Form_Show()
  Dim pic As Picture
  Dim image1 As New Image
  Me.Center()
  'image1.Stretch = True
  'Image.Load("icons/body/female_back.png")
 ' pic = New Picture
  
'ToolButton20.Picture = Picture.Load("icons/body/female_back.png")
 If bediting Then
    'Print "trying to edit a picture'"
    Try Picture_Load(sPicturePath)
 End If
End

Public Sub Form_Close() 

  ' If $bModify Then
  '   If Not Project.AboutToQuit Then
  '     Select Case Message.Question(("This image has been modified.\nDo you want to save it ?"), ("Save"), ("Close"), ("Cancel"))
  '       Case 1
  '         Save
  '       Case 3
  '         Stop Event
  '         Return
  '     End Select
  '   Endif
  ' Endif

  'Project.Files[Path] = Null

End

Public Sub ZoomIn()

  Dim iPos As Integer
 'If Not $hImage Then Return
  iPos = $aZoom.Find($iScale)
  If iPos < 0 Or iPos >= ($aZoom.Count - 1) Then Return
  $iScale = $aZoom[iPos + 1]
  RefreshZoom

End

Public Sub ZoomOut()

  Dim iPos As Integer
 'If Not $hImage Then Return
  iPos = $aZoom.Find($iScale)
  If iPos <= 0 Then Return
  $iScale = $aZoom[iPos - 1]
  RefreshZoom

End


Private Sub Zoom()
   'If Not $hImage Then Return
'rt  $iScale = $aZoom[cmbZoom.Index]
  RefreshZoom
  
End



Public Sub Form_Enter()

  dwgIcon.Mouse = GetMouse()

End


Public Sub SwapColor(Optional bInv As Boolean)

  Dim C1 As Integer
  Dim C2 As Integer

  'WITH FIconTool

    C1 = GetColor(1)
    C2 = GetColor(2)
    If bInv Then Swap C1, C2

  'END WITH

  If dwgPaste.Visible Then

    $hPaste.Replace(C1, C2)
    RefreshPaste

  Else

    SetUndo
    $hImage.Replace(C1, C2)
    RefreshZoom
    Modify

  Endif

End

Public Sub dwgIcon_KeyPress()

  Form_KeyPress  

End

Public Sub dwgPaste_KeyPress()

  Form_KeyPress  

End

Private Sub RedrawColor(iColor As Integer, X As Integer, Y As Integer, W As Integer, H As Integer)

  Draw.FillStyle = Fill.Solid
  Draw.LineStyle = Line.None
  
  Draw.FillColor = Color.Blend(iColor, &H808080&)
  Draw.Rect(X, Y, W, H)

  Draw.FillColor = Color.Blend(iColor, &HC0C0C0&)
  Draw.Rect(X + W \ 2, Y, W \ 2, H \ 2)
  Draw.Rect(X, Y + H \ 2, W \ 2, H \ 2)

  Draw.LineStyle = Line.Solid
  Draw.FillStyle = Fill.None
  Draw.Foreground = Color.Gray

  Draw.Rect(X, Y, W, H)

  Return

End

Public Sub dwgColor_Draw()

  Dim iColor As Integer
  
  iColor = Last.Tag
  If iColor >= 0 And iColor < $cColor.Count Then  
    iColor = $cColor[iColor]
  Else
    iColor = -1
  Endif

  RedrawColor(iColor, 3, 3, 18, 18)

End

Private Sub SetMode(iMode As Integer)
  
  $bIgnoreClick = True
  If $hMode Then $hMode.Value = False
  $iMode = iMode
'  $hMode = [btnBorder, btnFilled, btnBorderFilled][iMode]
  
  '$hMode.Value = True
  $bIgnoreClick = False
  
End

Private Sub SetTransparent(bTrans As Boolean)
  
  $bIgnoreClick = True
  If $hTrans Then $hTrans.Value = False
  $bTrans = bTrans
'  $hTrans = If($bTrans, btnTransparent, btnOpaque)
'  $hTrans.Value = True
  $bIgnoreClick = False
  
  If HasSelection() Then RefreshPaste
  
End


Public Sub btnTool_Click()

  If $bIgnoreClick Then Return

  Select Case Last.Tag
    Case "open file"
      Dialog.Title = "Select Image File"
      Dialog.Filter = ["*.png", "Image Files", "*", "All files"]
      If Dialog.OpenFile() Then Return
        Print Dialog.Path 
       ' FImageGet.$hImage = Image.Load(Dialog.Path)
          Try Picture_Load(Dialog.Path)
    Case "move", "select", "pen", "line", "rect", "circle", "fill", "fill-alt", "pipette"
      SetTool(Last)
  
    Case "opaque"
      SetTransparent(False)

    Case "transparent"
      SetTransparent(True)
      
    Case "border"
      SetMode(0)
      
    Case "full"
      SetMode(1)
      
    Case "border-full"
      SetMode(2)
      
    Case "zoom-in"
      ZoomIn
      
    Case "zoom-out"
      ZoomOut
      
    Case "save"
      'Insert_Picture()
      
    Case "undo"
      Undo
      
    Case "clear"
      Clear
    
    Case "swap"
      SwapColor
      
    Case "flip-h"
      DoFlip(0)
            
    Case "flip-v"
      DoFlip(1)
            
    Case "rotate"
      DoFlip(2)
            
    Case "rotate-back"
      DoFlip(3)
      
    Case "exchange"
      Swap $iForeground, $iBackground
      RefreshColor
      
    Case "cut"
      If HasSelection() Then
        Clipboard.Copy($hPaste)
        If $bPrivate Then PasteSelection
        BeginUndo
        $bPrivate = False
        DeleteSelection
        HideSelection
        EndUndo
      Else
        BeginUndo
        CopySelection
        DeleteSelection
        EndUndo
      Endif
      
    Case "copy"
      If HasSelection() Then
        Clipboard.Copy($hPaste)
        HideSelection
      Else
        CopySelection
      Endif
    
    Case "paste"
      DoPaste 'PasteSelection
      SetTool(btnSelect) 'put these back in adn remove my line
    '  past_rt()
  End Select
  
End

'----------------------------------------------------------------------------------------

' PRIVATE SUB ChangeMode(hImage AS ToolButton, sMode AS String, sLstPict AS String, sLstToolTip AS String)
' 
'   DIM iMode AS Integer
'   DIM aLstPict AS String[]
'   DIM aLstToolTip AS String[]
' 
'   aLstPict = Split(sLstPict)
'   aLstToolTip = Split(sLstToolTip)
' 
'   iMode = ($cMode[sMode] + 1) MOD aLstPict.Count
' 
'   hImage.Picture = Picture["img/16" &/ aLstPict[iMode] & ".png"]
'   hImage.ToolTip = aLstToolTip[iMode]
' 
'   $cMode[sMode] = iMode
' 
' END


' PUBLIC SUB btnTool_MouseUp()
' 
'   DIM hLast AS ToolButton
'   DIM bCommand AS Boolean
'   DIM bUp AS Boolean
' 
'   hLast = LAST
' 
'   bCommand = TRUE
' 
'   SELECT CASE hLast.Tag
' 
'     CASE "zoom"
' 
'       IF Mouse.Left THEN
'         $hCurrent.ZoomIn
'       ELSE IF Mouse.Right THEN
'         $hCurrent.ZoomOut
'       ENDIF
' 
'     CASE "save"
' 
'       $hCurrent.Save
' 
'     CASE "undo"
' 
'       $hCurrent.Undo
' 
'     CASE "clear"
' 
'       $hCurrent.Clear
' 
'     CASE "swap"
' 
'       $hCurrent.SwapColor(Mouse.Left)
' 
'     CASE "paste"
' 
'       $hCurrent.DoPaste
'       hLast.Value = FALSE
'       IF $hTool <> btnSelect THEN
'         $hLast = btnSelect
'         RevertTool
'       ENDIF
'       RETURN
' 
'     CASE "flip"
' 
'       IF Mouse.Left THEN
'         $hCurrent.DoFlip
'       ELSE
'         ChangeMode(btnFlip, "flip", "flip-h,flip-v,rotate,rotate-back", ("Horizontal flip,Vertical flip,Rotate clockwise,Rotate counter-clockwise"))
'       ENDIF
' 
'     DEFAULT
'       bCommand = FALSE
' 
'   END SELECT
' 
'   IF bCommand THEN
'     'hLast.Border = Border.None
'     hLast.Value = FALSE
'     RETURN
'   ENDIF
' 
'   'IF Button = 1 OR hLast <> $hTool THEN
' 
'   'ELSE
' 
'     SELECT CASE hLast.Tag
' 
'       CASE "rect"
'         IF Mouse.Right THEN
'           ChangeMode(btnRect, "rect", "square,square-f,square-fr", ("Rectangle,Filled rectangle,Filled delimited rectangle"))
'         ENDIF

' 
'       CASE "circle"
'         IF Mouse.Right THEN
'           ChangeMode(btnCircle, "circle", "circle,circle-f,circle-fr", ("Ellipse,Filled ellipse,Filled delimited ellipse"))
'         ENDIF
' 
'       CASE "fill"
'         IF Mouse.Right THEN
'           ChangeMode(btnFill, "fill", "fill,fill-alt", ("Flood fill,Patterned flood fill"))
'         ENDIF
' 
'       CASE "select"
'         IF Mouse.Left THEN
'           IF hLast = $hTool THEN
'             IF NOT $hCurrent.HasSelection() THEN
'               $hCurrent.SelectAll
'             ELSE
'               $hCurrent.HideSelection
'             ENDIF
'           ELSE
'             $hCurrent.HideSelection
'           ENDIF
'         ELSE IF Mouse.Right THEN
'           ChangeMode(btnSelect, "select", "frame,frame-opaque", ("Select and transparent paste,Select and opaque paste"))
'           $hCurrent.RefreshPaste
'         ENDIF
' 
'       'CASE "move"
'       '
'       '  IF Button AND Mouse.Right THEN
'       '    ChangeMode(imgMove, "move", "scroll,move",("Move,Translate"))
'       '  ENDIF
' 
'     END SELECT
' 
'   'ENDIF
' 
'   $hLast = $hTool
'   $hTool = hLast
' 
'   IF $hLast THEN
'     IF $hLast <> $hTool THEN
'       '$hLast.Border = Border.None
'       $hLast.Value = FALSE
'     ENDIF
'   ENDIF
' 
'   ChangeTool
' 
' END


Public Sub SetTool(hTool As ToolButton)

  If Not hTool Then Return

  ' IF hTool = $hTool THEN
  '   $hTool.Value = TRUE
  '   RETURN
  ' ENDIF


  If hTool.Tag = "pipette" Then $hLast = $hTool

  $bIgnoreClick = True
  If $hTool Then $hTool.Value = False
  $hTool = hTool
  $hTool.Value = True 
  $bIgnoreClick = False 

  $sTool = $hTool.Tag

  Select $sTool

    Case "move"
      SetIcon(Mouse.SizeAll)

    Case "pen"
      SetIcon(Mouse.Arrow)

    Case Else
      SetIcon(Mouse.Cross)

  End Select
  
End


Public Sub RevertTool()

  SetTool($hLast)

End



Public Sub dwgColor_MouseDown()

  Dim C As Integer

  C = Last.Tag

  If C < $cColor.Count Then
    C = $cColor[C]
  Else
    C = -1
  Endif

  If Mouse.Left Then
    $iForeground = C
  Else
    $iBackground = C
  Endif

  RefreshColor

End

Private Sub RefreshColor()

'  dwgForeground.ToolTip = FormatColor($iForeground)
 ' dwgBackground.ToolTip = FormatColor($iBackground)
 ' dwgForeground.Refresh
 ' dwgBackground.Refresh

End

Private Sub FormatColor(iColor As Integer) As String
  
  Return Subst("R: &1", Color[iColor].Red) & " " & 
    Subst("G: &1", Color[iColor].Green) & " " & 
    Subst("B: &1", Color[iColor].Blue) & " " & 
    Subst("A: &1", Color[iColor].Alpha)
    
End


Public Sub SetForeground(iColor As Integer)

  $iForeground = iColor
  RefreshColor

End

Public Sub SetBackground(iColor As Integer)

  $iBackground = iColor
  RefreshColor

End



Public Sub dwgForeground_Draw()

  'Draw.LineStyle = Line.None 'LINE.Solid
''''  RedrawColor($iForeground, 3, 3, dwgForeground.Width - 6, dwgForeground.Height - 6)

End


Public Sub dwgBackground_Draw()

  'Draw.LineStyle = Line.None 'LINE.Solid
''''  RedrawColor($iBackground, 3, 3, dwgBackground.Width - 6, dwgBackground.Height - 6)
  
End


Public Function GetColor(iButton As Integer) As Integer

  If iButton = 1 Then
    Return $iForeground
  Else
    Return $iBackground
  Endif

End


Public Sub dwgForeground_MouseUp()

  If FColorChooser.Run("&H" & Hex$($iForeground, 8), True) Then Return
  $iForeground = FColorChooser.Value
  RefreshColor

End

Public Sub dwgBackground_MouseUp()

  If FColorChooser.Run("&H" & Hex$($iBackground, 8), True) Then Return
  $iBackground = FColorChooser.Value
  RefreshColor

End

Public Function OtherColor(C As Integer) As Integer

  If C = $iBackground Then
    Return $iForeground
  Else
    Return $iBackground
  Endif

End


Private Sub SetIcon(iMouse As Integer)

  $iMouse = iMouse
  Form_Enter

End

Public Function GetMouse() As Integer

  Return $iMouse

End

Public Sub Form_Activate()

  ' To be activated  

End


Public Sub cmbZoom_Click()

''  Object.Lock(cmbZoom)
 '' Zoom
''  Object.UnLock(cmbZoom)

End


Private Function ReadOnly_Read() As Boolean

  Return $bReadOnly  

End


Public Sub OnProjectDebug()

  SetReadOnly

End

Public Sub Reload()

  Dim iInd As Integer
  'If Not $hImage Then Return
  HideSelection
 ' $hImage = New Image
  $hImage = Image.Load(Path)
  
  For iInd = 0 To 31
    $hUndo[iInd] = Null
  Next 
  $iUndo = 0
  
  $XD = COORD_HIDE
  $YD = COORD_HIDE

  Modify(True)
  ' Print "Just before refresh"
  dwgIcon.Refresh
  ' Print "after refresh"
End


Public Sub mnuReload_Click()

  If IsModified() Then
    If Message.Warning(("The file has been modified.\n\nAll your changes will be lost."), ("Reload"), ("Cancel")) <> 1 Then Return
  Endif

  Reload

End

' PUBLIC SUB Form_Resize()
' 
'   panPreview.Move(ME.W - $hImage.W - 8, ME.H - $hImage.H - 8, $hImage.W + 8, $hImage.H + 8)
' 
' END

Public Sub dwgPreview_Draw()

  Draw.Image($hImage, 4, 4)

End

' PUBLIC SUB btnPreview_Click()
' 
'   svwPreview.Visible = btnPreview.Value
'   IF svwPreview.Visible THEN splPreview.Layout = CStr(dwgPreview.W) & "," & CStr(ME.H - dwgPreview.W - 16)
' 
' END

Public Sub Picture_Load(sPath As String)

  Dim sText As String
  Dim iScale As Integer
  Dim iColor As Integer
  Dim hColor As DrawingArea
  Dim hCtrl As Control
 
'
  Path = sPath                        'path here is the fully qualified path/filename.png
 
 ' Name = Mid$(sPath, Len(File.Dir(Project.Path)) + 1)
 ' Print "Name is ", Name
  $iMaxW = Me.Width
  $iMaxH = Me.Height

 ' For Each iScale In $aZoom
  '  cmbZoom.Add(iScale & " x")
 ' Next

 ' For iColor = 0 To $cColor.Max + 1
 '   hColor = New DrawingArea(tlbColor) As "dwgColor"
 '   hColor.Resize(24, 24)
  '  hColor.Tag = iColor
  'Next
$iScale = 1  
  Reload
  
  
 ' For Each iScale In $aZoom
   ' If ($hImage.Width * iScale) > (Project.Workspace.ClientWidth * 0.75) Or ($hImage.Height * iScale) > (Project.Workspace.ClientHeight * 0.75) Then Break
 '   $iScale = iScale
 ' Next

  SetBackground(Color.White)
  SetForeground(Color.Black)

  SetTransparent(True)
  SetMode(0)
'  SetTool(btnMove)
  SetReadOnly
'  dwgPreview.Resize($hImage.W + 8, $hImage.H + 8)
  'panPreview.Dimension = dwgPreview.W + 8
  
  RefreshZoom
End

' 
' Public Sub BodyImage_Load_old()
'    '--------------------------------------------------
'    'Loads the selected body part image into the editor
'    '--------------------------------------------------
'  Select Case Last.Tag
'  Case "ear anterior"
'   sPicturePath = "icons/body/ear_anterior.png"
' 
'  Case "ear posterior"
'   sPicturePath = "icons/body/ear_posterior.png"
' 
'  Case "male torso anterior"
'    sPicturePath = "icons/body/male_front.png"
'  
'  ' Case "female torso posterior"
'    sPicturePath = "icons/body/female_back.png"
'  
'  Case "female torso anterior"
'    sPicturePath = "icons/body/female_front.png"
'  
'  Case "chest"
'    sPicturePath = "icons/body/chest_anterior.png"
'  
'  Case "body"
'    sPicturePath = "icons/body/body_anterior.png"
' 
'  Case "head"
'    sPicturePath = "icons/body/head_left.png"
'  Case "abdomen"
'    sPicturePath = "icons/body/eye_nose_side.png"
'  Case "hand"
'    sPicturePath = "icons/body/foot_side.png"
'  End Select
'  
'   Try Picture_Load(sPicturePath)
'   If Error Then
'      Message.info("Unable to find image file to load")
'   End If
'   
' 
' End
' Sub Temp_LoadPic()
'   
'   sPicturePath = "/home/richard/coding/gambas2/gb2/icons/body/female_front.png"
'   Try Picture_Load(sPicturePath)
'   If Error Then
'      Message.info("Unable to find image file to load")
'   End If
' End



Public Sub BodyPicture_Popup(PBox As Picturebox)
   '-------------------------------------------------
   'As User moves mouse of the available pictures
   'show an enlarged preview as the actual pictures
   'stuck on the panels are shrunken to quite a small
   'size which could be difficult for some eyes
   '-------------------------------------------------
   'Print "icons/body/" & PBox.tag & ".png"
   With Picturebox4
      .top = Toolbar1.top - Picturebox4.height
      .Visible = True
      .Picture = Picture["icons/body/" & PBox.tag & ".png"]
      .left = (PBox.parent.Left + PBox.width / 2) - Picturebox4.width / 2
   End With
 End


Public Sub ImageButtons_Leave()
   '----------------------------------------------------
   'Mouse leaves pseudo-button, remove the popup picture
   '----------------------------------------------------
  Picturebox4.Visible = False
End

Public Sub ImageButtons_Enter()
   '------------------------------------------------------
   'Each of the pictures on a panel is kinda-like a button
   'as mouse goes over the pseudo-button, display a larger
   'popup picture for those of failing eyesight like me
   '------------------------------------------------------
   BodyPicture_Popup(Last)
End


Public Sub ImageButtons_MouseUp()
   '---------------------------------------
   'Acts like a click_event
   'loads image under mouse to drawing area
   '---------------------------------------
  ' BodyImage_Load(Last)
   sPicturePath = "icons/body/" & Last.tag & ".png"
   'Print "path was", sPicturePath
    Try Picture_Load("icons/body/" & Last.tag & ".png")
   If Error Then
      Message.info("Unable to find image file to load")
   End If

End

Public Sub PictureBox4_DblClick()

  

End




Public Sub ImageButtons_MouseDown()

  

End
