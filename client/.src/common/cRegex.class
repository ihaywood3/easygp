' Gambas class file

' Copyright (C) 2013-2014 Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'----------------------------------------------------------------------------------
' This module implements a complex regexp-based search-replace function
' similar to those found in Python and Ruby

' this can be set before running a search and extracted afterwards
Public Subject As String
Property Read NumMatches As Integer


Private reg As Regexp
Private done As String


' re: the regular expression string
' subj: the subject to search for
' compileOptions: as for the Gambas native Regexp class
Public Sub _new(re As String, Optional subj As String = "", compileOptions As Integer = 0)
   
  reg = New Regexp(subj, re, compileOptions)
  Subject = subj
  done = Null
  
End

' during the search loop, subscript to get the submatch text
Public Sub _get(idx As Integer) As String
   
   Return reg[idx].Text
   
End

' called only during the search loop
' having performed whatever transform, put this replacement in place of the original regular expression
Public Sub Set(v As String)
   
   done &= v
   
End

' loop over all searches in the subject string
' replacements submitted using Set( ) above
Public Sub _next()
   
  If IsNull(Enum.Index) And If IsNull(done) Then ' the start condition
   Enum.Index = Subject
  Endif
  If Not IsNull(Enum.Index) Then reg.Exec(Enum.Index)  ' maybe blank/null/empty string at end
  If IsNull(Enum.Index) Or If reg.Offset = -1 Then 
     Subject = done & Enum.Index
     done = Null
     Enum.Stop
  Else
     done &= Left$(Enum.Index, reg.Offset)
     Enum.Index = Right$(Enum.Index, Len(Enum.Index) - (reg.Offset + Len(reg.Text)))
  Endif
   
End


' the number of submatches found
' using .Count in the underlying Regexp object
Private Function NumMatches_Read() As Integer

  Return reg.Count 

End


' perform a search-replace using the provided string
' reg: the regular expression as a string
' subj: the suubject text
' repl: the replacement text, with &1, &2, etc in this string replaced by the submatches of the regex
' compileOptions: passed to the udnerying Regexp object
' WARNING: don't try with more than 9 submatches!!!
Static Public Function Replace(reg As String, subj As String, repl As String, Optional compileOptions As Integer = 0) As String

  Dim r As New CRegex(reg, subj, compileOptions)
  Dim i As Integer
  Dim s As String
  
  For Each r
    s = repl
    For i = 1 To r.NumMatches
      s = Replace$(s, "&" & i, r[i])
    Next
    r.Set(s)   
  Next
  Return r.Subject
  
End


Static Public Sub Unit_Test()
  
  Debug cRegex.Replace("l(..)(.)l", "lee1l laa2l loo3l foo", "x&2&1x")  
   
End

