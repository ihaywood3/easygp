' Gambas class file

' Copyright (C) 2011,2012 Dr. Ian Haywood
' class to representing a Collection with the semantics we want
' specifically NULL members and can remember changes

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'----------------------------------------------------------------------

Private coll As Collection
Private mychanged As String[]
Private allkeys As String[]
Private mykey As String

Property Read changed As String[]
Property Read Count As Integer
Property Read Key As String


' allows database columns to be set as if this was a Collection
' so row!username = "John" sets field "username" to "John"
' 

Public Sub _put(value As Variant, field As String)
   Dim old_val As Variant
   Dim is_new As Boolean = False
   
   If coll.Exist(field) Then
      old_val = _get(field)
   Else 
      is_new = True
   Endif
   Me.put_unchanged(value, field)
   If Not mychanged.Exist(field) And If (old_val <> value Or is_new) Then mychanged.Add(field)
   
End

Public Sub put_unchanged(value As Variant, field As String)
   
   If IsNull(value) Then 
      coll[field] = "$*~NUL&L*"
   Else
      coll[field] = value
   Endif
   
End
' allows database columns to be accessed like a Collection, so
' row!username returns "John" after the _put command above
Public Function _get(field As String) As Variant
   
  If coll.Exist(field) Then
    If coll[field] = "$*~NUL&L*" Then Return Null
    Return coll[field]
  Else
    ' it never existed at all
    Error.Raise("Key " & field & " does not exist") ' Python-style error
  Endif 
   
End


' creats a new row from an existing collection
Public Sub _new(Optional mycoll As Collection = Null)
   
  If IsNull(mycoll) Then mycoll = New Collection
  coll = mycoll
  mychanged = New String[] 
  allkeys = Null
End

'returns true if this field exists in the row
Public Function Exist(field As String) As Boolean
   
  If coll.Exist(field) Then Return True
  Return False 
   
End

Private Function changed_Read() As String[]

   Return mychanged

End

Public Sub Save(table As String, pk_view_name As String, Optional fields As String[])
   
  ' saves the changed fields to the backend database
  ' table: the name of the table to save to (including the schema)
  ' pk_view_name: the name of this table's pk in the view that
  ' the row may come from. If exists used as PK for UPDATE, if
  ' doesn't, INSERT is performed.   
  ' fields: explicitly state the fields to save, otherwise use all changed fields
  Dim vals As New Variant[]
  Dim changed_fields As New String[]
  Dim new_coll As Collection
  Dim s As String
  
  If mychanged.Count = 0 Then Return
  If coll.Exist(pk_view_name) Then
    ' old pk exists so do update
       ' create update string
       If IsNull(fields) Then
          changed_fields = mychanged
          For Each s In mychanged
            vals.Add(_get(s)) 
          Next
       Else
          For Each s In fields
             If mychanged.Exist(s) Then
               vals.Add(_get(s))
               changed_fields.Add(s)
             Endif
          Next
       Endif
       modDBConnect.update_array(table, coll[pk_view_name], changed_fields, vals)
  Else
    ' insert
    new_coll = New Collection
    If IsNull(fields) Then
       For Each s In mychanged
         new_coll.Add(_get(s), s)
       Next
    Else
       For Each s In fields
          If mychanged.Exist(s) Then
             new_coll.Add(_get(s), s)
          Endif
       Next
    Endif
    coll[pk_view_name] = modDBConnect.insert(table, new_coll) 
  Endif
  
  If IsNull(fields) Then
     mychanged = New String[]
  Else
     ' preserve changed status on fields we didn't save on this call.
     changed_fields = New String[]
     For Each s In mychanged
        If Not fields.Exist(s) Then changed_fields.Add(s)
     Next
     mychanged = changed_fields
  Endif
End


Static Public Sub UnitTest(form_main As FMain)
   Dim coll As Collection
   
   coll = modDBConnect.exec_query_row("select * from contacts.data_persons where pk=1")
   Debug coll["1"]!memo
   coll["1"]!memo = Null
   coll["1"].Save("contacts.data_persons", "pk", ["memo"])
   
End



Private Function Count_Read() As Integer

  Recompute_Allkeys() 
  Return allkeys.Count
  
End

Private Sub Recompute_Allkeys()
   Dim v As Variant
   
   If Not IsNull(allkeys) Then Return
   Let allkeys = New String[]
   For Each v In coll
      allkeys.Add(coll.Key)
   Next

End

Public Function _next() As Variant

  If IsNull(Enum.Index) Then
    ' the enumeration has started
    Recompute_Allkeys()
    Enum.Index = 0 
  Else
    Inc Enum.Index
  Endif
  If Enum.Index >= allkeys.Count Then
     Enum.Stop
  Else
     mykey = allkeys[Enum.Index]
     Return Me[allkeys[Enum.Index]]
  Endif
     
End

Private Function Key_Read() As String

   Return mykey

End

Public Function ToJSON() As String
   
  Dim s As String = ""
  Dim i As Variant
  
  s &= "{\n"
  For Each i In Me
     s &= "    " & Me.Key & " : " & JSON.Encode(i) & " ,\n"
  Next
  s &= "}\n\n"
  Debug s
  Return s
End

' removes a key (so isn't saved to the backend at all
Public Sub Remove(key As String)
  Dim i As Integer
  
  coll.Remove(key)
  i = mychanged.Find(key)
  If i <> -1 Then mychanged.Remove(i) 
   
End

' make a new cRow with same keys, but all "changed" so saving back to the DB
Public Function Clone() As CRow
   
  Dim ret As New CRow
  Dim i As Variant
  
  For Each i In Me
     ret[Me.Key] = i
  Next
  Return ret
   
End
