' Gambas class file

' Copyright (C) 2008-2015 Dr. Richard Terry, Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY ; without Even the implied warranty Of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'
' *********************************************************************
' This is a class to run a background UNIX process and do something useful when 
' it finishes, such as make an audit entry


Private final_note As String

Private cmd As String[]
Private pro As Process
Private error_text As String
Private status As Byte
Private destdir As String
Private showing_error As Boolean
Private crashfile As String

Public Sub _new() 
  error_text = ""
  status = 0
End

Public Sub Init(cmd2 As String[], Optional destdir As String)
  cmd = cmd2
  If IsNull(destdir) Then destdir = User.Home
  Log.DebugMsg(Subst$("executing task \"&1\" object &2", cmd.Join(" "), Str$(Me)))
  pro = Exec cmd With ["PWD=" & destdir] For Read Write As "Process"
  showing_error = False
  crashfile = Null
End

' if the task crashes, try to read in this file and log it
Public Sub SetCrashFile(s As String)
   
  crashfile = s 
   
End


Public Sub Process_Read()
  Dim data As String
  Dim re As RegExp
  
  data = Read #pro, Lof(pro)
  Log.DataMsg(Subst$("task process &1 returned on stdout: \"&2\"", Str$(Me), Str$(data)))
  final_note &= data
  re = New RegExp(final_note, "~FINISH~")
  If Scan_Note(re) Then
     ' Process_Kill isn't always called unfortunately
     Log.DebugMsg(Subst$("task &1 give finish signal via stdin", Str$(Me)))
     If status = 0 Then
        status = 1
        Log.DebugMsg(Subst$("task &1 calling ME.Run_Final( )", Str$(Me)))
        Me.Run_Final()
     Endif
  Endif
  re = New RegExp(final_note, "~SAVE([^~]+)~([^~]+)~([^~]+)~")
  If Scan_Note(re) Then
     modFiles.Put(re[1].Text, re[2].Text, re[3].Text, Null)
  Endif
  Catch
     data = Error.Text
     Log.ErrorMsg(Subst$("&1: cTask.Process_Read: &2 &3", Str$(Me), data, Error.Where))
     If Not showing_error Then
        showing_error = True
        Message.Error(data)
        showing_error = False
     Endif
      
End

Private Sub Scan_Note(re As Regexp) As Boolean
   
  If re.Offset <> - 1 Then
    final_note = Left$(final_note, re.Offset) & Right$(final_note, - re.Offset - Len(re.Text)) 
    Return True
  Endif
  Return False
End


' for overriding in descendants if they need special actions
Public Sub Run_Final()
   ' NOOP
   Log.DebugMsg(Subst$("task &1 called virtual method Run_Final( )", Str$(Me)))
End

' for running in descendants if they need special actions
Public Sub Run_Error()
   
  ' NOOP 
   
End


Public Sub Process_Error(err As String)
   
  Dim re As Regexp
   re = New Regexp(err, "^\\[SSL Cipher .*\\]$") ' unfortunately ftp-ssl abuses it's stderr privileges
   If re.Offset = -1 Then
      status = 4
      Log.ErrorMsg(Subst$("task object &1 returned stderr:\"&2\"", Str$(Me), err))
      Me.Run_Error()
      If Not IsNull(crashfile) And If Exist(crashfile) And If Access(crashfile, gb.Read) Then
         Log.ErrorMsg(Subst$("crashfile &1 found and contains: &2", crashfile, File.Load(crashfile)))
      Endif
      If Not showing_error Then
         showing_error = True
         Message.Error(err, "OK")
         showing_error = False
      Endif 
   Endif
   
End

Public Sub Process_Kill()
   Dim re As Regexp
   Dim has_error As Boolean = False
   Dim error_message As String
   
   Log.DebugMsg(Subst$("task &1 triggered Process_Kill. Process.Value =  &2", Str$(Me), pro.Value))
   If pro.Value <> 0 Then
      If status <> 4 Then ' we haven't already reported it
        status = 4
        Me.Run_Error()
        If Not IsNull(crashfile) And If Exist(crashfile) And If Access(crashfile, gb.Read) Then
           Log.ErrorMsg(Subst$("crashfile &1 found and contains: &2", crashfile, File.Load(crashfile)))
        Endif
        If Not showing_error Then 
           showing_error = True
           Message.Error("Process returned error value " & pro.Value)
           showing_error = False
        Endif
      Endif
   Endif
   If status = 0 Then
     status = 1
     Log.DebugMsg(Subst$("task &1 calling Run_Fina( ) from exit signal", Str$(Me)))
     Me.Run_Final()
  Endif 
  Catch
     error_message = Error.Text
     Log.ErrorMsg(Subst$("&1: cTask.Process_Kill: &2 &3", Str$(Me), error_message, Error.Where))
     If Not showing_error Then
        showing_error = True
        Message.Error(error_message)
        showing_error = False
     Endif
End

Public Sub Close()
   
  pro.Close() 
   
End

Public Sub Send(s As String)
   
  Print #pro, s 
  Log.DataMsg(Subst$("sending to task &1 data \"&2\"", Str$(Me), s))
   
End





Static Public Sub Unit_Test()
   
  Dim t As CTask
  Dim s As String
  Dim c As CConsult
  
  s = "sleep 3\nprint \"hello from ruby!\"\n"
  c = New CConsult(modContactsDBI.Patient_Get_Using_PK(38))
  t = New CTask("/bin/sh")

  
End
