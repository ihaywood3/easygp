' Gambas class file

' Copyright (C) 2008-2014 Dr. Richard Terry, Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY ; without Even the implied warranty Of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'
' *********************************************************************
' This is a class to run a background UNIX process and do something useful when 
' it finishes, such as make an audit entry



Private cmd As String[]
Private final_sql As String
Private final_audit_note As String
Private final_audit_action As String
Private final_audit_consult As CConsult
Private final_audit_section As Integer
Private final_audit_table As String
Private final_audit_pk As Integer
Private pro As Process
Private error_text As String
Private status As Byte
Private destdir As String
Private showing_error As Boolean
Private crashfile As String

Public Sub _new()
  final_audit_action = "no-audit"
  final_audit_note = "" 
  error_text = ""
  status = 0
End

Public Sub Init(cmd2 As String[], Optional destdir As String)
  cmd = cmd2
  If IsNull(destdir) Then destdir = User.Home
  Log.DebugMsg(Subst$("executing task \"&1\" object &2", cmd.Join(" "), Str$(Me)))
  pro = Exec cmd With ["PWD=" & destdir] For Read Write As "Process"
  showing_error = False
  crashfile = Null
End

' if the task crashes, try to read in this file and log it
Public Sub SetCrashFile(s As String)
   
  crashfile = s 
   
End


' set an arbitrary SQL command to be run only if the task completes successfully
Public Sub SetSql(sql2 As String)
   final_sql = sql2
   If status = 1 Then ' program has already run
     Run_Sql()
     final_sql = Null
   Endif
End

' set an audit action on successful completion
' call signature deliberately matches modAudit.MakeAudit
Public Sub SetAudit(consult As CConsult, audit_action As String, tbl As String, fk_row As Integer, fk_section As Integer, Optional notes As String)
   
   final_audit_note &= notes
   final_audit_consult = consult
   final_audit_table = tbl
   final_audit_pk = fk_row
   final_audit_section = fk_section
   final_audit_action = audit_action
   If status = 1 Then ' program has already run
      Run_Audits()
      final_audit_action = "no-action"
   Endif
End


Public Sub Process_Read()
  Dim data As String
  Dim re As RegExp
  
  data = Read #pro, Lof(pro)
  Log.DataMsg(Subst$("task process &1 returned on stdout: \"&2\"", Str$(Me), Str$(data)))
  final_audit_note &= data
  re = New RegExp(final_audit_note, "~FINISH~")
  If Scan_Note(re) Then
     ' Process_Kill isn't always called unfortunately
     Log.DebugMsg(Subst$("task &1 give finish signal", Str$(Me)))
     If status = 0 Then
        status = 1
        Run_Audits()
        Run_Sql()
     Endif
  Endif
  re = New RegExp(final_audit_note, "~SAVE([^~]+)~([^~]+)~([^~]+)~")
  If Scan_Note(re) Then
     modFiles.Put(re[1].Text, re[2].Text, re[3].Text, Null)
  Endif
End

Private Sub Scan_Note(re As Regexp) As Boolean
   
  If re.Offset <> - 1 Then
    final_audit_note = Left$(final_audit_note, re.Offset) & Right$(final_audit_note, - re.Offset - Len(re.Text)) 
    Return True
  Endif
  Return False
End


Public Sub Process_Error(err As String)
   
  Dim re As Regexp
   re = New Regexp(err, "^\\[SSL Cipher .*\\]$") ' unfortunately ftp-ssl abuses it's stderr privileges
   If re.Offset = -1 Then
      status = 4
      Log.ErrorMsg(Subst$("task object &1 returned stderr:\"&2\"", Str$(Me), err))
      If Not IsNull(crashfile) And If Exist(crashfile) And If Access(crashfile, gb.Read) Then
         Log.ErrorMsg(Subst$("crashfile &1 found and contains: &2", crashfile, File.Load(crashfile)))
      Endif
      If Not showing_error Then
         showing_error = True
         Message.Error(err, "OK")
         showing_error = False
      Endif 
   Endif
   
End

Public Sub Process_Kill()
   Dim re As Regexp
   Dim has_error As Boolean = False
   
   Log.DebugMsg(Subst$("task &1 triggered Process_Kill. Process.Value =  &2", Str$(Me), pro.Value))
   If pro.Value <> 0 Then
      If status <> 4 Then ' we haven't already reported it
        status = 4
        If Not IsNull(crashfile) And If Exist(crashfile) And If Access(crashfile, gb.Read) Then
           Log.ErrorMsg(Subst$("crashfile &1 found and contains: &2", crashfile, File.Load(crashfile)))
        Endif
        If Not showing_error Then 
           showing_error = True
           Message.Error("Process returned error value " & pro.Value)
           showing_error = False
        Endif
      Endif
   Endif
   If status = 0 Then
     status = 1
     Run_Audits()
     Run_Sql()
  Endif 
   
End

Private Sub Run_Audits()

     If final_audit_action <> "no-audit" Then
           modAudit.MakeAudit(final_audit_consult, final_audit_action, final_audit_table, final_audit_pk, final_audit_section, final_audit_note)
           If IsNull(final_sql) Then modDBConnect.CommitTrans()
     Endif 
   
End

Private Sub Run_Sql()
   
     If Not IsNull(final_sql) Then 
          modDBConnect.exec_query(final_sql)
          modDBConnect.CommitTrans()
     Endif
   
End

Public Sub Close()
   
  pro.Close() 
   
End

Public Sub Send(s As String)
   
  Print #pro, s 
  Log.DataMsg(Subst$("sending to task &1 data \"&2\"", Str$(Me), s))
   
End





Static Public Sub Unit_Test()
   
  Dim t As CTask
  Dim s As String
  Dim c As CConsult
  
  s = "sleep 3\nprint \"hello from ruby!\"\n"
  c = New CConsult(modContactsDBI.Patient_Get_Using_PK(38))
  t = New CTask("/bin/sh")
  t.SetAudit(c, "completed", "clin_referrals.referrals", 1, 14, "faxed referrals")

  
End
