' Gambas module file

' Copyright (C) 2008-2011 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'----------------------------------------------------------------------

Private printerlist As String[]

Public Sub Print_PDF(pdf_path As String, Optional printertype As Integer = const.Paper_Plain, number_copies As Integer = 1)
   
   Dim cmd As String
   
   If pdf_path = "" Then Return
   Inc Application.Busy
   cmd = modUtil.FindProgram("lpr", "cups")
   If IsNull(cmd) Then Return
   pdf_path = Replace$(pdf_path, " ", "\\ ")
   cmd &= " " & GetOption(printertype)!lpr & " -# " & number_copies & " " & pdf_path
   'cmd &= " " & GetLprOption(printertype) & " -# " & number_copies & " " & pdf_path
   
   Shell cmd Wait
   Dec Application.Busy
   
End

Public Function Latex_To_PDF(latex As String) As String
   '---------------------------------------------------------
   'converts a latex string to a pdf and returns the filename
   '---------------------------------------------------------
   
   Dim stem As String
   Dim f As File
   Dim cmd As String
   
   Inc Application.Busy  
   stem = Temp$("printl")
   f = Open stem & ".tex" For Write Create
   Print #f, latex
   Close #f  
   cmd = modUtil.FindProgram("pdflatex", "texlive-latex-base")
   If IsNull(cmd) Then Error.Raise("LaTeX not available")
   cmd = "cd `dirname " & stem & "` ; " & cmd
   cmd &= " \\\\nonstopmode\\\\input printl.tmp.tex" 
   Shell cmd Wait
   Dec Application.Busy
   Return Replace(stem, "printl.tmp", "printl.tmp.pdf")
   
End

Public Sub Print_latex(latex As String, Optional printertype As Integer = const.Paper_Plain, number_copies As Integer = 1)
   '----------------------------------------------
   'prints a laTeX file up to number_copies copies
   '----------------------------------------------
   
   Dim stem As String
   Dim f As File
   Dim cmd As String
   Dim coll As Collection
   
   stem = Temp$("printl")
   f = Open stem & ".tex" For Write Create
   Print #f, latex
   Close #f
   cmd = modUtil.FindProgram("latex", "texlive-latex-base")
   If IsNull(cmd) Then Return
   Inc Application.Busy
   cmd = "cd `dirname " & stem & "` ; " & cmd 
   cmd &= " \\\\nonstopmode\\\\input printl.tmp.tex ; "
   'cmd &= "dvips printl.tmp.dvi -o"
   'cmd &= Subst$(" '!lpr &1 -# &2'", GetLprOption(printertype), number_copies)
   coll = GetOption(printertype)
   cmd &= Subst$("dvips printl.tmp.dvi &1 -o", coll!dvips)
   cmd &= Subst$(" '!lpr &1 -# &2'", coll!lpr, number_copies)
   Log.DebugMsg("Printing using command " & cmd)
   Shell cmd Wait
   Try Kill stem & ".tex"
   Try Kill stem & ".dvi"
   Try Kill stem & ".aux"
   Try Kill stem & ".log"
Finally
   Dec Application.Busy
Catch
   Message.Error(Error.Text, "OK")
   
End

Public Sub PrintHtml(sHtml As String, Optional printertype As Integer = const.Paper_Plain)
   '-----------------------------------------------------------------------------
   'prints some html to a printer as a pdf using wkhtmltopdf to do the conversion
   '-----------------------------------------------------------------------------
   
   Dim pro As Process
   Dim cmd As String
   Dim lpr As String
   
   If sHtml = "" Then Return
   cmd = modUtil.FindProgram("wkhtmltopdf", "wkhtmltopdf")
   If IsNull(cmd) Then Return
   lpr = modUtil.FindProgram("lpr", "cups")
   If IsNull(lpr) Then Return
   Inc Application.Busy
   'cmd = Subst$("&1 -q - - | &2 &3", cmd, lpr, GetLprOption(printertype))
   cmd = Subst$("&1 -q - - | &2 &3", cmd, lpr, GetOption(printertype)!lpr)
   Log.DebugMsg("HTML print command: " & cmd)
   pro = Shell cmd For Write
   Write #pro, sHtml
   
Finally
   Try Close #pro
   Dec Application.Busy
Catch
   Message.Error(Error.Text, "OK")
   
End

Public Function Write_HTML(sHTML As String, Optional prefix As String = "html") As String
   '----------------------------------------------------------------
   'expects some html, returns a temporary filename it is written to
   '----------------------------------------------------------------  
   
   Dim wFile As File
   Dim sFilename As String
   
   sFilename = Temp$(prefix) & ".html"
   wfile = Open sFilename For Write Create
   Print #wfile, sHTML
   Close #wfile
   Return sFilename
   
End

Public Function Make_PDF_From_Html(sHtml As String, Optional orientation As Integer = const.orientation_portrait, Optional cover_page As String = "", Optional bPrintTOC As Boolean = False, Optional output_filename As String = "any", Optional pb As ProgressBar = Null) As String 
   '--------------------------------------------------------
   'Makes a PDF file from some html and returns the filename
   '-------------------------------------------------------- 
   
   Dim section As String
   Dim shell_text As String 
   Dim progressbar_interval As Float
   Dim page_orientation As String
   Dim tempfile As String
   Dim pro As Process
   Dim cmd As String
   
   If orientation = const.orientation_landscape Then
      page_orientation = "landscape"
   Else
      page_orientation = "portrait"
   End If
   '----------------------------------------------------------------------------------------------------------
   'Construct the text to pass to the shell, first page orientation, toc, then headers, footers and coversheet
   '----------------------------------------------------------------------------------------------------------
   cmd = modUtil.FindProgram("wkhtmltopdf", "wkhtmltopdf")
   If IsNull(cmd) Then Return
   shell_text = cmd & " -O " & page_orientation 
   shell_text &= " --margin-bottom 15 --header-right 'Page [page]' --footer-center '- EasyGP Medical Records -' --footer-spacing 1 --footer-font-name 'comic sans ms' " 
   If cover_page <> "" Then
      shell_text &= " --cover " & Write_HTML(cover_page, "cover_page") & " "
   End If
   If Not IsNull(pb) Then 
      pb.value = pb.value + progressbar_interval
      Wait
   Endif
   shell_text &= Write_HTML(sHTML) & " " 
   shell_text &= "/tmp/" & output_filename
   '------------------------------------------------------------------------------------------------------------
   'This now looks like: wkhtmltopdf -O portrait ..flags.... file1.html .... /tmp/output_filename.pdf
   '------------------------------------------------------------------------------------------------------------
   Print shell_text   
   pro = Shell shell_text Wait For Write 
   Close #pro
   ' Shell "pdfjoin " & files_to_join & " --outfile " & output_filename Wait
   
   Try pb.value = 1.0                                        're-set progress bar if it exists
   Return "/tmp/" & output_filename   
   
End

Public Function Make_PDF_From_HTML_Pages(sections As Collection, Optional orientation As Integer = const.orientation_portrait, Optional cover_page As String = "", Optional bPrintTOC As Boolean = False, Optional output_filename As String = "any", Optional pb As ProgressBar) As String 
   '--------------------------------------------------------------------------------------------
   'takes a number of html pages and joins into single pdf using wkhtmltopdf-static (QT patched) 
   'if cover_page <> "" then it is the html for a coversheet
   'if bPrintTOC is true then print a table of contents
   '--------------------------------------------------------------------------------------------
   
   Dim section As String
   Dim shell_text As String 
   Dim progressbar_interval As Float
   Dim page_orientation As String
   Dim tempfile As String
   Dim pro As Process
   Dim cmd As String
   
   If orientation = const.orientation_landscape Then
      page_orientation = "landscape"
   Else
      page_orientation = "portrait"
   End If
   'FIXME - FIGURE OUT HOW TO MAKE PROGRESS BAR WORK
   progressbar_interval = 1 / (sections.Count + 1)
   
   '----------------------------------------------------------------------------------------------------------
   'Construct the text to pass to the shell, first page orientation, toc, then headers, footers and coversheet
   '----------------------------------------------------------------------------------------------------------
   cmd = modUtil.FindProgram("wkhtmltopdf", "wkhtmltopdf")
   If IsNull(cmd) Then Return
   shell_text = cmd & " -O " & page_orientation 
   If bPrintTOC Then shell_text &= " --toc --outline" 'FIXME LATER: the gambas component dosn 't seem to handle outlines/indexs
   shell_text &= " --margin-bottom 15 --header-right 'Page [page]' --footer-center '- EasyGP Medical Records -' --footer-spacing 1 --footer-font-name 'comic sans ms' " 
   If cover_page <> "" Then
      shell_text &= " --cover " & Write_HTML(cover_page, "cover_page") & " "
   End If
   '-----------------------------------------------------------------------------------
   'Now for each section we want to print, create a temporary file, chain them together
   '-----------------------------------------------------------------------------------
   Print shell_text   
   For Each section In sections 
      '  pb.value = pb.value + progressbar_interval
      '  Wait
      '  Endif
      If Not IsNull(section) Then
         If Not IsNull(pb) Then 
            pb.value = pb.value + progressbar_interval
            pb.Refresh()
            Wait  
         Endif
         shell_text &= Write_HTML(section, sections.key) & " " 
      Endif
   Next
   shell_text &= "/tmp/" & output_filename
   '------------------------------------------------------------------------------------------------------------
   'This now looks like: wkhtmltopdf -O portrait ..flags.... file1.html, file2.html.... /tmp/output_filename.pdf
   '------------------------------------------------------------------------------------------------------------
   
   pro = Shell shell_text Wait For Write 
   Close #pro
   pb.value = 1.0                                        're-set progress bar
   Return "/tmp/" & output_filename
   
End

Public Function Join_PDF(pdf_files As Collection, Optional output_filename As String = "") As String
   '-------------------------------------------
   'Joins any number of files into a single pdf
   '-------------------------------------------
   
   Dim files As String
   Dim files_to_join As String
   
   If output_filename = "" Then
      output_filename = Temp$()
   Else
      output_filename &= ".pdf"
   End If  
   For Each files In pdf_files
      files_to_join &= files & " "
   Next
   Shell "pdfjoin " & files_to_join & " --outfile " & output_filename Wait
   Return output_filename
   
End

Public Function Join_PDF_IAN(pdf_files As String[], Optional output_filename As String = "joined", metadata As Collection = Null) As String
   '-------------------------------------------
   'Joins any number of files into a single pdf
   '-------------------------------------------
   
   Dim f As String
   Dim stem As String
   Dim cmd As String
   Dim lf As File
   
   cmd = modUtil.FindProgram("pdflatex", "texlive-latex-base")
   If IsNull(cmd) Then Return
   
   stem = Left$(Temp$(output_filename), -4) ' strip .tmp from name
   lf = Open stem & ".tex" For Write Create
   Print #lf, "\\documentclass[a4paper]{article}"
   Print #lf, "\\usepackage{pdfpages}"
   If Not IsNull(metadata) Then
      Print #lf, "\\pdfinfo{"
      For Each f In metadata
         ' this is actually raw PostScript
         Print #lf, Subst$("/&1 (&2)", metadata.Key, f)
      Next
      Print #lf, "}"
   Endif
   Print #lf, "\\begin{document}"
   For Each f In pdf_files
      Print #lf, Subst$("\\includepdf[pages=-]{&1}", f)
   Next
   Print #lf, "\\end{document}"
   Close #lf
   cmd = Subst$("cd `dirname &1` ; &2 &1.tex; rm *.aux *.log *.tex", stem, cmd)
   Shell cmd Wait
   Return stem & ".pdf"
   
End

Public Sub Split_PDF(pdf_file As String)
   '-------------------------------------------
   'Splits a PDF into single page pdfs
   ' pdf-file must be a full path
   ' new files are created in the same directory
   ' where foo.pdf, foo-1.pdf, foo-2,pdf, foo-3.pdf etc are created
   '-------------------------------------------
   
   Dim stem As String
   Dim cmd As String
   Dim pdflatex As String
   Dim lf As File
   Dim cmd_result As String
   Dim page As Integer = 1
   Dim status As Integer
   
   pdflatex = modUtil.FindProgram("pdflatex", "texlive-latex-base")
   If IsNull(pdflatex) Then Return
   If Right$(pdf_file, 4) = ".pdf" Then
      stem = Left$(pdf_file, -4) ' strip .pdf from name
   Else
      stem = pdf_file
   Endif
   Do
      lf = Open stem & "-" & Str$(page) & ".tex" For Write Create
      Print #lf, "\\documentclass[a4paper]{article}"
      Print #lf, "\\usepackage{pdfpages}"
      Print #lf, "\\begin{document}"
      Print #lf, Subst$("\\includepdf[pages=&1]{&2}", Str$(page), pdf_file)
      Print #lf, "\\end{document}"
      Close #lf
      cmd = "cd `dirname " & stem & "` ; " & pdflatex
      cmd &= " -interaction=nonstopmode " & stem & "-" & Str$(page) & ".tex"
      Shell cmd To cmd_result
      status = 2 ' error unless proved otherwise
      If InStr(cmd_result, "required page does not exist") Then
         status = 1 ' ran out of files so stop gracefully
      Else If Access(stem & "-" & Str(Page) & ".pdf") Then
         status = 0 ' generated a file, so keep going
      Endif
      Try Kill stem & "-" & Str(page) & ".tex"
      Try Kill stem & "-" & Str(page) & ".aux"
      Try Kill stem & "-" & Str(page) & ".log"
      Inc page
   Loop Until status > 0
   If status = 2 Then
      Log.ErrorMsg("pdfLaTeX error: " & cmd_result)
      Error.Raise("pdfLateX failed: check the log")
   Endif
   
End

Public Function Printers_Load() As String[]
   '--------------------------------------------------
   'Gets names of all available printers for this host
   'i.e assuming cups is started FIXME add error msg
   'then add these printer names to a temporary file
   '--------------------------------------------------
   
   Dim strs As String[]
   Dim i As Integer
   Dim sLineInput As String
   Dim pro As Process
   Dim cmd As String
   
   printerlist = New String[]
   cmd = modUtil.FindProgram("lpstat", "cups")
   If IsNull(cmd) Then Return printerlist 
   pro = Exec [cmd, "-v"] For Read
   '--------------------------------------------
   'Now open that file and populate the array
   'lpstat -v gives device for Printername: path
   'don't include temporary printer devices
   '-------------------------------------------- 
   While Not Eof(pro)                                   
      Line Input #pro, sLineInput
      If InStr(sLineInput, "tmp") Then Continue
      sLineInput = Replace(sLineInput, "device for ", "")
      i = InStr(sLineInput, ": ")
      If i = 0 Then Continue
      printerlist.Add(Left$(sLineInput, i - 1))
   Wend
   'Close #pro
   pro.Wait()
   Return printerlist
   
End

Public Function NoPrinters() As Boolean
   ' returns true if we can't print due to lack of printers
   
   Return printerlist.Count = 0
   
End

Private Function GetLprOption(printertype As Integer) As String
   'put back in temporarily to get me functional again
   'till ian fixes somes bugs
   
   Dim config_printer As String
   Dim printername As String
   Dim printer_options As String
   Dim i As String
   
   config_printer = "Default"
   Try config_printer = FMain.GetSelectedPrinter()
   If config_printer = "" Then config_printer = "Default"
   If config_printer <> "Default" Then
      FMain.ResetPrinters()
      Return Subst$("-P &1", config_printer)
   Endif
   Select Case printertype
      Case const.Paper_Script
         printername = "script"
      Case const.Paper_Plain
         printername = "plain"
      Case const.Paper_Request
         printername = "request"
      Case const.Paper_Long
         printername = "long"
   End Select
   config_printer = Settings[Subst$("Printers/&1", printername), "Default"]
   printer_options = Settings[Subst$("Printers/&1_options", printername), "Default"]
   If config_printer = "Default" Then
      config_printer = ""
   Else
      config_printer = Subst$("-P &1", config_printer)
   Endif
   If printer_options <> "Default" Then
      config_printer &= " " & printer_options
   Endif
   Return config_printer
   
End

Private Function GetOption(printertype As Integer) As Collection
   
   Dim config_printer As String
   Dim printername As String
   Dim coll As New Collection
   Dim printer_options As String
   
   Dim i As String
   
   config_printer = "Default"
   Try config_printer = FMain.GetSelectedPrinter()
   If config_printer = "" Then config_printer = "Default"
   If config_printer <> "Default" Then
      FMain.ResetPrinters()
      Return Subst$("-P &1", config_printer)
   Endif
   Select Case printertype
      Case const.Paper_Script
         printername = "script"
      Case const.Paper_Plain
         printername = "plain"
      Case const.Paper_Request
         printername = "request"
      Case const.Paper_Long
         printername = "long"
   End Select
   config_printer = Settings[Subst$("Printers/&1", printername), "Default"]
   printer_options = Settings[Subst$("Printers/&1_options", printername), "Default"]
   If printer_options <> "Default" Then
      coll = SplitOptions(printer_options)
   Endif
   If config_printer <> "Default" Then
      coll!lpr &= Subst$(" -P &1", config_printer)
   Endif
   Return coll
   
End

Public Function SplitOptions(opts As String) As Collection
   
   ' splits options string into dvips and lpr options strings
   
   Dim res As String[] = ["-O \\S+", "-T \\S+"]
   Dim i As String
   Dim re As Regexp
   Dim dvips_opts As String
   Dim lpr_opts As String
   
   dvips_opts = ""
   For Each i In res
      If opts = "" Then Break 
      re = New Regexp(opts, i)
      If re.Offset > -1 Then
         dvips_opts &= " " & re.Text
         opts = Left$(opts, re.Offset) & Right$(opts, Len(opts) - (re.Offset + Len(re.Text)))
      End If
   Next
   
   Return ["lpr": opts, "dvips": dvips_opts] 
   
End

Public Sub UnitTest(form_main As FMain)
   
   Print_latex(File.Load("templates/testpage.tex"), const.Paper_Plain)
   
End
