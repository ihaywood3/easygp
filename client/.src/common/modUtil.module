' Gambas module file
' Copyright (C) 2008,2009 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'
' PURPOSE: A module to assist in validation of input areas with key restriction
'-------------------------------------------------------------------------------
Private bValidKey As Boolean 

Public Sub filepath_fix_Blanks(filepath As String) As String
 
       filepath = Replace(filepath, " ", "\\ ")
       Return filepath

End


Public Function Make_Plural(txt As String) As String
   '-------------------------------------------------
   'Makes a word plural, not real smart
   'FIXME to take into account returning proper case
   '------------------------------------------------
  
   Dim Lastchar As String
   
   Lastchar = (Right$(txt))
  
   If Lower(Lastchar) = "y" Then 
      Lastchar = Replace(Lastchar, Lastchar, "ies")
   Else
      lastchar = Replace(lastchar, Lastchar, lastchar & "'s")
   Endif
   Return Left(txt, Len(txt) - 1) & lastchar
End


Public Function Ucase_Word(txt As String) As String
  
  Return UCase(Left(txt)) & Right(txt, Len(txt) - 1)
  
End


Public Function Calc_age(dob As Date) As Integer
  
  Return DateDiff(dob, Now, gb.Year)
  
End

Public Function Write_HTML(sHTML As String, Optional prefix As String = "html") As String
   '----------------------------------------------------------------
   'expects some html, returns a temporary filename it is written to
   'IAN BEFORE REMOVING THIS AGAIN CAN YOU MAKE SURE THE ROUTINES
   'CALLING IT HAVE ANOTHER WAY OF WORKING OR TELL ME WHAT YOU
   'WANT AND i'LL TRY AND IMPLEMENT IT
   '----------------------------------------------------------------  
  Dim wFile As File
  Dim sFilename As String
  
  sFilename = Temp$(prefix) & ".html"
  wfile = Open sFilename For Write Create
  Print #wfile, sHTML
  Close #wfile
  Return sFilename
End

Public Function Convert_rtf_to_html(sHtml As String) As String
 '-------------------------------------------------------------------------------
 'converts a medrec *.rtf letter to html sort of
 'returns string of formatted html text
 '
 'sample letter format:
 ' {\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss Small Fonts;}{\f3\froman Times New Roman;}{\f4\froman Times New Roman;}{\f5\fscript Comic Sans MS;}}
 ' {\colortbl\red0\green0\blue0;}
 ' \deflang1033\pard\plain\f4\fs24 A Practice
 ' \par 141 Peter Close
 ' \par ANYTOWN 9999
 ' \par Phone:02 48 999999
 ' \par Fax  :02 49 11111
 ' \par Email:
 ' \par 
 ' \par 19/11/2001
 ' \par 
 ' \par Dr Whoever
 ' \par Unit1
 ' \par 199 Whatever ST
 ' \par BROADMEADOW 2292
 ' \par 42222222
 ' \par 
 ' \par Dear Lindsay,
 ' \par Re: A Patient An Address  KAHIBAH 2290 DOB: 22/01/1922 Age:73.6
 ' \par 
 ' \par TYPE OF REFERRAL: ONGOING MANAGEMENT
 ' \par 
 ' \par Merle is troubled by her left knee osteoarthritis and would like to discuss of replacement with you.
 ' \par 
 ' \par Allergies: Reversible Inhibitors Of Monoamine Oxidase Type A - reaction allergic rash noted with the drug Aurorix [DEFINATE], Penicillin - reaction diarrhoea noted with the drug Abbocillin VK [DEFINATE].
 ' \par 
 ' \par 
 ' \par Yours sincerely,
 ' \par 
 ' \par 
 ' \par 
 ' \par Dr Bruce Blogs(Prov No.:111111A)\plain\f3\fs24 
 ' \par }
 '
 ' Ian would probably do this in a one liner, but for my simple brain
 'I inserted a couple of pipes to split the text, took out the letter
 'and replace the paragraph returns with <BR>
 '-------------------------------------------------------------------------
  Dim bits As String[]
  Dim charpos As Integer
  Dim badcount As Integer
  '------------------------------------------------------------------
  'Some letters seem to have been re-saved in word which has altered
  'the simple rtf file headers I constructed in VB, so replace these
  'out of 11,000 letters, was only in the order of 20 or so, and these
  'also had 'par }}' at the end of the letter
  '------------------------------------------------------------------
  charpos = InStr(shtml, "cgrid0")
  
  If charpos Then
     sHtml = "{sometext here\\fs24" & Right(shtml, Len(shtml) - charpos - 5)
     sHtml = Replace(shtml, "\\par }}", "\\par }")
    ' Message.info(shtml)
    Inc badcount
  End If
 '-----------------------------------------------------
 'There appears some variation at the end of the letter
 'to be removed IAN FIX ME
 '-----------------------------------------------------
  sHtml = Replace(sHtml, "\\plain\\f2\\fs24", "|")
  sHtml = Replace(sHtml, "\\plain\\f3\\fs24", "|")
  sHtml = Replace(sHtml, "\\plain\\f4\\fs24", "|")
  sHtml = Replace(sHtml, "\\plain\\f5\\fs24", "|")
  sHtml = Replace(sHtml, "\\plain\\f6\\fs24", "|")
  sHtml = Replace(sHtml, "\\plain\\f7\\fs24", "|")
  sHtml = Replace(sHtml, "\\plain\\f8\\fs24", "|")
  sHtml = Replace(sHtml, "\\plain\\f5\\fs10\\cf0", "|")
  sHtml = Replace(sHtml, "\\plain\\f5\\fs18\\cf0", "|")
  '----------------------------------------------------
  'Replace the last par } at end of the letter and
  'then the fs24 just before the practice name
  'Now we can split on the | character and take seg 1
  '----------------------------------------------------
  sHtml = Replace(sHtml, "\\par }", "|")
  sHtml = Replace(sHtml, "\\fs24 ", "|")
  bits = Split(sHtml, "|", "", True)
  sHtml = Trim(sHtml)
  '-----------------------------------------
  'Convert paragraph returns to <BR> in html
  '-----------------------------------------
  sHtml = Replace(bits[1], "\\par", "<BR>")
 ' If charpos Then Message.info(shtml)
 'Just in case we missed an odd one
  If InStr(sHtml, "\\plain") Then
      Message.info(sHtml)
  End If
 ' If Right(sHtml, 1) <> ")" Then
  '    Print Right(Trim(sHtml), 10)
  '    Print Right(Trim(sHTML), 1), "= the last char"
  '    Message.info(sHtml)
  'End If
  
  Return sHtml
End


Public Function File_IO_Describe_Error(error_code As Integer) As String
   Dim sMsg As String
   Select Case error_code
         
         Case const.File_IOError_Out_of_memory 
               smsg = "Unable to open the file - out of memory"
         Case const.File_IOError_Access_Forbidden 
               sMsg = "The file could not be accessed, please check you have the appropriate file permissions"
         Case const.File_IOError_File_is_directory 
               sMsg = "The file you have attempted to open is a directory"
         Case const.File_IOError_File_Non_Existant 
               sMsg = "The file could not be found. Please check the name and path and try again"
         Case const.File_IOError_Device_Full 
               sMsg = "The disk you are trying to write to is full. To continue you should probably clean up your disk"
         Case const.File_IOError_System_Error
               sMsg = "Unkown system error"
   End Select
   Return sMsg
End
Public Sub NotImplemented(sFeature As String)
  
   Message.Info(sFeature & "\n\nThis feature is not implemented yet")
  
End

Public Function WebBrowserZoom(mode As String, current_zoom As Integer) As Integer
  
  Select Case mode
  Case "zoom in"
      Return Round(current_zoom * 1.25, -2)
  Case "zoom out"
       Return Round(current_zoom / 1.25, -2)
  End Select

  
End




Public Function COct(num As Integer) As String
  Dim octnumber As New Integer[]
  Dim octstring As String

  octnumber.Add(Int(num / 64))
  octnumber.Add(Int((num Mod 64) / 8))
  octnumber.Add((num Mod 64) Mod 8)
  octstring = octnumber[0] & octnumber[1] & octnumber[2]
  Return octstring
End

Public Function SplitStrings_into_collection(sstring As String, delimiter As String, Optional key_name As String) As Collection
   '----------------------------------------------------------------------------
   'Splits a line of delimited text into individual elements > into a collection
   '----------------------------------------------------------------------------
   Dim the_array As String[]
   Dim element As String 
   Dim C As New Collection
   the_array = Split(sString, delimiter)
   For Each element In the_array
      C.Add(element, C.count)
   Next
   Return C
End

Public Function columnSizes_Set(colsizes As String, cvw As Columnview)
   '-----------------------------------------------------------------
   'PURPOSE    helper for Settings_Load() from any form needing
   '           to set user-defined column sizes
   '-----------------------------------------------------------------
   Dim x As Integer
   Dim cols As String[]
   
   If colsizes = "" Then Return
   cols = Split(colsizes, "|")
   cvw.Columns.count = cols.Count
   For x = 0 To cvw.Columns.count - 1
       If cols.count > x Then
         cvw.Columns[x].width = Val(cols[x])
       Endif
   Next
End

Public Function Columnsizes_To_String(cvw As ColumnView) As String
   '---------------------------------------------------------------------------------------
   'PURPOSE    reads the column sizes of a columnview, concatenates to '|' delimited string
   '           used by any columnview which wants to save its sizes back to settings file
   '----------------------------------------------------------------------------------------
   Dim x As Integer
   Dim colsize As String
   For x = 0 To cvw.Columns.Count - 1
    colsize &= Str$(cvw.Columns[x].width) & "|"
   Next
   colsize = Left(colsize, Len(colsize) - 1) 'trim off unwanted pipe character
   Return colsize 
End 

Public Function AllowKeys(Restriction As Integer, keyascii As Integer) As Boolean
  '--------------------------------------------------------------------------------------
  'Restricts key entry in textboxes, excluding <return><backspace><leftarrow><rightarrow>
  'const.AllowKeys_NumbersOnly  0-9
  'const.AllowKeys_Letters upper or lower case a-z
  'const.AllowKeys_DateFormat dd/mm/yyyy as numbers or a '/' character
  'RETURNS true if key is valid
  '--------------------------------------------------------------------------------------
  bValidKey = False
  Select Case Restriction
  Case const.AllowKeys_InputMask
           If (keyascii = Asc("/") Or keyascii = Asc(":") Or keyascii = Asc(".") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
                  bValidKey = True
          End If
  Case const.AllowKeys_NumbersDecimal  
          If (keyascii = Asc(".") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then 
                  bValidKey = True
          End If

  Case const.AllowKeys_NumbersOnly  
          If (keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
                  bValidKey = True
          End If
   Case const.AllowKeys_Numbers_D_M_Y
        If keyascii = Asc("M") Or keyascii = Asc("m") Or keyascii = Asc("Y") Or keyascii = Asc("y") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (KeyAscii = 8 Or KeyAscii = 13 Or (KeyAscii > 47 And KeyAscii < 59)) Then
            bValidKey = True
        End If
  Case const.AllowKeys_AtoZ
           If keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123)) Then
                 bValidKey = True
            End If
     
  Case const.AllowKeys_Letters 'abc etc and the apostrophe ' and ? and * and -
          If keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 42) Or (KeyAscii = 45) Or (KeyAscii = 63) Or (KeyAscii = 39) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123) Or (KeyAscii = 8) Or (KeyAscii = 59)) Then
                 bValidKey = True
            End If
   Case const.AllowKeys_DateFormat 'allow on eg mm/dd/yyyy or mm.dd.yyyy or mm-dd-yyyy but Replace .. -- with /
        If keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (KeyAscii = 8 Or KeyAscii = 13 Or (KeyAscii > 46 And KeyAscii < 59)) Then
            bValidKey = True
        End If
   Case const.AllowKeys_Date_DWMY
  ' Case const.AllowKeys_DateRecalls 'special format for recalls, date characters + 'Mm' or 'Yy" to allow typeing 3Y (= Now + 3ys)
    If keyascii = Asc("D") Or keyascii = Asc("d") Or keyascii = Asc("W") Or keyascii = Asc("w") Or keyascii = Asc("M") Or keyascii = Asc("m") Or keyascii = Asc("Y") Or keyascii = Asc("y") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (KeyAscii = 8 Or KeyAscii = 13 Or (KeyAscii > 46 And KeyAscii < 59)) Then
            bValidKey = True
        End If

  End Select
  Return bValidKey
End 


Public Function DateString_Encode(datestring As String) As String
   'turns eg 01/02/2010 into '20100201'
    Dim bits As String[]
    If datestring <> "" Then 
      bits = Split(datestring, "/")
      Return bits[2] & bits[1] & bits[0]
    Else
      Return
    End If  
    
  
End

Public Function DateString_Decode(Datestring As String) As Date
  Dim sTemp As String
  Dim d1 As Date
  
  d1 = Null
  sTemp = Left(Datestring, 8)
  Try d1 = Date(Val(Left(sTemp, 4)), Val(Mid(sTemp, 5, 2)), Val(Right(sTemp, 2)))
  Return d1
End

Public Function Copy_Collection(cSource As Collection) As Collection 
   Dim vVal As Variant
   Dim cDestination As New Collection 
   
   For Each vVal In cSource
     cDestination[cSource.Key] = vVal
   Next
   Return cDestination
End

Public Function Copy_Collection_Keyed_Sequentially(cSource As Collection) As Collection 
   'copies a collection key'ed 0,1,2,3... etc
   'This dosn't really work, it just points to the same bits as the source?? why FIX ME
   Dim vVal As Variant
   Dim NewVal As Variant
   Dim x As Integer
   Dim cDestination As New Collection 
   For Each vVal In cSource
      newVal = vVal
     cDestination[x] = NewVal
     Inc x
   Next
   Return cDestination
End

' Public Function Name_Construct(pers As cPerson) As String
'    '----------------------
'    'Makes e.g Dr Joe Blogs
'    'FIXME to have the option of full name or initial
'    '----------------------
'    Dim aName As String
'    aName = pers.Title & " " & Left(pers.Firstname, 1) & " " & pers.Surname
'    Return aName
'  End   
'  



Public Function Format_Date(d As Date) As String
  '--------------------------------------------
  'Expects a date and returns a formatted string
  '---------------------------------------------
  Try Return Format(d, "dd/mm/yyyy")
  If Error Then Return "date-error-occurred"
  
End


Public Function LoadCombo(combo As ComboBox, data As Collection, display_field As String) As Collection
   '-------------------------------------------------------------------------------
   'Note the combo must be cleared by the calling routine, as sometimes we may want
   'to add data not retrieved from the data collection
   '-------------------------------------------------------------------------------  
  Dim i As Integer
  Dim j As Collection
  Dim c As New Collection
  combo.Clear()
  i = 0
  For Each j In data
      combo.Add(data[data.key][display_field])
      c.Add(j, i)
      Inc i
  Next
  Return c
End


Public Function Change_Fonts(F As Font) As Font

  Dialog.font = F
  If Dialog.SelectFont() Then Return 
  Return Dialog.Font   
End


Public Function Screenshot_Grab(Ctrl As Control, Optional h As Integer, Optional w As Integer) As String
   
   '---------------------------------------------------------------
   'Grabs a screenshot of a control, saves to a temp file
   'returns some html for the notes
   'fixme this dosn't work
   '---------------------------------------------------------------
   Dim tempfile As String 
   Dim I As New Image
   Dim P As New Picture
   Dim sPicPath As String 
   
   Tempfile = Temp() & ".png" 
   P = Ctrl.Screenshot()
  
   P.Save(Tempfile)  'save the picture to the disk
   If Not h Then h = P.h
   If Not w Then w = P.w
      
   sPicPath = "<TABLE WIDTH=100%><TR><TD WIDTH=100%><P><IMG src=" & tempfile & " " 
   sPicPath &= " NAME=graphics ALIGN=LEFT WIDTH=" & Str(w) & " HEIGHT=" & Str(h) & " BORDER=0></TR></TD></TABLE><BR><BR>"  '<BR CLEAR=Left>

   Return sPicPath
' 
End


Public Function CapsLockStatus() As Boolean
  Dim res As String
  
  ' xset q = xset query returns report about X console, then use awk to parse out the hex digit we want
  Try Shell "xset q | awk '/.*LED mask.*/ { print and(1,strtonum(\"0x\" substr($10,8,1))) }'" To res
  If Error Then Return False
  res = Trim$(res)
  If res = "1" Then
    Return True
  Else
    Return False
  Endif
  
End

Public Sub ReportError(errtxt As String, bt As String[])
  ' reports as error, usually used at the end of the 
  ' function like:
  ' Catch
  '   modUtil.ReportError(Error.Text, Error.Backtrace)
  ' End   
  Dim frm_error As FError 
  Dim i As String
  
  Log.ErrorMsg(errtxt)
  For Each i In bt
    Log.ErrorMsg(i)
  Next
  
  frm_error = New FError
  frm_error.SetMessage(errtxt)
  frm_error.ShowModal()

End

Public Function FindProgram(prg As String, package As String) As String
  
  ' checks that an executable is available on the system
  ' prg: the name of the program
  ' package: the name of the Debian/RedHat package, only used to
  ' create a more helpful error message
  ' returns
  '   - NULL if the program isn't found on the system. Calling
  '      code should just exit directly, there is no need to have an
  '      error message as the function does this for you
  '   - if found the full path of the program which can be used for 
  '     Shell or Exec commands
  
  If Not IsNull(Settings["Paths/" & prg]) Then Return Settings["Paths/" & prg]
  If Access("/usr/bin" &/ prg, gb.Exec) Then Return "/usr/bin/" & prg
  If Access("/usr/local/bin" &/ prg, gb.Exec) Then Return "/usr/local/bin" &/ prg
  Message.Error(Subst$("Cannot find program &1. try installing package &2 on your system", prg, package))
  Log.ErrorMsg(Subst$("&1 not found anywhere", prg))
  Return Null
End
