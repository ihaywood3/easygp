' Gambas module file

' Copyright (C) 2008-2013 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'
' PURPOSE: A module to assist in validation of input areas with key restriction
'-------------------------------------------------------------------------------

Private tempdir As String

Public Function As_Percent(num As Integer, data_count As Integer) As String

   Return Str(Round((num / data_count) * 100)) & "%"

End

' prepare a default value for Splitter.Layout
' values is an array of percentages of desktop width
Public Sub HSplit(values As Integer[]) As Integer[]

   Return Splitter_Defaults(values, Desktop.Width)

End

Public Sub Columnview_Columns_Set_Size(cvw As ColumnView, lblMeasure As Label)
   '---------------------------------------------------------
   'Due to gambas columns eradically auto-sizing, do the work
   '---------------------------------------------------------

   Dim col_widths As New Integer[cvw.Columns.count + 1]
   Dim col As Integer
   Dim row As Integer

   With lblMeasure
      .AutoResize = True
      .Expand = False
      .Visible = False
      .font = cvw.Font
   End With

   If Not cvw.count Then Return
   For row = 0 To cvw.Count - 1
      Print row
      For col = 0 To cvw.Columns.Count               'read each column row 0 to row nAdd(allergy!pk
         If cvw[row][col] <> "" Then
            lblMeasure.text = cvw[row][col]
            col_widths[col] = Max(col_widths[col], lblMeasure.width)
         End If
      Next
   Next
   For col = 0 To cvw.Columns.Count - 1
      cvw.Columns[col].Width = col_widths[col]
   Next

End

Public Sub Gridview_Columns_Set_Size(gvw As Gridview, lblMeasure As Label)
   '---------------------------------------------------------
   'Due to gambas columns eradically auto-sizing, do the work
   '---------------------------------------------------------

   Dim col_widths As New Integer[gvw.Columns.count + 1]
   Dim col As Integer
   Dim row As Integer

   With lblMeasure
      .AutoResize = True
      .Expand = False
      .Visible = False
      .font = gvw.Font
   End With

   If Not gvw.Rows.count Then Return
   For row = 0 To gvw.Rows.Count - 1
      For col = 0 To gvw.Columns.Count - 1              'read each column row 0 to row nAdd(allergy!pk
         If gvw[row, col].Text <> "" Then
            lblMeasure.text = gvw[row, col].Text
            col_widths[col] = Max(col_widths[col], lblMeasure.width)
         Else
            If Not IsNull(gvw[row, col].Picture) Then
               col_widths[col] = Max(col_widths[col], gvw[row, col].Picture.Width)
            Endif
         End If
      Next
   Next
   For col = 0 To gvw.Columns.Count - 1
      gvw.Columns[col].Width = col_widths[col]
   Next

End
' same for vertical splits using Desktop height.

Public Sub VSplit(values As Integer[]) As Integer[]

   Return Splitter_Defaults(values, Desktop.Height)

End

Public Sub text_gt_lt_protect(s As String) As String
   ' Replace(Replace(PH!aim_of_plan, "<", "&lt;"), ">", "&gt;") & ", " & Replace(PH!management_summary, "<", "&lt;") & "</P>"
   'protects the > and < eg bp<130/80 or bp>130/8 0

   Return Replace(Replace(s, "<", "&lt;"), ">", "&gt;")

End

Public Sub Splitter_Defaults(values As Integer[], sz As Integer) As Integer[]

   Dim ret As New Integer[]
   Dim i As Integer

   For Each i In values
      ret.Add(CInt(sz * i / 100))
   Next
   Return ret

End

Public Sub Calc_BMI(height As Variant, weight As Variant) As Variant
   '---------------------------------------------------------------------------------
   'fix me there are calc_BMI's all over the place
   ' eg  modDecision_Support.BMI_DecSupp
   '     modMeasurements.Calc_BMI
   'They all are different and do differnet things names don't represent what they do
   '---------------------------------------------------------------------------------

   Dim BMI As Float

   BMI = Format((weight / (height ^ 2)) * 10000, "##.#")
   ' BMI = Val(height) / ((height / 100) * (height / 100))
   Return BMI
   '    Return BMI = Val(Format(Str$(BMI), "##.#"))

End

Public Sub Calc_md5sum_File(filename As String) As String

   Dim md5Output As String

   Exec ["/usr/bin/md5sum", filename] To md5Output
   Return Left(md5Output, InStr(md5Output, " ") - 1)

End

Public Sub filepath_fix_Blanks(filepath As String) As String

   filepath = Replace(filepath, " ", "\\ ")
   Return filepath

End

Public Function Restore_Case(txt As String, lower_case As Boolean) As String

End

Public Function Filename_Protect(fname As String) As String
   'change the filename to remove characters that upset BASH or printing.
   'something odd here - has always lived in this module I think and disappeared recently

   Dim s As String = ""
   Dim i As Integer
   Dim a As Integer

   For i = 0 To Len(fname)
      a = String.Code(fname, i)
      If a = 32 Then s &= "_"
      If a = 38 Then s &= "_and_"
      If a = 40 Then s &= ""            '(
      If a = 41 Then s &= ""            ')
      If a = 39 Then s &= ""         'apostrophe eg O'Brien
      If a = 45 Then s &= "-"
      If a = 95 Then s &= "_"
      If a = 46 Then s &= "_"
      If a >= 48 And a <= 57 Then s &= Chr$(a) ' numbers
      If a >= 65 And a <= 90 Then s &= Chr$(a + 32) ' letters: to lowercase
      If a >= 97 And a <= 122 Then s &= Chr$(a) ' letters
   Next

   Return s

End

Public Function Make_Plural(txt As String) As String
   '-------------------------------------------------
   'Makes a word plural
   '------------------------------------------------

   Dim lastchar As String
   Dim lower_case As Boolean = False

   If txt = Lower(txt) Then
      lower_case = True
   Else
      txt = Lower(txt)
   Endif
   Select Case txt
      Case "child"
         txt = "children"
      Case "ox"
         txt = "oxen"
      Case "sheep"
         txt = "sheep"
      Case "deer"
         txt = "deer"
      Case "salmon"
         txt = "salmon"
      Case "fish"
         txt = "fish"
      Case "moose"
         txt = "moose"
      Case "goose"
         txt = "geese"
      Case "monkey"
         txt = "monkeys"
      Case "money"
         txt = "monies"
      Case "brother"
         txt = "brethren"
      Case "foot"
         txt = "feet"
      Case "louse"
         txt = "lice"
      Case "man"
         txt = "men"
      Case "mouse"
         txt = "mice"
      Case "tooth"
         txt = "teeth"
      Case "woman"
         txt = "women"
      Case "key"
         txt = "keys"
      Case Else
         Select Case Right$(txt)
            Case "y"
               txt = Left(txt, -1) & "ies"
            Case "f"
               txt = Left(txt, -1) & "ves"
            Case "s"
               txt &= "es"
            Case Else
               txt &= "s"
         End Select
   End Select

   If Not lower_case Then txt = Upper$(txt)

   Return txt

End

Public Function Ucase_Word_First_Letter(txt As String) As String

   Return UCase(Left(txt)) & Lower(Right(txt, Len(txt) - 1))

End

Public Function Calc_age(dob As Date) As Integer

   Dim months As Integer

   months = DateDiff(dob, Now, gb.Month)
   If Day(dob) > Day(Now) Then
      Dec months
   Endif
   Return months Div 12

End

Public Function Write_HTML(sHTML As String, Optional prefix As String = "html") As String
   '----------------------------------------------------------------
   'expects some html, returns a temporary filename it is written to
   'IAN BEFORE REMOVING THIS AGAIN CAN YOU MAKE SURE THE ROUTINES
   'CALLING IT HAVE ANOTHER WAY OF WORKING OR TELL ME WHAT YOU
   'WANT AND i'LL TRY AND IMPLEMENT IT
   '----------------------------------------------------------------

   Dim wFile As File
   Dim sFilename As String

   sFilename = Temp$(prefix) & ".html"
   wfile = Open sFilename For Write Create
   Print #wfile, sHTML
   Close #wfile
   Return sFilename

End

Public Function Convert_rtf_to_html(sHtml As String) As String
   '-------------------------------------------------------------------------------
   'converts a medrec *.rtf letter to html sort of
   'returns string of formatted html text
   '
   'sample letter format:
   ' {\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss Small Fonts;}{\f3\froman Times New Roman;}{\f4\froman Times New Roman;}{\f5\fscript Comic Sans MS;}}
   ' {\colortbl\red0\green0\blue0;}
   ' \deflang1033\pard\plain\f4\fs24 A Practice
   ' \par 141 Peter Close
   ' \par ANYTOWN 9999
   ' \par Phone:02 48 999999
   ' \par Fax  :02 49 11111
   ' \par Email:
   ' \par
   ' \par 19/11/2001
   ' \par
   ' \par Dr Whoever
   ' \par Unit1
   ' \par 199 Whatever ST
   ' \par BROADMEADOW 2292
   ' \par 42222222
   ' \par
   ' \par Dear Lindsay,
   ' \par Re: A Patient An Address  KAHIBAH 2290 DOB: 22/01/1922 Age:73.6
   ' \par
   ' \par TYPE OF REFERRAL: ONGOING MANAGEMENT
   ' \par
   ' \par Merle is troubled by her left knee osteoarthritis and would like to discuss of replacement with you.
   ' \par
   ' \par Allergies: Reversible Inhibitors Of Monoamine Oxidase Type A - reaction allergic rash noted with the drug Aurorix [DEFINATE], Penicillin - reaction diarrhoea noted with the drug Abbocillin VK [DEFINATE].
   ' \par
   ' \par
   ' \par Yours sincerely,
   ' \par
   ' \par
   ' \par
   ' \par Dr Bruce Blogs(Prov No.:111111A)\plain\f3\fs24
   ' \par }
   '
   ' Ian would probably do this in a one liner, but for my simple brain
   'I inserted a couple of pipes to split the text, took out the letter
   'and replace the paragraph returns with <BR>
   '-------------------------------------------------------------------------

   Dim bits As String[]
   Dim charpos As Integer
   Dim badcount As Integer
   '------------------------------------------------------------------
   'Some letters seem to have been re-saved in word which has altered
   'the simple rtf file headers I constructed in VB, so replace these
   'out of 11,000 letters, was only in the order of 20 or so, and these
   'also had 'par }}' at the end of the letter
   '------------------------------------------------------------------
   charpos = InStr(shtml, "cgrid0")

   If charpos Then
      sHtml = "{sometext here\\fs24" & Right(shtml, Len(shtml) - charpos - 5)
      sHtml = Replace(shtml, "\\par }}", "\\par }")
      ' Message.info(shtml)
      Inc badcount
   End If
   '-----------------------------------------------------
   'There appears some variation at the end of the letter
   'to be removed IAN FIX ME
   '-----------------------------------------------------
   sHtml = Replace(sHtml, "\\plain\\f2\\fs24", "|")
   sHtml = Replace(sHtml, "\\plain\\f3\\fs24", "|")
   sHtml = Replace(sHtml, "\\plain\\f4\\fs24", "|")
   sHtml = Replace(sHtml, "\\plain\\f5\\fs24", "|")
   sHtml = Replace(sHtml, "\\plain\\f6\\fs24", "|")
   sHtml = Replace(sHtml, "\\plain\\f7\\fs24", "|")
   sHtml = Replace(sHtml, "\\plain\\f8\\fs24", "|")
   sHtml = Replace(sHtml, "\\plain\\f5\\fs10\\cf0", "|")
   sHtml = Replace(sHtml, "\\plain\\f5\\fs18\\cf0", "|")
   '----------------------------------------------------
   'Replace the last par } at end of the letter and
   'then the fs24 just before the practice name
   'Now we can split on the | character and take seg 1
   '----------------------------------------------------
   sHtml = Replace(sHtml, "\\par }", "|")
   sHtml = Replace(sHtml, "\\fs24 ", "|")
   bits = Split(sHtml, "|", "", True)
   sHtml = Trim(sHtml)
   '-----------------------------------------
   'Convert paragraph returns to <BR> in html
   '-----------------------------------------
   sHtml = Replace(bits[1], "\\par", "<BR>")
   ' If charpos Then Message.info(shtml)
   'Just in case we missed an odd one
   If InStr(sHtml, "\\plain") Then
      Message.info(sHtml)
   End If
   ' If Right(sHtml, 1) <> ")" Then
   '    Message.info(sHtml)
   'End If

   Return sHtml

End

Public Function File_IO_Describe_Error(error_code As Integer) As String

   Dim sMsg As String

   Select Case error_code

      Case const.File_IOError_Out_of_memory
         smsg = "Unable to open the file - out of memory"
      Case const.File_IOError_Access_Forbidden
         sMsg = "The file could not be accessed, please check you have the appropriate file permissions"
      Case const.File_IOError_File_is_directory
         sMsg = "The file you have attempted to open is a directory"
      Case const.File_IOError_File_Non_Existant
         sMsg = "The file could not be found. Please check the name and path and try again"
      Case const.File_IOError_Device_Full
         sMsg = "The disk you are trying to write to is full. To continue you should probably clean up your disk"
      Case const.File_IOError_System_Error
         sMsg = "Unkown system error"
   End Select
   Return sMsg

End

Public Sub NotImplemented(sFeature As String, Optional title As String)

   If title <> "" Then
      Message.Title = title
   Endif
   Message.Info(sFeature & "\n\nThis feature is not implemented yet")

End

Public Function WebBrowserZoom(mode As String, current_zoom As Integer) As Integer

   Select Case mode
      Case "zoom in"
         Return Round(current_zoom * 1.25, -2)
      Case "zoom out"
         Return Round(current_zoom / 1.25, -2)
   End Select

End

Public Function COct(num As Integer) As String

   Dim octnumber As New Integer[]
   Dim octstring As String

   octnumber.Add(Int(num / 64))
   octnumber.Add(Int((num Mod 64) / 8))
   octnumber.Add((num Mod 64) Mod 8)
   octstring = octnumber[0] & octnumber[1] & octnumber[2]
   Return octstring

End

Public Function SplitStrings_into_collection(sstring As String, delimiter As String, Optional key_name As String) As Collection
   '----------------------------------------------------------------------------
   'Splits a line of delimited text into individual elements > into a collection
   '----------------------------------------------------------------------------

   Dim the_array As String[]
   Dim element As String
   Dim C As New Collection

   the_array = Split(sString, delimiter)
   For Each element In the_array
      C.Add(element, C.count)
   Next
   Return C

End

Public Function columnSizes_Set(colsizes As String, cvw As Columnview)
   '-----------------------------------------------------------------
   'PURPOSE    helper for Settings_Load() from any form needing
   '           to set user-defined column sizes
   '-----------------------------------------------------------------

   Dim x As Integer
   Dim cols As String[]

   If Not InStr(colsizes, "|") Then Return
   cols = Split(colsizes, "|")
   cvw.Columns.count = cols.Count
   For x = 0 To cvw.Columns.count - 1
      If cols.count > x Then
         cvw.Columns[x].width = Val(cols[x])
      Endif
   Next

End

Public Function Columnsizes_To_String(cvw As ColumnView) As String
   '---------------------------------------------------------------------------------------
   'PURPOSE    reads the column sizes of a columnview, concatenates to '|' delimited string
   '           used by any columnview which wants to save its sizes back to settings file
   '----------------------------------------------------------------------------------------

   Dim x As Integer
   Dim colsize As String

   For x = 0 To cvw.Columns.Count - 1
      colsize &= Str$(cvw.Columns[x].width) & "|"
   Next
   colsize = Left(colsize, Len(colsize) - 1) 'trim off unwanted pipe character
   Return colsize

End

Public Function AllowKeys(Restriction As Integer, keyascii As Integer) As Boolean
   '--------------------------------------------------------------------------------------
   'Restricts key entry in textboxes, excluding <return><backspace><leftarrow><rightarrow>
   'const.AllowKeys_NumbersOnly  0-9
   'const.AllowKeys_Letters upper or lower case a-z
   'const.AllowKeys_DateFormat dd/mm/yyyy as numbers or a '/' character
   'RETURNS true if key is valid
   'I've also include F12 here, as this is the EasyGP global 'save' key press in FClinical
   '--------------------------------------------------------------------------------------

   Dim bValidKey As Boolean

   bValidKey = False
   Select Case Restriction
      Case const.AllowKeys_BP
         If (keyascii = Asc("/")) Or (keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
            bValidKey = True
         End If

      Case const.AllowKeys_InputMask
         If (keyascii = Asc("/") Or keyascii = Asc(":") Or keyascii = Asc(".") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_NumbersDecimal
         If (keyascii = Asc(".") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_money
         If (keyascii = Asc(".") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59) Or keyascii = Asc("$")) Then
            bValidKey = True
         End If
      Case const.AllowKeys_NumbersOnly
         If (keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_Numbers_D_M_Y
         If keyascii = Asc("M") Or keyascii = Asc("m") Or keyascii = Asc("Y") Or keyascii = Asc("y") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (KeyAscii = 8 Or KeyAscii = 13 Or (KeyAscii > 47 And KeyAscii < 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_Letters_Numbers_slash_apostrophe_dash 'FIX THIS WHOLE ROUTINE MUST BE A MORE INTELLIGENT WAY OF DOING IT
         If keyascii = Asc("-") Or keyascii = Asc("/") Or keyascii = Asc("'") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123)) Or (keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_Letters_Numbers_slash_dash_period
         If keyascii = Asc(".") Or keyascii = Asc("-") Or keyascii = Asc("/") Or keyascii = Asc(",") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123)) Or (keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
            bValidKey = True
         End If

      Case const.AllowKeys_Letters_Numbers
         If keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123)) Or (keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (keyascii > 47 And keyascii < 59)) Then
            bValidKey = True
         End If

      Case const.AllowKeys_Letters
         If keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_AtoZ_UpDown_Arrows 'a-z plus arrow keys, used in grid validation eg FDayList
         If keyascii = key.up Or keyascii = key.down Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123)) Then
            bValidKey = True
         End If

      Case const.AllowKeys_Letters 'abc etc and the apostrophe ' and ? and * and -
         If keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or ((KeyAscii > 64 And KeyAscii < 91) Or (KeyAscii = 42) Or (KeyAscii = 45) Or (KeyAscii = 63) Or (KeyAscii = 39) Or (KeyAscii = 32) Or (KeyAscii = 13) Or (KeyAscii > 96 And KeyAscii < 123) Or (KeyAscii = 8) Or (KeyAscii = 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_DateFormat 'allow on eg mm/dd/yyyy or mm.dd.yyyy or mm-dd-yyyy but Replace .. -- with /
         If keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (KeyAscii = 8 Or KeyAscii = 13 Or (KeyAscii > 46 And KeyAscii < 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_Date_DWMY
         ' Case const.AllowKeys_DateRecalls 'special format for recalls, date characters + 'Mm' or 'Yy" to allow typeing 3Y (= Now + 3ys)
         If keyascii = Asc("D") Or keyascii = Asc("d") Or keyascii = Asc("W") Or keyascii = Asc("w") Or keyascii = Asc("M") Or keyascii = Asc("m") Or keyascii = Asc("Y") Or keyascii = Asc("y") Or keyascii = Key.Return Or keyascii = Key.BackSpace Or keyascii = Key.Delete Or keyascii = Key.Left Or keyascii = Key.Right Or (KeyAscii = 8 Or KeyAscii = 13 Or (KeyAscii > 46 And KeyAscii < 59)) Then
            bValidKey = True
         End If
      Case const.AllowKeys_SQLCrash
         If keyascii <> Asc("\\") Then
            bValidKey = True
         End If

   End Select
   Return bValidKey

End

Public Function DateString_Encode(datestring As String) As String
   'turns eg 01/02/2010 into '20100201'

   Dim bits As String[]

   If datestring <> "" Then
      bits = Split(datestring, "/")
      Return bits[2] & bits[1] & bits[0]
   Else
      Return
   End If

End

Public Function DateString_Decode(Datestring As String) As Date

   Dim sTemp As String
   Dim d1 As Date

   d1 = Null
   sTemp = Left(Datestring, 8)
   Try d1 = Date(Val(Left(sTemp, 4)), Val(Mid(sTemp, 5, 2)), Val(Right(sTemp, 2)))
   Return d1

End

Public Function Copy_Collection(cSource As Collection) As Collection

   Dim vVal As Variant
   Dim cDestination As New Collection

   For Each vVal In cSource
      cDestination.Add(vVal, cSource.Key)
   Next
   Return cDestination

End

' get one item from a collection
Public Function Get_One(coll As Collection) As Variant

   Dim i As Variant

   For Each i In coll
      Return i
   Next

End

Public Function Copy_Collection_Keyed_Sequentially(cSource As Collection) As Collection
   '-----------------------------------------------------------------------------------------------------
   'copies a collection key'ed 0,1,2,3... etc
   'Note syntax in calling routine must be for example:
   'StaffTypes = modUtil.Copy_Collection_Keyed_Sequentially(modAdminDBI.Staff_Types_Get())
   'This is mainly used in loading combo's so that retreiving the data can use the zero based combo index
   'e.g  staff_member!fk_lu_staff_type = StaffTypes[cmbStafftype.index]!pk
   '------------------------------------------------------------------------------------------------------

   Dim vVal As Variant
   Dim NewVal As Variant
   Dim x As Integer
   Dim cDestination As New Collection

   For Each vVal In cSource
      newVal = vVal
      cDestination[x] = NewVal
      Inc x
   Next
   Return cDestination

End

' Public Function Name_Construct(pers As cPerson) As String
'    '----------------------
'    'Makes e.g Dr Joe Blogs
'    'FIXME to have the option of full name or initial
'    '----------------------
'    Dim aName As String
'    aName = pers.Title & " " & Left(pers.Firstname, 1) & " " & pers.Surname
'    Return aName
'  End
'

Public Function Format_Date(d As Date) As String
   '--------------------------------------------
   'Expects a date and returns a formatted string
   '---------------------------------------------

   Try Return Format(d, "dd/mm/yyyy")
   If Error Then Return "date-error-occurred"

End

Public Function LoadCombo(combo As ComboBox, data As Collection, display_field As String) As Collection
   '-------------------------------------------------------------------------------
   'Note the combo must be cleared by the calling routine, as sometimes we may want
   'to add data not retrieved from the data collection
   '-------------------------------------------------------------------------------

   Dim i As Integer
   Dim j As Collection
   Dim c As New Collection

   combo.Clear()
   i = 0
   For Each j In data
      combo.Add(data[data.key][display_field])
      c.Add(j, i)
      Inc i
   Next
   Return c

End

Public Function LoadCombo_new(combo As ComboBox, data As Collection, display_fields As String[]) As Collection
   '-------------------------------------------------------------------------------
   'Note the combo must be cleared by the calling routine, as sometimes we may want
   'to add data not retrieved from the data collection
   'IAN ?fixme or at least accept me as ok.
   '-------------------------------------------------------------------------------

   Dim i As Integer
   Dim j As Collection
   Dim c As New Collection
   Dim Display_field As String

   combo.Clear()
   i = 0
   For Each j In data
      If IsNull(data[data.key][display_fields[0]]) Then
         combo.Add(data[data.key][display_fields[1]])
      Else
         combo.Add(data[data.key][display_fields[0]])
      End If
      c.Add(j, i)
      Inc i
   Next
   Return c

End

Public Sub Columnview_SetFont(Obj As Object, Settings_Section As String)
   '----------------------------------------------------------
   'Attempts to change the font of object and save to settings
   'FIXME - do global search/replace name it Object_SetFont
   '----------------------------------------------------------

   Dialog.font = obj.font
   If Dialog.SelectFont() Then Return
   Obj.font = Dialog.Font
   Settings[Settings_Section & "/" & Obj.name & ".font"] = Obj.Font.ToString()

End

Public Sub Listview_SetFont(lvw As Listview, Settings_Section As String)
   '-----------------------------------------------------------------
   'Attempts to change the font of a columnview and save to settings
   '-----------------------------------------------------------------

   Dialog.font = lvw.font
   If Dialog.SelectFont() Then Return
   lvw.font = Dialog.Font
   Settings[Settings_Section & "/" & lvw.name & ".font"] = lvw.Font.ToString()

End

Public Function Change_Fonts(F As Font) As Font

   Dialog.font = F
   If Dialog.SelectFont() Then Return
   Return Dialog.Font

End

Public Function Screenshot_Grab(Ctrl As Control, Optional h As Integer, Optional w As Integer) As String

   '---------------------------------------------------------------
   'Grabs a screenshot of a control, saves to a temp file
   'returns some html for the notes
   'fixme this dosn't work
   '---------------------------------------------------------------
   Dim tempfile As String
   Dim I As New Image
   Dim P As New Picture
   Dim sPicPath As String

   Tempfile = Temp() & ".png"
   P = Ctrl.Screenshot()

   P.Save(Tempfile)  'save the picture to the disk
   If Not h Then h = P.h
   If Not w Then w = P.w

   sPicPath = "<TABLE WIDTH=100%><TR><TD WIDTH=100%><P><IMG src=" & tempfile & " "
   sPicPath &= " NAME=graphics ALIGN=LEFT WIDTH=" & Str(w) & " HEIGHT=" & Str(h) & " BORDER=0></TR></TD></TABLE><BR><BR>"  '<BR CLEAR=Left>

   Return sPicPath
   '

End

Public Function CapsLockStatus() As Boolean

   Dim res As String

   ' xset q = xset query returns report about X console, then use awk to parse out the hex digit we want
   Try Shell "xset q | awk '/.*LED mask.*/ { print and(1,strtonum(\"0x\" substr($10,8,1))) }'" To res
   If Error Then Return False
   res = Trim$(res)
   If res = "1" Then
      Return True
   Else
      Return False
   Endif

End

Public Sub ReportError(errtxt As String, bt As String[])
   ' reports as error, usually used at the end of the
   ' function like:
   ' Catch
   '   modUtil.ReportError(Error.Text, Error.Backtrace)
   ' End

   Dim frm_error As FError
   Dim i As String

   Log.ErrorMsg(errtxt)
   For Each i In bt
      Log.ErrorMsg(i)
   Next

   frm_error = New FError
   frm_error.SetMessage(errtxt)
   Try frm_error.ShowModal()

End

Public Sub Medicare_Number_Check(mcn As String) As String
   '----------------------
   ' strip out any non-numeric characters and check validity of 10-digit Medicare number
   '----------------------

   Dim i As Integer
   Dim Magic As Byte[] = [1, 3, 7, 9, 1, 3, 7, 9]
   Dim proper_mcn As String = ""
   Dim check_total As Integer = 0
   Dim proper_pos As Integer

   For i = 1 To Len(mcn)
      If Asc(mcn, i) >= Asc("0") And If Asc(mcn, i) <= Asc("9") Then
         proper_pos = Len(proper_mcn)
         If proper_pos < 8 Then
            check_total += Magic[proper_pos] * (Asc(mcn, i) - Asc("0"))
         Endif
         If proper_pos = 8 Then ' this is digit nine: the check digit
            If (Asc(mcn, i) - Asc("0")) <> check_total Mod 10 Then
               Return "*INVALID*"
            Endif
         Endif
         proper_mcn &= Mid$(mcn, i, 1)
      Endif
   Next
   If Len(proper_mcn) <> 10 Then Return "*INVALID*"
   Return proper_mcn

End

Public Sub Medicare_Number_Format(mcn As String) As String
   ' return a 10-digit medicare number formatted in a nice way

   Dim s As String

   mcn = Trim$(mcn)
   s = Mid$(mcn, 1, 4) & " " & Mid$(mcn, 5, 5) & " " & Mid$(mcn, 10, 1) & " " & Mid$(mcn, 11, 1)
   Return s

End

Public Sub Medicare_Create_Expiry_date(s As String) As String
   '-------------------------------------------------------------
   'expects string like 09/2012, returns last-day-in-month/mm/yyyy
   '--------------------------------------------------------------

   Dim re As Regexp
   Dim m As Integer
   Dim y As Integer
   Dim d As Integer

   If s = "" Then Return
   re = New Regexp(s, "^([0-9]{1,2})/([0-9]{2,4})$")
   If re.Offset < 0 Then Return Null
   m = Val(re.SubMatches[1].Text)
   y = Val(re.SubMatches[2].text)
   If y < 100 Then y += 2000
   Select Case m
      Case 2
         d = 28
         If ((y Mod 4 = 0) And (y Mod 100 <> 0)) Or (y Mod 400 = 0) Then d = 29
      Case 9, 4, 6, 11 ' 30 days hath..
         d = 30
      Case Else
         d = 31
   End Select
   Return Str(d) & "/" & s

End

Public Sub Provider_Number_Check(pn As String) As String
   ' cleans up an checks validity of Medicare provider numbers
   ' example: 246564AK

   Dim re As Regexp
   Dim i As Integer
   Dim check_total As Integer = 0
   Dim Magic As Integer[] = [3, 5, 8, 4, 2, 1]
   Dim PLV As String[] = ["0", Null, "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "Q", "R", "T", "U", "V", "W", "X", "Y"]
   Dim Check_Digits As String[] = ["Y", "X", "W", "T", "L", "K", "J", "H", "F", "B", "A"]

   pn = Upper$(pn)
   If Len(pn) = 7 Then pn = "0" & pn
   re = New Regexp(pn, "^[0-9]{6}[0-9A-Y][A-Y]$")
   If re.Offset = -1 Then Return "*INVALID*"
   For i = 1 To 6
      check_total += (Asc(pn, i) - Asc("0")) * Magic[i - 1]
   Next
   i = PLV.Find(Mid$(pn, 7, 1))
   If i = -1 Then Return "*INVALID*"
   check_total += i * 6
   check_total = check_total Mod 11
   If Mid$(pn, 8, 1) <> Check_Digits[check_total] Then Return "*INVALID*"
   Return pn

End

Public Function Check_Utilities_Missing() As Boolean
   '--------------------------------------------------------------------
   'Does a quickn dirty check that some necessary programs are installed
   'pdfjoin (pdfjam) wkhtmltopdf, gmplayer, gnuplot
   'returns True if not installed
   '---------------------------------------------------------------------

   Dim Support_Programs As String[]
   Dim bMissingPrograms As Boolean
   Dim x As Integer
   Dim sMsg As String

   Support_Programs = New String[7, 2]
   Support_Programs[0, 0] = "mplayer"
   Support_Programs[0, 1] = "plays video files - install mplayer"
   Support_Programs[1, 0] = "wkhtmltopdf"
   Support_Programs[1, 1] = "converts html files to pdf files - install wkhtmltopdf-static binary"
   Support_Programs[2, 0] = "gnuplot"
   support_Programs[2, 1] = "creates graphs - install gnuplot"
   Support_Programs[3, 0] = "pdfjoin"
   support_Programs[3, 1] = "joins pdf - install pdfjam to get this"
   Support_Programs[4, 0] = "pdftk"
   support_Programs[4, 1] = "A pdf tool kit - install pdftk"
   Support_Programs[5, 0] = "lame"
   support_Programs[5, 1] = "An MP3 encoder"
   Support_Programs[6, 0] = "latex"
   support_Programs[6, 1] = "Latex - for document preparation and printing - install texlive-latex-base and texlive-latex-extra"
   sMsg = "Some utilities needed to run EasyGP are missing from this computer:\n\n"
   For x = 0 To Support_Programs.count / 2 - 1
      If IsNull(modUtil.FindProgram(support_Programs[x, 0], support_Programs[x, 0], True)) Then  'look for program, but suppress error message
         bMissingPrograms = True
         sMsg &= Support_Programs[x, 0] & " - " & Support_Programs[x, 1] & "\n"
      End If
   Next
   If bMissingPrograms Then
      Message.Title = "EasyGP - Missing Support Utilities"
      sMsg &= "\nEasyGP may not function properly, or worse, may even crash.\n\nYou should probably contact your IT support before using the program.\n\nAre you sure you want to continue?"
      If Message.Warning(sMsg, "Yes", "No") = 2 Then
         Return True
      Else
         Return False
      Endif
   End If

End

Public Function FindProgram(prg As String, package As String, Optional bSuppressMessage As Boolean = False) As String
   '------------------------------------------------------------------
   ' checks that an executable is available on the system
   ' prg: the name of the program
   ' package: the name of the Debian/RedHat package, only used to
   ' create a more helpful error message
   ' returns
   '   - NULL if the program isn't found on the system. Calling
   '      code should just exit directly, there is no need to have an
   '      error message as the function does this for you
   '   - if found the full path of the program which can be used for
   '     Shell or Exec commands
   'If bSuppressMessage =  True then no popup not found message is shown
   '---------------------------------------------------------------------

   Dim sMsg As String

   If Not IsNull(Settings["Paths/" & prg]) Then Return Settings["Paths/" & prg]
   If Access("/usr/bin" &/ prg, gb.Exec) Then Return "/usr/bin/" & prg
   If Access("/usr/local/bin" &/ prg, gb.Exec) Then Return "/usr/local/bin" &/ prg
   If Access("/usr/sbin" &/ prg, gb.Exec) Then
      sMsg = "A required executable " & prg
      sMsg &= " has been found in the directory /usr/sbin.\n\n"
      "Note that on linux systems the directory /sbin should contain only binaries "
      "essential for booting, restoring, recovering, and or repairing the system.\n\n"
      "it is recommended you move this file to the directory /usr/bin however EasyGP will continue to function without this change."
      Message.title = " PROBLEM FOUND WITH REQUIRED EXECUTABLES"
      Message.Warning(sMsg)
      Return "/usr/sbin" &/ prg
   Else
      If bSuppressMessage = False Then
         Message.Error(Subst$("Cannot find program &1. try installing package &2 on your system", prg, package))
      End If
      Log.ErrorMsg(Subst$("&1 not found anywhere", prg))
      Return Null
   End If

End

Public Function Find_File(fname As String) As String
   ' looks for a file in "common" places: in SVN,
   ' and where files should be stored in end-user deployments
   ' returns NULL if can't be found anywhere

   Dim paths As String[] = [Application.Path &/ "..", Application.Path, User.Home &/ "easygp/trunk", "/usr/share/easygp/", "/usr/local/share/easygp/"]
   Dim i As String

   For Each i In paths
      If Exist(i &/ fname) Then Return i &/ fname
   Next
   Return Null

End

Public Function StripExtraBlanks(s1 As String) As String
   '---------------------------------------------------------
   'strips any extra ascii 32 characters plus any off the end
   '---------------------------------------------------------

   Dim s2 As String = ""

   s2 = Replace$(s1, "  ", " ")
   While s2 <> s1
      s1 = s2
      s2 = Replace$(s1, "  ", " ")
   Wend
   Return Trim(s2)

End

' expects a collection from a database query where there are
' fields consult_date and fk_staff.
' returns another collection, being only those rows where the
' current user is fk_staff, and consult_date refers to today's date
Public Function Todays_Rows(original As Collection) As Collection

   Dim r As New Collection
   Dim i As Variant
   Dim fk_staff As Integer
   Dim t As Date

   fk_staff = modDBConnect.currentUser!fk_staff
   t = Now()
   For Each i In original
      If i!fk_staff = fk_staff And If IsSameDay(i!consult_date, t) Then
         r.Add(i, original.Key)
      End If
   Next

   Return r

End

' true if the two dates are the same day (i.e. but different times)
Public Function IsSameDay(d1 As Date, d2 As Date) As Boolean

   If Day(d1) = Day(d2) And If Month(d1) = Month(d2) And If Year(d1) = Year(d2) Then
      Return True
   Else
      Return False
   Endif

End

Public Sub SendMailToDeveloper(subject As String, text As String)

   Dim smtp As New SmtpClient
   Dim s As String

   smtp.Port = 10025
   s = modDBConnect.currentUser_FullName()
   If Not IsNull(modDBConnect.currentUser) Then
      If Lower$(modDBConnect.currentUser!branch) <> "head office" Then
         s &= " " & modDBConnect.currentUser!branch
      Endif
      s &= " " & modDBConnect.currentUser!organisation & " " & modDBConnect.currentUser!town
   Endif
   s = Replace$(s, " ", "-")
   s = Lower$(s)
   smtp.Encrypt = Net.TLS
   smtp.From = s
   smtp.Host = "haywood.id.au"
   smtp.Add(text)
   smtp.To.Add("ian@haywood.id.au")
   smtp.Subject = "[EASYGP] " & subject
   Try smtp.Send()
   If Error Then
      Message.Error(Error.Text)
   Endif

End

Public Sub SendContribution(f As String, sMsg As String)

   Dim s As String
   Dim h As New HttpClient

   sMsg = "-- date: " & Now() & "\n" & sMsg
   SendMailToDeveloper("[EASYGP] drug contribution", sMsg)

End

Public Function Money_Format(money As Variant) As String

   Dim s As String
   Dim s2 As String[]

   If money = "" Then Return
   If TypeOf(money) = gb.Float Or If TypeOf(money) = gb.Single Then
      Return "$" & Format(money, "#.00")
   Else
      s2 = Split(money, ".")
      If Left$(s2[0], 1) <> "$" Then
         s2[0] = "$" & s2[0]
      Endif
      If s2.Length = 1 Then
         Return s2[0] & ".00"
      Else
         If Len(s2[1]) = 1 Then
            s2[1] = s2[1] & "0"
         Endif
         If Len(s2[1]) = 0 Then
            s2[1] = "00"
         Endif
         If Len(s2[1]) > 2 Then
            s2[1] = Left$(s2[1], 2)
         Endif
         Return s2[0] & "." & s2[1]
      Endif
   Endif

End

Public Function isMoney(s As String) As Boolean

   Dim re As Regexp

   If s = "" Then Return
   re = New Regexp(s, "^\\$[0-9]+\\.?[0-9]{0,2}$")
   If re.Offset = -1 Then Return False
   Return True

End

' accepts a money value formatted as from Format_Money or Postgres money type
Public Function MoneyToFloat(s As String) As Float

   If s = "" Then Return CFloat(0)
   If Left$(s, 1) = "$" Then s = Right$(s, -1)
   Return Val(s)

End

Public Sub Split_Firstname(name As String, ByRef firstname As String, ByRef initial As String)

   Dim sa As String[]

   sa = Split(name, " ", "", True)
   firstname = sa[0]
   If sa.Length > 1 Then
      initial = Left$(sa[1], 1)
   Else
      initial = ""
   Endif

End

Public Sub Kill_If_Temp(fname As String)

   If Not IsNull(fname) And If Left$(fname, 5) = "/tmp/" Then
      Try Kill fname
   Endif

End

Public Sub Get_Temp_Dir() As String

   Dim re As Regexp

   If Not IsNull(tempdir) Then Return tempdir
   re = New Regexp(Temp$(), "(/.*/)[0-9]+\\.tmp$")
   tempdir = re.SubMatches[1].Text
   Return tempdir

End
