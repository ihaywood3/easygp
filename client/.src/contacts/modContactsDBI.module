' Gambas module file

' Copyright (C) 2008-2013 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'----------------------------------------------------------------------
Public sSubroutineName As String
Private searchtext As String
Private regex As Regexp
Private staff As Collection
Private clinics As Collection

Public Sub Communication_UnDelete(pk As Integer)
   'Un-deletes a communication, returns non-zero if succeeded
   
   modDBConnect.exec_query("Update contacts.data_communications set deleted = False where pk =" & pk)
   
End

Public Function Towns_Get(Optional postcode As String) As Collection
   '------------------------------------------------------------------------
   ' Return a collection of all Towns/localities or whatever you'd call them
   ' vwTowns is ordered alphabetically
   '------------------------------------------------------------------------
   
   If IsNull(postcode) Then
      Return modDBConnect.exec_query_collection("select * from contacts.vwTowns order by town")
   Else
      Return modDBConnect.exec_query_first("select * from contacts.vwTowns where postcode=&1 limit 1", [postcode])
   Endif
   
End

Public Sub Fix_Categories()
   
   '---------------------------------------------------------------------------
   'Tempory fix to duplicated categores till Horst/I decide what to do
   'unfortunately historically persons were allocated categories as well
   'as occuptions, this was later removed, but occupations have ended up 
   'in the categories table, plus there was  a bug leading to duplicates  
   '----------------------------------------------------------------------------
   
   Dim sql As String
   Dim categories As Collection
   Dim done As Boolean
   
   Dim branches As Collection
   Dim branch As Collection 
   Dim old_category As String
   Dim R As Result
   Dim x As Integer
   Dim category As Collection 
   Dim new_pk_category As String 
   
   'make a copy of all unique categories in the database these will have new primary keys 1 through to whatever
   If Message.Warning("This will fix duplicated entries in the categories table.\n\nIt will not affect your current allocation of categories", "Yes", "No") = 2 Then Return 
   modDBConnect.exec_query("CREATE temporary TABLE lu_categories_new (pk serial primary key,category text NOT NULL)")
   Inc Application.Busy
   modDBConnect.exec_query("insert into lu_categories_new (category) select distinct lower (category) from contacts.lu_categories order by lower (category)")
   'Now to fix all the tables contacts.data_branches
   branches = modDBConnect.exec_query_collection("Select * from contacts.data_branches")
   For Each branch In branches
      R = modDBConnect.exec_query("Select * from contacts.lu_categories where pk = " & branch!fk_category)       'for each branch get its fk_categoryl)
      If R.count = 0 Then     'warning just in case 
         Message.Warning("missing category")
      Else
         old_category = R!category                                                        'assuming dosn't fail
         sql = "Select * from lu_categories_new where category ILIKE $$" & old_category & "$$"  'get new category pk
         R = modDBConnect.exec_query(sql)
         If R.count = 0 Then
            Message.Warning("missing new category")
         Else
            new_pk_category = R!pk                                                            'then update the old table with new pk
            sql = "Update contacts.data_branches set fk_category = " & new_pk_category & " where pk=" & branch!pk
            modDBConnect.exec_query(sql)
         Endif
      Endif
   Next
   '------------------------------------------------------------------------------
   'Now wipe the original contacts lu_categories table, copy back the altered data
   '------------------------------------------------------------------------------
   modDBConnect.exec_query("Delete from contacts.lu_categories")      'Now wipe the contacts lu_categories table
   sql = "ALTER SEQUENCE contacts.lu_categories_pk_seq "              'reset the index to the start
   sql &= " INCREMENT 1 MINVALUE 1 "
   sql &= "MAXVALUE 9223372036854775807 RESTART 1 "
   sql &= "CACHE 1 NO CYCLE"
   modDBConnect.exec_query(sql)
   sql = "INSERT INTO contacts.lu_categories(pk,category) "
   sql &= "SELECT * from lu_categories_new order by pk"     'copy back the fixed data
   modDBConnect.exec_query(sql)
   sql = "Select count(pk) from lu_categories_new"
   R = modDBConnect.exec_query(sql)
   sql = "ALTER SEQUENCE contacts.lu_categories_pk_seq RESTART " 'reset starting pk
   sql &= R!count
   modDBConnect.exec_query(sql)
   sql = "drop table lu_categories_new"
   modDBConnect.exec_query(sql)
   Dec Application.Busy
   Select Case Message.Question("Finished refurbishing the category table, commit the transaction?", "Yes", "No")
      Case 1
         modDBConnect.CommitTrans()
      Case 2
         modDBConnect.RollBack()
   End Select
   
End

Public Function Town_state_postcode_get() As Collection
   '-------------------------------------------------------------------------------------------------
   'gets collection of single field joined townstatepostcode, used in importing or updating postcodes
   '-------------------------------------------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("SELECT lu_towns.town || lu_towns.state::text || lu_towns.postcode AS pk_view  FROM contacts.lu_towns")
   
End

Public Function firstname_add(firstname As String, sex As String) As Integer
   
   Dim res As Integer
   Dim sql As String
   Dim $result As Result
   
   res = 4999
   sql = "select max(ord) as pk_firstname from contacts.lu_firstnames"
   $result = modDBConnect.exec_query(sql)
   res = $Result!pk_firstname
   sql = "Insert into contacts.lu_firstnames(firstname, ord, sex) Values($$"
   sql &= firstname & "$$," & res
   sql &= ",$$" & sex & "$$)"
   $result = modDBConnect.exec_query(sql)
   Return 1
   
End

Public Function Firstname_Get(name As String) As Collection
   
   Dim sql As String
   
   sql = "SELECT distinct pk, firstname, sex FROM contacts.lu_firstnames WHERE lower (firstname) LIKE $$"
   sql &= Lower$(name) & "%$$  LIMIT 10"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function find_surname(name As String) As Result
   
   Dim sql As String
   Dim $dataset As Result
   
   sql = "SELECT * "
   "FROM "
   "contacts.lu_surnames "
   "WHERE "
   " lower (surname) LIKE $$"
   sql &= Lower$(name) & "%$$  LIMIT 20"
   $dataset = modDBConnect.exec_query(sql)
   Return $dataset
   
End

Public Function Categories_Get(category As String) As Collection
   'Returns categories LIKE
   
   Return modDBConnect.exec_query_collection("SELECT * FROM contacts.lu_categories WHERE category ILIKE $$%" & category & "%$$  LIMIT 20")
   
End

Public Function Category_Get(category As String) As Collection
   'gets just a single category strings must match
   
   Return modDBConnect.exec_query_first("SELECT * FROM contacts.lu_categories WHERE lower(category) =$$" & Lower(category) & "$$")
   
End

Public Function Category_Save(category As String) As Integer
   '----------------------------------------------
   'Inserts a category into contacts.lu_categories
   '----------------------------------------------
   
   Dim $Result As Result
   
   $Result = modDBConnect.exec_query("INSERT INTO contacts.lu_categories (category) VALUES($$" & category & "$$) returning pk")
   Return $Result!pk
   
End

Public Function Language_Get(language As String) As Collection
   
   Return modDBConnect.exec_query_collection("SELECT *   FROM common.lu_languages WHERE  lower (language) ILIKE $$" & Lower$(language) & "%$$  LIMIT 20")
   
End

Public Function Ethnicity_Get(ethnicity As String) As Collection
   
   Return modDBConnect.exec_query_collection("SELECT * FROM common.lu_ethnicity WHERE ethnicity ILIKE $$" & ethnicity & "%$$  LIMIT 20")
   
End

Public Function Country_Get(country As String) As Collection
   
   Return modDBConnect.exec_query_collection("SELECT * FROM common.lu_countries WHERE lower (country) ILIKE $$" & Lower(country) & "%$$ LIMIT 10")
   
End

Public Function Country_Get_Single(country As String) As Collection
   
   Return modDBConnect.exec_query_first("SELECT * FROM common.lu_countries WHERE lower (country) ILIKE $$" & country & "$$")
   
End

Public Function get_last_person_pk() As Integer
   'fetches the last person's pk inserted into the database
   
   Dim sql As String
   Dim $dataset As Result
   
   sql = "select * from contacts.data_persons where pk = currval('contacts.data_persons_pk_seq')"
   $dataset = modDBConnect.exec_query(sql)
   Return $dataset!pk
   
End

Public Function get_last_family_pk() As Integer
   
End

Public Sub Person_Addresses_Save(old_data As Collection, pk_view_address As Variant, addresses As Collection, person As Collection)
   
   Dim address As Collection
   '-------------------------------------
   'Address: create new or change details
   '-------------------------------------
   For Each Address In addresses
      If Not IsNull(address) Then
         If IsNull(address!fk_address) Then
            '--------------------
            'Create a new address
            '--------------------
            address!fk_address = modDBConnect.insert("contacts.data_addresses", address)
            person_address_link(person!fk_person, address!fk_address)
            
         Else
            '-------------------------------
            'change existing address details
            '-------------------------------
            Try address.Remove("town")
            Try address.Remove("postcode")
            Try address.Remove("state")
            modDBConnect.update("contacts.data_addresses", old_data[address!fk_address], address, "fk_address")
         End If
      End If
   Next
   
End

Public Function person_addresses_get(fk_person As Integer) As Collection
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwPersonsAddresses where fk_person = " & fk_person)
   
End

Public Function person_comms_get(fk_person As Integer) As Collection
   
   Return modDBConnect.exec_query_collection("Select * From contacts.vwpersonscomms where fk_person = " & fk_person & " And deleted = False")
   
End

Public Sub Employee_Comm_Link(fk_employee As Integer, pk_comm As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_employees_comms "
   "(fk_employee,fk_comm)"
   "VALUES ("
   sql &= fk_employee & "," & pk_comm & ")"
   modDBConnect.exec_query(sql)
   
End

Public Function Employee_Get(surname As String) As Collection
   
   Dim sql As String
   
   sql = " Select * From contacts.vwOrganisationsEmployees where surname ILIKE $$"
   sql &= Trim(surname) & "%$$ ORDER BY surname, firstname, category"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_get_memo(fk_organisation As Integer, fk_branch As Integer, fk_person As Integer) As Collection
   
   Dim sql As String
   
   sql = "Select * From contacts.vwOrganisationsEmployees WHERE "
   sql &= "fk_organisation = " & fk_organisation
   sql &= " AND fk_branch = " & fk_branch
   sql &= " AND fk_person = " & fk_person
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Get_With_Memo_Like(surname As String, memo As String, Optional sex As Integer = const.cSexUnknown) As Collection
   '--------------------------------------------------------------------
   'I am arbitrarily allowing searching on multiple things eg anger;sex;
   '--------------------------------------------------------------------
   
   Dim sql As String
   Dim searchitems As String[]
   Dim item As String
   Dim x As Integer
   
   searchitems = Split(memo, ";", "", True)
   
   sql = "Select * From contacts.vwOrganisationsEmployees where surname ILIKE $$"
   sql &= Trim(surname) & "%$$ "
   If sex <> const.cSexUnknown Then
      sql &= "AND fk_sex = " & sex & " "
   End If
   
   For x = 0 To searchitems.count - 1
      
      sql &= "AND memo ILIKE $$%" & searchitems[x] & "%$$ "
      
   Next
   sql &= "ORDER BY surname, firstname, category"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Staff_Exists(logon_name As String) As Boolean
   
   Dim sql As String
   Dim r As Result
   
   sql = "select 1 from admin.staff where logon_name = &1"
   r = modDBConnect.exec_query(sql, [logon_name])
   If r.Count > 0 Then Return True
   Return False
   
End

Public Function Staff_Create_Postgres_User(old_data As Collection, pk_view As Integer, staff As Crow, Optional bSuperuser As Boolean) As Boolean
   '-------------------------------------------------------------------
   'Creates or changes a postgres user returns True if succeeds
   'any validation of existing user must be done my the calling routine
   'IAN PLEASE DO NOT REMOVE THIS AGAIN WITHOUT TALKING TO ME
   'I DON'T MIND, BUT THERE WAS A SPECIFIC REASON TO TO WITH IMPORTING
   'I'M SURE YOU HAVE A MORE ELEGANT SOLUTION, HAPPY WITH WHATEVER
   'BUT IT CRIPPLES MY IMPORT OF HORSTS DATA
   '-------------------------------------------------------------------
   
   Dim $Result As Result
   Dim sql As String
   Dim role As String
   'this is temporary IAN FIXME.
   Select Case staff!fk_role
      Case const.StaffRole_SysAdmin
         role = "easygp"
      Case Else
         role = "staff"
   End Select
   
   If Not staff.Exist("fk_staff") Then
      '----------------------------------------------------
      'New staff member? add as user with selected password
      '----------------------------------------------------
      If Not modDBConnect.Role_Check_If_Exists(staff!logon_name) Then
         sql = "CREATE USER  \"" & staff!logon_name & "\" PASSWORD $$" & staff!password & "$$ IN ROLE " & role
         If bSuperuser Then
            sql &= " SUPERUSER "
         Endif
         If Not (IsNull(staff!logon_date_to)) Then
            sql &= " VALID UNTIL '" & Format$(staff!logon_date_to, "dd/mm/yyyy") & "'"
         End If
         $Result = modDBConnect.exec_query(sql)
         sql = "GRANT staff to \"" & staff!logon_name & "\""
         $Result = modDBConnect.exec_query(sql)
      Else
         Return 'a false flag = fail
      End If
   Else
      '------------------------------------------------------------
      'An existing user
      '------------------------------------------------------------
      If staff!logon_name <> old_data[pk_view]!logon_name Then
         sql = "ALTER ROLE \"&1\" RENAME TO \"&2\""
         sql = Subst$(sql, old_data[pk_view]!logon_name, staff!logon_name)
         modDBConnect.exec_query(sql)
      Endif
      If staff!logon_date_to <> old_data[pk_view]!logon_date_to Then
         sql = "ALTER ROLE \"&1\" VALID UNTIL '&2'"
         sql = Subst$(sql, staff!logon_name, Format$(staff!logon_date_to, "dd/mm/yyyy"))
         modDBConnect.exec_query(sql)
      Endif
      If staff.Exist("password") And If staff!password <> "" Then
         sql = "ALTER ROLE \"&1\" WITH PASSWORD '&2'"
         sql = Subst$(sql, staff!logon_name, staff!password)
         modDBConnect.exec_query(sql)
      Endif
   End If
   Return True
   
End

Public Function Staff_Member_Save(old_data As Collection, pk_view As String, staff As Collection, employees_place_of_work As Collection) As Integer
   '----------------------------------------------------
   'Saves or changes a staff member with particular role
   'easygp the only one who can add new staff members
   '(unless of course you are a superuser!)
   '----------------------------------------------------
   
   Dim $Result As Result
   Dim sql As String
   Dim role As String
   'this is temporary IAN FIXME.
   Select Case staff!fk_role
      Case const.StaffRole_SysAdmin
         role = "easygp"
      Case Else
         role = "staff"
   End Select
   
   If IsNull(staff!fk_staff) Then
      '----------------------------------------------------
      'New staff member? add as user with selected password
      '----------------------------------------------------
      If Not modDBConnect.Role_Check_If_Exists(staff!logon_name) Then
         sql = "CREATE USER  \"" & staff!logon_name & "\" PASSWORD $$" & staff!password & "$$ IN ROLE " & role
         If Not (IsNull(staff!logon_date_to)) Then
            sql &= " VALID UNTIL '" & Format$(staff!logon_date_to, "dd/mm/yyyy") & "'"
         End If
         $Result = modDBConnect.exec_query(sql)
         sql = "GRANT staff to \"" & staff!logon_name & "\""
         $Result = modDBConnect.exec_query(sql)
      End If
      '------------------------------------
      'Now create the user as a EasyGP user
      '------------------------------------
      staff.remove("password") ' don't save password in table
      staff!fk_staff = modDBConnect.insert("admin.staff", staff)
      '---------------------------------------
      'now link the staff member to the clinic
      '---------------------------------------
      employees_place_of_work!fk_staff = staff!fk_staff
      employees_place_of_work!fk_link_staff_clinic = modDBConnect.insert("admin.link_staff_clinics", employees_place_of_work)
   Else
      '------------------------------------------------------------
      'An existing user
      '------------------------------------------------------------
      If staff!logon_name <> old_data[pk_view]!logon_name Then
         sql = "ALTER ROLE \"&1\" RENAME TO \"&2\""
         sql = Subst$(sql, old_data[pk_view]!logon_name, staff!logon_name)
         modDBConnect.exec_query(sql)
      Endif
      If staff!logon_date_to <> old_data[pk_view]!logon_date_to Then
         sql = "ALTER ROLE \"&1\" VALID UNTIL '&2'"
         sql = Subst$(sql, staff!logon_name, Format$(staff!logon_date_to, "dd/mm/yyyy"))
         modDBConnect.exec_query(sql)            'GRANT Staff to DB;
      Endif
      If staff.Exist("password") And If staff!password <> "" Then
         sql = "ALTER ROLE \"&1\" WITH PASSWORD '&2'"
         sql = Subst$(sql, staff!logon_name, staff!password)
         modDBConnect.exec_query(sql)
         staff.Remove("password") ' password not stored anywhere else
      Endif
      modDBConnect.update("admin.staff", old_data[pk_view], staff, "fk_staff")
      modDBConnect.update("admin.link_staff_clinics", old_data[pk_view], employees_place_of_work, "fk_link_staff_clinic")
   End If
   Staff_Cache_Wipe()
   Return staff!fk_staff
   
End

Public Function Staff_Status_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from admin.lu_staff_status")
   
End

Public Function Image_Save(The_Image As Collection, Optional fk_consult As Integer) As Integer
   '-------------------------------------------------------------
   'Saves an image, usually a persons picture  returns its pk
   'Fixme - move Iamge_Save from modconsultDBI to somewhere else
   '-------------------------------------------------------------
   
   If IsNull(The_Image!fk_image) Then
      Return modConsultDBI.Image_Save(The_Image!path, fk_consult, modUtil.Calc_md5sum_File(The_Image!path))
   Else
      ' Message.Info("STOP: BUG HERE")
      Return The_Image!fk_image 'fixme allow editing
      '   Return modConsultDBI.Image_Save(The_Image!path, The_Image!fk_image)
   End If
   
End

Public Function Patients_Erase()
   '----------------------------------------------------
   'Wipes the entire patient database
   'As Yet does'nt cascade to person as I've not put in
   'referential integrity, not wipes any data
   'just using this during import practice
   '-----------------------------------------------------
   
   Dim sql As String
   Dim $result As Result
   
   sql = "Delete from clerical.data_patients"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "Delete from clerical.data_family_members"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "Delete from clerical.data_families"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "ALTER SEQUENCE clerical.data_patients_pk_seq"
   "    INCREMENT 1  MINVALUE 1"
   "    MAXVALUE 9223372036854775807  RESTART 1"
   "    CACHE 1  NO CYCLE"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "ALTER SEQUENCE clerical.data_family_members_pk_seq"
   "    INCREMENT 1  MINVALUE 1"
   "    MAXVALUE 9223372036854775807  RESTART 1"
   "    CACHE 1  NO CYCLE"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "ALTER SEQUENCE clerical.data_families_pk_seq "
   " INCREMENT 1  MINVALUE 1 "
   " MAXVALUE 9223372036854775807  RESTART 1 "
   " CACHE 1  NO CYCLE"
   $Result = modDBConnect.exec_query(sql)
   
End

Public Function Person_Save(old_data As Collection, old_pk As String, person As Collection, comms As Collection, old_comms As Collection) As Integer
   '---------------------
   'First, the occupation
   '---------------------
   
   Dim comm As Collection
   
   If IsNull(person!fk_occupation) And (Not IsNull(person!occupation)) Then
      person!fk_occupation = modCommonDBI.Occupation_Save(person!occupation)
      person.Remove("occupation")
   End If
   If IsNull(person!fk_category) And (Not IsNull(person!category)) Then
      person!fk_category = Category_Save(person!category)
   End If
   Try person.Remove("category")
   '-------------------------
   'Save or modify the person
   '-------------------------
   If IsNull(person!fk_person) Then
      person!fk_person = modDBConnect.insert("contacts.data_persons", person)
   Else
      modDBConnect.update("contacts.data_persons", old_data[old_pk], person, "fk_person")
   End If
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         person_Comm_Link(person!fk_person, comm!pk)
      Else
         modDBConnect.update("contacts.data_communications", old_comms[comm!pk], comm, "pk")
      End If
   Next
   Return person!fk_person
   
End

Public Function Person_Get_Photo(fk_image As Integer) As Picture
   
   Dim P As Picture
   Dim R As Result
   
   R = modDBConnect.exec_query("Select * from blobs.images where pk=" & fk_image)
   If R.count Then
      If Not IsNull(R!image) Then
         P = modGraphics.Blob_Convert_To_Picture(R!image)!picture
      Endif
   Endif
   Return P
   
End

Public Function Patient_Save(old_data_patient As Collection, old_pk As String, patient As Collection) As Integer ', person As collection, comms As collection, old_comms As collection) As Integer
   '---------------------------------------------
   'Saves or updates a patient
   'FIXME - PUT IN VALIDATION THAT NOT DUPLICATED
   '---------------------------------------------
   
   Dim comm As Collection
   Dim family As Collection
   Dim collection_to_return As New Collection
   
   '-------------------------------
   'A Patient is firstly a person
   '------------------------------
   ' If IsNull(person!fk_person) Then
   '       person!fk_person = modDBConnect.insert("contacts.data_persons", person)
   ' Else
   '      modDBConnect.update("contacts.data_persons", old_data_patient[old_pk], person, "fk_person")
   ' End If
   '-------------------------------------------
   'Saves communications for patient
   '--------------------------------------------
   ' For Each comm In comms
   '    Try comm.Remove("type") 'was needed for display in editing
   '    If IsNull(comm!pk) Then
   '       comm!pk = modDBConnect.insert("contacts.data_communications", comm)
   '       person_Comm_Link(person!fk_person, comm!pk)
   '
   '    Else
   '       modDBConnect.update("contacts.data_communications", old_comms[comm!pk], comm, "pk")
   '    End If
   ' Next
   ' 'Ok, finished with person specific stuff. in a minute split this routine
   '-------------------------------
   'Now, make this person a patient
   '-------------------------------
   If IsNull(patient!fk_patient) Then
      ' patient!fk_person = person!fk_person
      patient!fk_patient = modDBConnect.insert("clerical.data_patients", patient)
      If IsNull(patient!fk_family) Then
         '-------------------------------------------------------------
         'A family gets a single pk and as long as family members exist
         'then disbanded = False
         '-------------------------------------------------------------
         family = New Collection
         family!disbanded = False
         family!fk_family = modDBConnect.insert("clerical.data_families", family)
         family.Remove("disbanded")
         'havn't checked this - should it be fk-patient or fk_person
         family!fk_patient = patient!fk_patient
         'this name has no meaning here
         family!fk_family = modDBConnect.insert("clerical.data_family_members", family)
         '-----------------------------------------------------------------
         ' now insert this into data_family_members, with the patient key
         '-----------------------------------------------------------------
      End If
   Else
      modDBConnect.update("clerical.data_patients", old_data_patient[old_pk], patient, "fk_patient")
      
   End If
   
   Return patient!fk_patient
   
End

Public Function Employee_Comms_Get(fk_employee As Integer) As Collection
   
   Dim sql As String
   
   sql = "Select "
   " c.pk ,"
   " c.value,"
   " c.note,"
   " c.preferred_method,"
   " c.confidential,"
   " c.deleted,"
   " c.fk_type, "
   " t.type"
   " From "
   " contacts.data_communications c, "
   " contacts.links_employees_comms lec, "
   " contacts.lu_contact_type t "
   "WHERE "
   " t.pk = c.fk_type and "
   " c.pk = lec.fk_comm and lec.fk_employee = &1 "
   "union select "
   " c.pk ,"
   " c.value,"
   " c.note,"
   " c.preferred_method,"
   " c.confidential,"
   " c.deleted,"
   " c.fk_type, "
   " t.type"
   " From "
   " contacts.data_communications c, "
   " contacts.lu_contact_type t, "
   " contacts.links_branches_comms lbc,"
   " contacts.data_employees e "
   "WHERE "
   " t.pk = c.fk_type and "
   " lbc.fk_branch = e.fk_branch and lbc.fk_comm = c.pk and e.pk = &1 "
   sql = Subst$(sql, fk_employee)
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Branch_Comms_Get(fk_branch As Integer) As Collection
   '-------------------------------------------------------------------
   'Fetch all communications or contact information for a single branch
   '-------------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwBranchesComms where fk_branch =" & fk_branch)
   
End

Public Function Employees_All_Locations_get(pk_person As Integer) As Result
   '--------------------------------------------------------------------------
   'Filters record on employee, note must be on pk_person as each location
   'has a different pk_employee as they are employed by distinct organisations
   'or branches
   '--------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees "
   "WHERE "
   sql &= " pk_person =" & pk_person
   sql &= " AND organisation_deleted = False And branch_deleted = False "
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query(sql)
   
End

Public Function Clinics_Get() As Collection
   '---------------------------------------------------
   'Returns a collection of clinics in our organisation
   '---------------------------------------------------
   
   If IsNull(clinics) Then
      Let clinics = modDBConnect.exec_query_collection("Select * from admin.vwClinics")
   Endif
   Return clinics
   
End

Public Function Staff_Get(Optional surname As String = "", Optional fk_staff_type As Integer = 0) As Collection
   '----------------------------------------------------------------------------------
   'Return a collection of staff(or member)  in our organisation. This is not the same
   'as employees in an organisation but specific to the practice running EasyGP
   '----------------------------------------------------------------------------------
   ' this query gets done a lot: so cache in RAM and query on the cache
   
   Dim coll As New Collection
   Dim i As Collection
   
   If IsNull(staff) Then
      staff = modDBConnect.exec_query_collection("select * from admin.vwstaffinclinics")
   Endif
   
   For Each i In staff
      If fk_staff_type = 0 Or If fk_staff_type = i!fk_staff_type Then
         If surname = "" Or If Left$(Lower$(i!surname), Len(surname)) = Lower$(surname) Then
            coll[staff.Key] = i
         Endif
      Endif
   Next
   
   Return coll
   
End

Public Sub Staff_Cache_Wipe()
   
   clinics = Null
   staff = Null
   
End

Public Function Staff_Get_Per_Role(fk_role As Integer, Optional fk_clinic As Integer) As Collection
   '-----------------------------------------------------------------------------------
   ' Returns a collection of type of staff eg const.StaffRole_Doctor gives all doctors
   ' FIXME this won't work as a doctor could be sys-admin
   ' HORST/IAN/RICHARD fix this whole messup of roles
   ' If clinic non zero then returns only on a per-clinic basis
   '"0"; "sysadmin"
   ' "1"; "doctor"
   ' "2"; "dentist"
   ' "3"; "locum" ""
   ' "4"; "student"
   ' "5"; "registered nurse"
   ' "6"; "practice manager"
   ' "7"; "secretary"
   ' "8"; "information technology"
   ' "9"; "counselor"
   ' "10"; "enrolled nurse"
   ' "11"; "dietitian"
   ' "12"; "psychologist"
   '-----------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from admin.vwStaffInClinics where fk_role = " & fk_role
   If fk_clinic Then
      sql &= " AND fk_clinic= " & fk_clinic
   Endif
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Staff_Get_With_Provider_Number() As Collection
   
   Dim i As Collection
   Dim coll As New Collection
   
   For Each i In Staff_Get()
      If Not IsNull(i!provider_number) Then
         coll[i!pk_view] = i
      Endif
   Next
   Return coll
   
End

Public Function Unmatched_Staff_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from documents.unmatched_staff where fk_real_staff is null")
   
End

Public Function Organisations_Employees_Get(organisation As String, Optional limit As Integer = 0) As Collection 
   '-----------------------------------------------------------
   'PURPOSE    Get a list of organisations and their employee's
   'fixme makes sure re-ording this and putting no_fax before limit does not screw anywhere with teh program
   '-----------------------------------------------------------
   
   Dim bits As String[]
   Dim bits_branch As String[]
   Dim sql As String
   
   sql = "Select * From contacts.vwOrganisationsEmployees where organisation ILIKE $$%"
   If InStr(organisation, ",") Then
      '----------------------------------------------
      'lets say user wants john hunter emergency ward
      'has typed joh,em
      '----------------------------------------------
      bits = Split(organisation, ",")
      If InStr(Trim(bits[0]), " ") Then 'mm.... someone could have typed eg john , instead of john,
         bits_branch = Split(bits[0], " ", "", True)
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "
      Else
         sql &= Trim(bits[0]) & "%$$"
      End If
      sql &= " AND branch ILIKE  $$%" & Trim(bits[1]) & "%$$ "
   Else
      '---------------------------------------------------------------------
      'user not after a head office, branch, maybe a two worded organisation
      '---------------------------------------------------------------------
      If InStr(Trim(organisation), " ") Then
         bits_branch = Split(organisation, " ", "", True)
         '     sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ " 'this would be eg. %whitebridge%m%
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "  'this will be  %whitebridge m%
      Else
         sql &= organisation & "%$$ "
      End If
   Endif
   sql &= "AND (employee_deleted = False Or employee_deleted Is null) "
   sql &= " AND branch_deleted = False and organisation_deleted = FALSE "
   sql &= " order by fk_Organisation,branch,surname,firstname "
   'sql &= " order by  fk_organisation, organisation ASC, branch, surname DESC, firstname "
   
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Organisations_Get_HeadOffice(organisation As String) As Collection
   
   Dim sql As String
   
   sql = "Select * from contacts.vworganisationsEmployees where organisation ILIKE $$%" & organisation & "%$$ "
   sql &= "AND fk_employee = 0 AND head_office = true "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Organisations_Get_HeadOffices_For_Provider_Type(fk_category As Integer, organisation As String) As Collection
   
   Dim sql As String
   
   sql = "Select * from contacts.vworganisationsEmployees where organisation ILIKE $$%" & organisation & "%$$ "
   sql &= "AND fk_employee = 0 AND head_office = true and fk_category = " & fk_category
   Return modDBConnect.exec_query_collection(sql)
   
End



Public Function Provider_Get_Types() As Collection
   '------------------------------------------------------------------
   'Gets list of all provider types by category
   'Note that everyone we want to provider services must be allocated
   'to a category name 'Name Provider' eg Pathology Provider
   '------------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * from contacts.lu_categories where category ILIKE $$%provider%$$ ORDER BY category")
   
End

Public Function Provider_Get_Types_Like(stype As String) As Collection
   '------------------------------------------------------------------
   'Gets list of all provider types by category
   'Note that everyone we want to provider services must be allocated
   'to a category name 'Name Provider' eg Pathology Provider
   '------------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * from contacts.lu_categories where category ILIKE $$%provider%$$ ORDER BY category")
   
End

Public Function Organisation_Get_Head_office_pk(fk_organisation As Integer) As Integer
   '------------------------------------------------------------------------------
   'Returns the primary key of the branch whose address is the address of the head
   'office of an organisation
   '------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "SELECT contacts.data_branches.pk FROM  contacts.data_branches "
   "INNER JOIN contacts.data_addresses ON (contacts.data_branches.fk_address = contacts.data_addresses.pk) "
   "WHERE contacts.data_branches.fk_organisation = "
   sql &= fk_organisation & " And   contacts.data_addresses.head_office = True"
   Return modDBConnect.exec_query(sql)!pk
   
End

Public Function Branches_Get_For_Category(fk_organisation As Integer, fk_category As Integer) As Collection
   '---------------------------------------------------------------------------------------
   'Gets branches for an organisation as a collection including comms using fk_organisation
   '---------------------------------------------------------------------------------------
   
   Dim sql As String
   Dim branches As Collection
   Dim branch As Collection
   Dim comms As Collection
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees WHERE fk_organisation = "
   sql &= fk_organisation & " AND fk_category =" & fk_category
   sql &= " And fk_employee < 1 and organisation_deleted = FALSE "
   sql &= "ORDER BY branch asc LIMIT 20 "
   branches = modDBConnect.exec_query_collection(sql)
   For Each branch In branches
      sql = "Select * from contacts.vwBranchesComms WHERE fk_branch = " & branch!fk_branch
      comms = modDBConnect.exec_query_collection(sql)
      branch!comms = comms
   Next
   Return branches
   
End

Public Function Branches_Get_For_Organisation(fk_organisation As Integer, Optional branch_name As String) As Collection
   '----------------------------------------------------------------------------------------
   'Gets branches for an organisation as a collection including comms using fk_organisation
   'fix me include like branch
   '---------------------------------------------------------------------------------------
   
   Dim sql As String
   Dim branches As Collection
   Dim branch As Collection
   Dim comms As Collection
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees WHERE fk_organisation = "
   sql &= fk_organisation
   sql &= " And fk_employee < 1 and organisation_deleted = FALSE "
   sql &= "ORDER BY branch asc " 'fixme checkme removed the limit March 12
   branches = modDBConnect.exec_query_collection(sql)
   For Each branch In branches
      sql = "Select * from contacts.vwBranchesComms WHERE fk_branch = " & branch!fk_branch
      comms = modDBConnect.exec_query_collection(sql)
      branch!comms = comms
   Next
   Return branches
   
End

Public Function Branches_Get_Like(branch As String) As Collection
   'changed to :and fk_employee = 0 23Feb10, this may fuck contacts?
   
   Return modDBConnect.exec_query_collection("select * from contacts.vwOrganisationsEmployees where branch ILIKE $$%" & branch & "%$$ and fk_employee = 0")
   
End

Public Sub Branch_get_by_keys(fk_branch As Integer) As Collection
   
   Return modDBConnect.exec_query_collection("Select * From contacts.vwOrganisationsEmployees where fk_branch = " & fk_branch & " and fk_employee = 0")
   
End

Public Sub Organisations_Get_By_Category(category As String) As Collection
   '------------------------------------------------------------------------------------------
   'get organisations by category
   'notes: as collection must have unique key, I've used fk_branch as the pk_view, still need
   'fk_branch for use within the calling routine
   '------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = ""
   "select distinct category, organisation, fk_organisation, branch, fk_branch as pk_view, fk_branch, "
   "town, street1, street2, postcode from contacts.vwOrganisations "
   "where organisation_deleted is not true and branch_deleted is not true and address_deleted is not true "
   sql &= " and category  ILIKE $$%" & category & "%$$ order by category, organisation, fk_branch " 'this way head-office always as first branch
   
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub Organisations_Get(organisation As String) As Collection
   '-------------------------------------------------------------------------------
   'Gets a list of organisations without employees, if comma separated
   'the searches on organisation and branch
   'can recieve text like org,branch or new rad,ad = newcastle radiology adamstown
   'need to Trim as can receive eg newc,  em instead of newc,em
   '------------------------------------------------------------------------------
   
   Dim bits As String[]
   Dim bits_branch As String[]
   Dim sql As String
   
   sql = "Select * From contacts.vwOrganisations where organisation ILIKE $$%"
   If InStr(organisation, ",") Then
      '----------------------------------------------
      'lets say user wants john hunter emergency ward
      'has typed joh,em
      '----------------------------------------------
      bits = Split(organisation, ",")
      If InStr(Trim(bits[0]), " ") Then 'mm.... someone could have typed eg john , instead of john,
         bits_branch = Split(bits[0], " ", "", True)
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "
      Else
         sql &= Trim(bits[0]) & "%$$"
      End If
      sql &= " AND branch ILIKE  $$%" & Trim(bits[1]) & "%$$ "
   Else
      '---------------------------------------------------------------------
      'user not after a head office, branch, maybe a two worded organisation
      '---------------------------------------------------------------------
      If InStr(Trim(organisation), " ") Then
         bits_branch = Split(organisation, " ", "", True)
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "
      Else
         sql &= organisation & "%$$ "
      End If
   Endif
   sql &= " AND branch_deleted is not true and organisation_deleted is not true "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub person_address_delete(pk_address As Integer)
   '---------------------------------------------------------------
   'Marks an address as deleted in the addresses table, and removes
   'the linkage in the appropriate table
   '---------------------------------------------------------------
   
   Dim sql As String
   
   If pk_address Then
      sql = "Update contacts.links_persons_addresses set deleted = TRUE  where fk_address = "
      sql &= pk_address
      modDBConnect.exec_query(sql)
      sql = "Update contacts.data_addresses set deleted = TRUE where pk = "
      sql &= pk_address
      modDBConnect.exec_query(sql)
   End If
   
End

Public Sub person_address_link(pk_person As Integer, pk_address As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_persons_addresses "
   "(fk_address,fk_person)"
   "VALUES ("
   sql &= pk_address & "," & pk_person & ")"
   modDBConnect.exec_query(sql)
   
End

Public Sub person_comm_link(pk_person As Integer, pk_comm As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_persons_comms "
   "(fk_comm,fk_person)"
   "VALUES ("
   sql &= pk_comm & "," & pk_person & ")"
   modDBConnect.exec_query(sql)
   
End

Public Sub Person_Comm_Link_Mark_Deleted(fk_person As Integer, fk_comm As Integer)
   '------------------------------------
   'Marks a comm as deleted and the link
   '------------------------------------
   
   Dim sql As String
   Dim $Result As Result
   
   sql = "UPDATE contacts.links_persons_comms SET Deleted = True "
   sql &= " WHERE fk_person =" & fk_person & " AND fk_comm = " & fk_comm
   $result = modDBConnect.exec_query(sql)
   
End

Public Function AnalyseName(searchtext As String) As String[]
   '---------------------------------------------------------------------
   'Splits the seach text into firstname, surname using this logic:
   'If input is comma separated:
   '        if two parts eg "smith, pe" assummed to be surname,firstname
   '        if one part eg "cathy," assumed to be a firstname
   'if input is space separated
   '        if one part eg "terry" assumed to be surname
   '        if two parts eg rich ter" assumed to be firstname surname
   'Returns strArray[0]=surname
   '        strArray[1]=firstname
   '---------------------------------------------------------------------
   
   Dim firstname As String
   Dim surname As String
   Dim title As String
   Dim commapos As Integer
   Dim strArray As New String[] 'was 3
   
   commapos = InStr(searchtext, ",")
   'If there is a comma in the search text
   'can be surname,firstname or firstname,
   If commapos > 0 Then
      strArray = Split(searchtext, (","))
      surname = strArray[0]
      firstname = strArray[1]
      'IF what we are assuming TO be firstname(ie what 's left after the comma is nothing"""
      If Len(firstname) = 0 Then
         strArray[1] = surname 'ie actually a fistname strArray.Add("", 1)
         strArray[0] = ""
      End If
      
   Else
      'otherwise, check if two words separated by blank
      'which we will interpret as firstname <space> surname
      If InStr(searchtext, " ") > 0 Then
         strArray = Split(searchtext, (" "))
         If strArray.count = 3 Then
            'this is not 100% accurate but will do as a start
            'two possibilities 1) Title, firstname, surname or firstname surname (as eg joe de lyall)
            If LCase(strArray[0]) = "mr" Or LCase(strArray[0]) = "mrs" Or LCase(strArray[0]) = "mst" Or LCase(strArray[0]) = "ms" Or LCase(strArray[0]) = "miss" Or LCase(strArray[0]) = "prof" Or LCase(strArray[0]) = "dr" Then
               surname = strArray[2]
               firstname = strArray[1]
               title = strArray[0]
               strArray[2] = title
               strArray[1] = firstname
               strArray[0] = surname
            Else
               surname = strArray[1] & " " & strArray[2]
               firstname = strArray[0]
               strArray[0] = surname
               strArray[1] = firstname
            End If
         Else
            surname = strArray[1]
            firstname = strArray[0]
            strArray[0] = surname
            strArray[1] = firstname
         Endif
      Else
         'othwise is just a single word, no comma, so assume a surname search
         
         strArray.Add(searchtext, 0)
         strArray.Add("", 1)
      Endif
   End If
   
   Return strArray
   
End

Public Function family_members_get(fk_family As Integer) As Result
   
   Dim sql As String
   
   sql = "select * from contacts.vwPatients WHERE fk_family=" & fk_family
   Return modDBConnect.exec_query(sql)
   
End

Public Function person_get_firstname_surname(name As String) As Result
   'FIXME BAD BAD BUGS IN HERE, INPUT NOT PARSED TO EXCLUDE UNSEARCHABLE THINGS
   'FIX AS PER FIND PATIENTS.
   
   Dim sql As String
   Dim strArrayNames As String[]
   
   strArrayNames = AnalyseName(name)
   
   sql = "SELECT PERSONS.*,TITLE.title, MARITAL.marital,SEX.sex "
   
   "FROM  contacts.data_persons PERSONS "
   "Left OUTER JOIN contacts.lu_title TITLE ON(PERSONS.fk_title = TITLE.pk) "
   "Left OUTER JOIN contacts.lu_marital MARITAL ON(PERSONS.fk_marital = MARITAL.pk) "
   "Left OUTER JOIN contacts.lu_sex SEX ON(PERSONS.fk_sex = SEX.pk) "
   "WHERE "
   "lower(surname) LIKE $$"
   sql &= Lower$(strArrayNames[0]) & "%$$ "
   sql &= "AND lower(firstname) LIKE $$"
   sql &= Lower$(strArrayNames[1]) & "%$$"
   sql &= "ORDER BY surname LIMIT 100;"
   Return modDBConnect.exec_query(sql)
   
End

Public Function Person_Get_By_Surname(txtName As String) As Collection
   '-------------------------------------------------------------------------
   'return a collection of persons by surname, either employee or sole trader
   'Called by FQuickContact, FReferrals and FCarePlanning
   'Excludes persons where are retired, deceased or left organisation
   'FIXME remove the exact same functoin from FReferrals
   '-------------------------------------------------------------------------
   
   Dim bits As New String[]
   Dim sql As String
   
   bits = Split(txtName, ",")
   sql = "Select * from contacts.vwPersonsEmployeesByOccupation WHERE  "
   If bits.count = 2 Then
      sql &= "surname ILIKE $$%" & bits[0] & "%$$ AND firstname ILIKE $$%" & bits[1] & "%$$ "
   Else
      sql &= " surname  ILIKE $$%" & txtName & "%$$ "
   Endif
   sql &= " LIMIT 60"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employees_Get_By_Occupation(soccupation As String, Optional instring_search As Boolean = True) As Collection
   '-----------------------------------------------------------------------------
   'returns collction of employees by occupation optionally by an instring search
   '-----------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from contacts.vwOrganisationsEmployees where occupation ILIKE $$"
   If instring_search Then
      sql &= "%" 
   Endif
   sql &= soccupation & "%$$ "
   sql &= "ORDER BY organisation, branch, surname"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Persons_Get_By_Occupation(sOccupation As String, Optional bInstringSearch As Boolean = True, Optional surname As String = "", Optional bExludeRetired As Boolean = False, Optional bIncludeDeceased As Boolean = False) As Collection
   '----------------------------------------------------------
   'returns collction of persons (not employees) by occupation
   'optionally an instring search
   '----------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from contacts.vwpersonsemployeesbyoccupation where occupation ILIKE $$"
   If bInstringSearch Then
      sql &= "%"
   Endif
   sql &= soccupation & "%$$ "
   SQL &= "AND fk_employee=0 "
   If surname <> "" Then
      sql &= " AND surname ILIKE $$%" & surname & "%$$"
   Endif
   If bIncludeDeceased = True Then               
      '  sql &= " AND deceased = True "
   Else
      sql &= " AND deceased = False "
   Endif
   ' If bExludeRetired Then                      'if excluding retired
   '    If bExcludeDeceased <> True Then         'but user wants to see deceased (ie true) don't include retired
   '        sql &= " AND retired = True "
   '    End If   
   ' Endif
   sql &= "ORDER BY surname, firstname"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_get_For_Organisation(fk_branch As Integer, surname As String, firstname As String) As Collection
   
   Dim sql As String
   
   sql = "Select * from contacts.vwOrganisationsEmployees where fk_branch = " & fk_branch
   sql &= " AND organisation_deleted = False and employee_deleted = false AND "
   If firstname <> "" Then
      sql &= "firstname ILIKE $$" & firstname & "$$ "
   End If
   If surname <> "" Then
      sql &= "AND surname ILIKE $$" & surname & "$$ "
   End If
   'note could be two employees of same name
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Get_By_Fk_branch_fk_person(fk_person As Integer, fk_branch As Integer) As Integer
   
   Dim R As Result
   
   R = modDBConnect.exec_query("Select fk_employee from  contacts.vwemployees where fk_person=" & fk_person & " AND fk_branch=" & fk_branch)
   If R.count Then Return R!fk_employee
   
End

Public Function Employees_Get(name As String) As Collection
   '------------------------------------------------------------
   'Gets all employees like name (expects string comma delimited
   'This one has both organisation_category and employee_category
   'only rows with employee's not with organisations and employee
   '------------------------------------------------------------
   
   Dim strArrayNames As String[]
   Dim sql As String
   
   strArrayNames = AnalyseName(name)
   sql = "SELECT * FROM contacts.vwEmployees  WHERE "
   sql &= "surname ILIKE $$" & strArrayNames[0] & "%$$ "
   sql &= "AND firstname ILIKE $$"
   sql &= strArrayNames[1] & "%$$ "
   If Not strArrayNames.count = 3 Then
      sql &= "AND title ILIKE $$"
      sql &= strArrayNames[2] & "%$$ "
   End If
   sql &= " AND organisation_deleted = False And branch_deleted = False "
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Get_By_Surname(surname As String) As Collection
   '-----------------------------------------
   'return a collection of persons by surname
   '-----------------------------------------
   
   Dim sql As String
   
   sql = "Select DISTINCT occupation, surname, firstname , fk_person  as pk_person,"
   sql &= "title || ' ' ||firstname || ' ' || surname as wholename from "
   sql &= "contacts.vwOrganisationsEmployees where surname ILIKE $$%"
   sql = sql & surname & "%$$ ORDER BY surname  LIMIT 20 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employees_In_Organisations_Find(name As String) As Collection
   '------------------------------------------------------------
   'Gets all employees like name (expects string comma delimited
   '------------------------------------------------------------
   
   Dim strArrayNames As String[]
   Dim sql As String
   
   strArrayNames = AnalyseName(name)
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees  WHERE "
   sql &= "surname ILIKE $$" & strArrayNames[0] & "%$$ "
   sql &= "AND firstname ILIKE $$"
   sql &= strArrayNames[1] & "%$$ "
   If Not strArrayNames.count = 3 Then
      sql &= "AND title ILIKE $$"
      sql &= strArrayNames[2] & "%$$ "
   End If
   sql &= " AND organisation_deleted = False And branch_deleted = False "
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Patients_Get_Temp(searchtext2 As String) As Collection
   
   Dim sql As String
   'used by my contacts patients form until ian fixes the search
   sql = "Select * from contacts.vwPatients where surname ILIKE $$" & Trim(searchtext2) & "%$$ order by surname limit 20"
   Return modDBConnect.exec_query_collection(sql)
   
End

Private Function test_regex(sRegex As String[]) As Boolean
   
   Dim sql As String
   Dim i As String
   
   If searchtext = "" Then Return False
   For Each i In sRegex
      regex = New Regexp(searchtext, i)
      If regex.Offset >= 0 Then
         searchtext = Left$(searchtext, regex.Offset) & Right$(searchtext, Len(searchtext) - Len(regex.Text) - regex.Offset)
         Return True
      Endif
   Next
   Return False
   
End

Public Function Patient_Get_Using_PK(fk_patient As Integer) As Collection
   'fixme or at least look at the implications globally, some patients have multiple addresses so without limit 1 this would bomb \
   'quick fix 05sept12 - put in limit1 whilst working on billing.
   
   Return modDBConnect.exec_query_first("Select * from contacts.vwPatients where fk_patient =" & fk_patient & "  LIMIT 1")
   
End

Public Function Patient_Get_pk_Using_Person_pk(fk_person As Integer) As Integer
   '-------------------------------------------------------------------------------
   'Get the patient's primary key for clerical.data_patients, using their fk_person
   'used during data updating in the patient import wizard
   '-------------------------------------------------------------------------------
   
   Dim sql As String
   Dim R As Result
   
   sql = "Select * From contacts.vwpatients where fk_person = " & fk_person
   If R.count Then
      Return modDBConnect.exec_query(sql)!fk_patient
   Else
      Return 0
   End If
   
End

Public Function patients_get_firstname_surname(searchtext2 As String, Optional bDeceased As Boolean = False, Optional limit As Integer = 100) As Collection
   '-------------------------------------------------------
   'Find a patient according to criteria
   'if sql criteria, use that, otherwise firstname, surname
   'fixme put in optional limit
   'first attempt at searching by query criteria FIXME UP
   '-----------------------------------------------------
   
   Dim sql As String
   Dim clauses As New String[]
   Dim tables As New String[]
   Dim sql_in_english_array As New String[]
   Dim $result As Collection
   
   searchtext = Lower$(searchtext2)
   tables.Clear
   clauses.Clear
   sql_in_english_array.Clear
   
   tables.Add("contacts.vwpatients cvwp")
   If test_regex(["(sex|gender) ?(:|=) ?(f|female|woman)"]) Then
      ' clauses.Add("cvwp.sex = 'F'")
      clauses.Add("cvwp.fk_sex =" & const.cSexFemale)
      sql_in_english_array.Add("patient is female")
   Endif
   If test_regex(["(sex|gender) ?(:|=) ?(m|male|man)"]) Then
      ' clauses.Add("cvwp.sex = 'M'")
      clauses.Add("cvwp.fk_sex = " & const.cSexMale)
      sql_in_english_array.Add("patient is male")
   Endif
   
   If test_regex(["([0-9]+) ?< ?age ?< ?([0-9]+)", "age ?> ?([0-9]+) ?< ?([0-9]+)", "age between ([0-9]+) and ([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[2].Text & " years'")
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("age is between " & regex.SubMatches[1].Text & " and " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?> ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("older than " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?< ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("younger than " & regex.SubMatches[1].Text)
   Endif
   
   ' search in the form surname, firstname
   If test_regex(["([a-z' \\-]+) ?, ?([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & Trim(regex.SubMatches[1].Text) & "%$$") 'trim eg bailey<space> **ATTENTION IAN***
      clauses.Add("lower(cvwp.firstname) like $$%" & Trim(regex.SubMatches[2].Text) & "%$$") 'RT inserted %for instring search 08Feb12
      sql_in_english_array.Add("surname begins with \"" & Trim(regex.SubMatches[1].Text) & "\"")
      sql_in_english_array.Add("firstname begins with \"" & Trim(regex.SubMatches[2].Text) & "\"")
   Endif
   
   ' search in the form firstname surname
   If test_regex(["([a-z'\\-]+) +([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[2].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$%" & regex.SubMatches[1].Text & "%$$") 'RT inserted %for instring search 08Feb12
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[2].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   
   If test_regex(["([a-z'\\-]+)"]) Then ' just the surname
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[1].text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   'ian fixme quickndirty fix because if characters like *% entered in search > crashes (do need at least the wildcard
   If clauses.count = 0 Then
      sql = "SELECT cvwp.* FROM "
      sql &= tables.Join(",")
      sql &= " WHERE surname ILIKE $$%$$ "
   Else
      sql = "SELECT cvwp.* FROM "
      sql &= tables.Join(",")
      sql &= " WHERE address_deleted is not true AND " & clauses.Join(" AND ")
   End If
   If bDeceased = False Then
      sql &= " AND deceased = false "
   Endif
   sql &= " ORDER BY surname, firstname ASC LIMIT " & limit
   Print sql
   $result = modDBConnect.exec_query_collection(sql)
   $result!sql_in_english = sql_in_english_array.Join(" and ")
   Return $result
   
End

Public Function Person_Get(searchtext2 As String, iSearchCriteria As Integer, Optional bDeceased As Boolean = False) As Collection
   '------------------------------------------------------------------------------
   'Get a list of either only patients, only non-patients or persons who are both
   '-----------------------------------------------------------------------------
   
   Dim sql As String
   Dim clauses As New String[]
   Dim tables As New String[]
   Dim sql_in_english_array As New String[]
   Dim Persons As Collection
   
   searchtext = Lower$(searchtext2)
   tables.Clear
   clauses.Clear
   sql_in_english_array.Clear
   Select Case iSearchCriteria
      Case const.contacttype_patient
         tables.Add("contacts.vwpatients cvwp")
      Case const.contacttype_person
         tables.Add("contacts.vwpersonsexcludingpatients cvwp")
      Case Else
         tables.Add("contacts.vwpersonsincludingpatients cvwp")
   End Select
   
   If test_regex(["(sex|gender) ?(:|=) ?(f|female|woman)"]) Then
      clauses.Add("cvwp.sex = 'F'")
      sql_in_english_array.Add("patient is female")
   Endif
   If test_regex(["(sex|gender) ?(:|=) ?(m|male|man)"]) Then
      clauses.Add("cvwp.sex = 'M'")
      sql_in_english_array.Add("patient is male")
   Endif
   
   If test_regex(["([0-9]+) ?< ?age ?< ?([0-9]+)", "age ?> ?([0-9]+) ?< ?([0-9]+)", "age between ([0-9]+) and ([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[1].Text & " years'")
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[0].Text & " years'")
      sql_in_english_array.Add("age is between " & regex.SubMatches[0].Text & " and " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?> ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("older than " & regex.SubMatches[0].Text)
   Endif
   
   If test_regex(["age ?< ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("younger than " & regex.SubMatches[0].Text)
   Endif
   
   ' search in the form surname, firstname
   If test_regex(["([a-z' \\-]+) ?, ?([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[1].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$" & regex.SubMatches[2].Text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[1].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[2].Text & "\"")
   Endif
   
   ' search in the form firstname surname
   If test_regex(["([a-z'\\-]+) +([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[2].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$" & regex.SubMatches[1].Text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[2].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   
   If test_regex(["([a-z'\\-]+)"]) Then ' just the surname
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[1].text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   'ian fixme quickndirty fix because if characters like *% entered in search > crashes (do need at least the wildcard
   sql = "SELECT cvwp.* FROM "
   sql &= tables.Join(",") & " WHERE "
   If bDeceased Then
      sql &= "deceased = True "
   Else
      sql &= "deceased = False "
   Endif
   
   If clauses.count = 0 Then
      sql &= " AND surname ILIKE $$%$$ "
   Else
      sql &= " AND " & clauses.Join(" AND ")
   End If
   sql &= " ORDER BY surname, firstname, fk_person DESC"
   Persons = modDBConnect.exec_query_collection(sql)
   Persons!sql_in_english = sql_in_english_array.Join(" AND ")
   Print sql
   Return Persons
   
End

Public Function Person_excluding_patients_Get_By_pk(fk_person As Integer) As Collection
   'USED IN FHL7MessagePreferences
   
   Dim sql As String
   
   sql = "Select * From contacts.vwpersonsexcludingpatients "
   sql &= "where fk_person = " & fk_person
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Person_Including_Patients_Get_Using_Pk(pk_person As Integer) As Collection
   'there are several similar in this file, don't remove without finding where used an fix DISCUSS WITH RICHARD
   
   Return modDBConnect.exec_query_first("Select * from contacts.vwpersonsincludingpatients where fk_person = " & pk_person)
   
End

Public Function Get_Town(town As String, Optional wildcard_search As Boolean = False, Optional LIMIT As Integer = 20) As Collection
   
   Dim sql As String
   
   sql = "SELECT * from contacts.lu_towns WHERE town ILIKE $$"
   If wildcard_search Then
      sql &= "%"
   Endif
   sql &= town & "%$$ order by town  LIMIT " & LIMIT
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub Employee_Delete(fk_person As Integer, fk_branch As Integer)
   
   modDBConnect.exec_query("Update contacts.data_employees set deleted = True where fk_person = " & fk_person & " AND fk_branch = " & fk_branch)
   
End

Public Function Employee_Save(old_data As Collection, pk_view As String, person As Collection, employee As Collection, comms As Collection, views_comms As Collection) As Collection ', old_comms As collection) As collection
   '--------------------------------------------
   'Saves an employee in an organisation
   'Nothing in the organisation can have changed
   '--------------------------------------------
   
   Dim comm As Collection
   Dim collection_to_return As New Collection
   Dim sql As String
   '-------------------------------------------------------
   'does the firstname exist in the fistnames table?
   'FIXME PUT IN THE CODE, BUT WHAT ABOUT SPELLING mistakes
   '-------------------------------------------------------
   If IsNull(person!fk_person) Then
      person!fk_person = modDBConnect.insert("contacts.data_persons", person)
   Else
      '------------------------------------------------------------------------------------
      'As there is no associated 'old-data' for a person cannot use this:
      ' modDBConnect.update("contacts.data_persons", old_data[pk_view], person, "fk_person")
      ' so am doing it the 'old way'
      modDBConnect.update("contacts.data_persons", old_data[pk_view], person, "fk_person")
   End If
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         person_Comm_Link(person!fk_person, comm!pk)
      Else
         comm.Remove("fk_person")
         modDBConnect.update("contacts.data_communications", views_comms[comm!pk], comm, "pk")
      End If
   Next
   '---------------------------------
   'Save any new employee occupations
   '---------------------------------
   If IsNull(employee!fk_occupation) Then
      employee!fk_occupation = modCommonDBI.Occupation_Save(employee!occupation)
   End If
   Try employee.remove("occupation")
   '-----------------------------------------
   'Next check if the employee already exists
   '-----------------------------------------
   If IsNull(employee!fk_employee) Then
      employee!fk_person = person!fk_person
      employee!fk_employee = modDBConnect.insert("contacts.data_employees", employee)
   Else
      modDBConnect.update("contacts.data_employees", old_data[pk_view], employee, "fk_employee")
   End If
   '-------------------------------------------
   'Saves communications for branch or employee
   '--------------------------------------------
   ' For Each comm In comms
   '    Try comm.Remove("type") 'was needed for display in editing
   '    If IsNull(comm!pk) Then
   '       comm!pk = modDBConnect.insert("contacts.data_communications", comm)
   '       Employee_Comm_Link(employee!fk_employee, comm!pk)
   '    Else
   '       modDBConnect.update("contacts.data_communications", old_comms[pk_view], comm, "pk")
   '    End If
   ' Next
   
   '--------------------------------------------------------------------------------
   'Now, if the employee is a staff member = for us, a database user, deal with that
   '--------------------------------------------------------------------------------
   ' modDBConnect.CommitTrans()
   '--------------------------------------------------------------------
   'These three keys identify a row, and will be used to restore the row
   '--------------------------------------------------------------------
   ' collection_to_return.Add(organisation!fk_organisation, "fk_organisation")
   ' collection_to_return.Add(branch!fk_branch, "fk_branch")
   ' If Not IsNull(employee) Then
   '   collection_to_return.Add(employee!fk_employee, "fk_employee")
   ' End If
   collection_to_return!fk_person = person!fk_person
   collection_to_return!fk_employee = employee!fk_employee
   'this will break contacts - fixme
   Return collection_to_return
   
End

Public Function organisation_save(old_data_organisation As Collection, old_pk As Integer, organisation As Collection, branch As Collection, address As Collection, comms As Collection, old_comms As Collection) As Collection
   '-------------------------------------------------------------------------
   'Saves an organisation +/- its branch, address, communications
   'First save any previously unkown fields for which we need the key
   'COMMENTS:  Note all fields needed for user to make sense of gui but not
   '           needed in the data tables are removed like this:
   '           Try collection.remove("field")
   '--------------------------------------------------------------------------
   
   Dim comm As Collection
   Dim collection_to_return As New Collection
   
   If IsNull(organisation!fk_organisation) Then
      organisation!fk_organisation = modDBConnect.insert("contacts.data_organisations", organisation)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      modDBConnect.update("contacts.data_organisations", old_data_organisation[old_pk], organisation, "fk_organisation")
   End If
   '-------------------------------------
   'Address: create new or change details
   '-------------------------------------
   If Not IsNull(address) Then
      If IsNull(address!fk_address) Then
         '--------------------------------------------------------------------------------
         'Thought there may be an address collection, the user may have put nothing in it
         '-------------------------------------------------------------------------------
         '-------------------
         'Create a new address
         '-------------------
         address!fk_address = modDBConnect.insert("contacts.data_addresses", address)
      Else
         '-------------------------------
         'change existing address details
         '-------------------------------
         Try address.Remove("town")
         Try address.Remove("postcode")
         Try address.Remove("state")
         modDBConnect.update("contacts.data_addresses", old_data_organisation[old_pk], address, "fk_address")
      End If
   End If
   '--------------------------------------------
   'Branch: create new or change details
   '        first save its category if necessary
   '--------------------------------------------
   If IsNull(branch!fk_category) Then
      branch!fk_category = Category_Save(branch!category)
   End If
   Try branch.Remove("category")
   
   If IsNull(branch!fk_branch) Then
      '-------------------
      'Create a new branch
      '-------------------
      Try branch!fk_address = address!fk_address  'may not have an address
      branch!fk_organisation = organisation!fk_organisation
      branch!fk_branch = modDBConnect.insert("contacts.data_branches", branch)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      modDBConnect.update("contacts.data_branches", old_data_organisation[old_pk], branch, "fk_branch")
   End If
   
   '-------------------------------------------
   'Saves communications for branch or employee
   '--------------------------------------------
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         Branch_Comm_Link(branch!fk_branch, comm!pk)
      Else
         comm.Remove("fk_branch")
         modDBConnect.update("contacts.data_communications", old_comms[old_pk], comm, "pk")
         
      End If
   Next
   'Now save the default clinic to the admin.clinics table
   
   modDBConnect.CommitTrans()
   '--------------------------------------------------------------------
   'These two keys identify a row, and will be used to restore the row
   '--------------------------------------------------------------------
   collection_to_return.Add(organisation!fk_organisation, "fk_organisation")
   collection_to_return.Add(branch!fk_branch, "fk_branch")
   Return collection_to_return
   
End

Public Function Org_save(old_data_organisation As Collection, old_pk As Integer, organisation As Collection, branch As Collection, address As Collection, comms As Collection, old_comms As Collection, clinic As Collection) As Collection
   '-------------------------------------------------------------------------
   'Saves an organisation +/- its branch, address, communications
   'First save any previously unkown fields for which we need the key
   'COMMENTS:  Note all fields needed for user to make sense of gui but not
   '           needed in the data tables are removed like this:
   '           Try collection.remove("field")
   '--------------------------------------------------------------------------
   
   Dim comm As Collection
   Dim collection_to_return As New Collection
   
   '------------------------------------------
   'Organisation: create new or change details
   '------------------------------------------
   If IsNull(organisation!fk_organisation) Then
      organisation!fk_organisation = modDBConnect.insert("contacts.data_organisations", organisation)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      modDBConnect.update("contacts.data_organisations", old_data_organisation[old_pk], organisation, "fk_organisation")
   End If
   '-------------------------------------
   'Address: create new or change details
   '-------------------------------------
   If Not IsNull(address) Then
      If IsNull(address!fk_address) Then
         '--------------------------------------------------------------------------------
         'Thought there may be an address collection, the user may have put nothing in it
         '-------------------------------------------------------------------------------
         '-------------------
         'Create a new address
         '-------------------
         address!fk_address = modDBConnect.insert("contacts.data_addresses", address)
      Else
         '-------------------------------
         'change existing address details
         '-------------------------------
         Try address.Remove("town")
         Try address.Remove("postcode")
         Try address.Remove("state")
         modDBConnect.update("contacts.data_addresses", old_data_organisation[old_pk], address, "fk_address")
      End If
   End If
   '--------------------------------------------
   'Branch: create new or change details
   '        first save its category if necessary
   '--------------------------------------------
   If IsNull(branch!fk_category) Then
      branch!fk_category = Category_Save(branch!category)
   End If
   Try branch.Remove("category")
   
   If IsNull(branch!fk_branch) Then
      '-------------------
      'Create a new branch
      '-------------------
      Try branch!fk_address = address!fk_address  'may not have an address
      branch!fk_organisation = organisation!fk_organisation
      branch!fk_branch = modDBConnect.insert("contacts.data_branches", branch)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      Try branch!fk_address = address!fk_address  'may now have an address
      modDBConnect.update("contacts.data_branches", old_data_organisation[old_pk], branch, "fk_branch")
   End If
   '-------------------------------------------
   'Saves communications for branch or employee
   '--------------------------------------------
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         Branch_Comm_Link(branch!fk_branch, comm!pk)
      Else
         comm.Remove("fk_branch")
         modDBConnect.update("contacts.data_communications", old_comms[comm!pk], comm, "pk")
      End If
   Next
   
   '-------------------------------------
   'Now save or modify the clinic details
   '-------------------------------------
   If Not IsNull(clinic) Then
      If clinic!fk_clinic = 0 Then  ' And clinic!default_clinic Then
         Try clinic.remove("fk_clinic")
         Try clinic.Remove("default_clinic")
         clinic!fk_branch = branch!fk_branch
         clinic!fk_clinic = modDBConnect.insert("admin.clinics", clinic)
      End If
   End If
   '--------------------------------------------------------------------
   'These two keys identify a row, and will be used to restore the row
   '--------------------------------------------------------------------
   collection_to_return.Add(organisation!fk_organisation, "fk_organisation")
   collection_to_return.Add(branch!fk_branch, "fk_branch")
   collection_to_return.Add(branch!fk_category, "fk_category") 'FIXME MAKE ME LOGICAL
   Return collection_to_return
   
End

Public Function Organisations_Employees_Get_By_Keys(Optional fk_organisation As Integer = 0, Optional fk_branch As Integer = 0, Optional fk_employee As Integer = 0, Optional no_fax As Boolean = False) As Collection
   
   Dim sql As String
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees WHERE "
   If fk_employee <> 0 Then
      sql &= " fk_employee = " & fk_employee
   Else
      If fk_organisation <> 0 Then sql &= "fk_organisation = " & fk_organisation
      If fk_branch <> 0 And fk_organisation <> 0 Then sql &= " AND "
      If fk_branch <> 0 Then sql &= " fk_branch = " & fk_branch
   Endif
   sql &= " And employee_deleted is not true "
   If no_fax Then
      sql &= " AND fax is null "
   Endif
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub Branch_Comm_Link(fk_branch As Integer, pk_comm As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_branches_comms "
   "(fk_comm,fk_branch)"
   "VALUES ("
   sql &= pk_comm & "," & fk_branch & ")"
   modDBConnect.exec_query(sql)
   
End

Public Sub Branch_Comm_Link_Mark_Deleted(fk_branch As Integer, fk_comm As Integer)
   '------------------------------------
   'Marks a comm as deleted and the link
   '------------------------------------
   
   Dim sql As String
   Dim $Result As Result
   
   sql = "UPDATE contacts.links_branches_comms SET Deleted = True "
   sql &= " WHERE fk_branch =" & fk_branch & " AND fk_comm = " & fk_comm
   $result = modDBConnect.exec_query(sql)
   
End

Public Function Misspelt_towns_Get(town As String) As Collection
   '---------------------------------------------------------------
   'Called by FImportPatients.PatientCreate if a suburb match fails
   'This may have occurred previously
   '---------------------------------------------------------------
   
   Return modDBConnect.exec_query_first("select * from contacts.lu_misspelt_towns where town_misspelt ILIKE $$" & town & "$$")
   
End

Public Sub Set_Numbers(fk_person As Integer, fk_branch As Integer, provider_number As String, Optional prescriber_number As String)
   
   Dim res As Result
   Dim sql As String
   
   Message.Info("Stop richard, using modContacsDBI.set_numbers should not be possible")
   Return 
   
End

Public Sub Set_Numbers_new(fk_person As Integer, fk_branch As Integer, provider_number As String, Optional prescriber_number As String, Optional australian_business_number As String, Optional hpio As String, Optional hpii As String)
   'Update the data numbers table:
   ' CREATE TABLE contacts.data_numbers
   ' (
   '   fk_person integer,
   '   fk_branch integer, -- can be NULL for individuals in solo practices who aren't part of an 'organisation' in our system.
   '   provider_number text, -- the Medicare Australia alphanumeric provider number.
   '   prescriber_number text,
   '   australian_business_number text,
   '   pk serial NOT NULL,
   '   hpio text, -- Health Provider Identifier - Organisation
   '   hpii text, -- Health Provider Identifier - Individual
   '   CONSTRAINT data_numbers_pkey PRIMARY KEY (pk ),
   '   CONSTRAINT data_numbers_fk_branch_fkey FOREIGN KEY (fk_branch)
   '       REFERENCES contacts.data_branches (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '   CONSTRAINT data_numbers_fk_person_fkey FOREIGN KEY (fk_person)
   '       REFERENCES contacts.data_persons (pk) MATCH SIMPLE
   '       ON UPDATE NO ACTION ON DELETE NO ACTION,
   '   CONSTRAINT data_numbers_hpii_check CHECK (hpii ~ '^[0-9]+$'::text),
   '   CONSTRAINT data_numbers_hpio_check CHECK (hpio ~ '^[0-9]+$'::text),
   '   CONSTRAINT employees_no_hpio CHECK (NOT (hpio IS NOT NULL AND fk_person IS NOT NULL AND fk_branch IS NOT NULL)),
   '   CONSTRAINT one_of_branch_person CHECK (NOT (fk_branch IS NULL AND fk_person IS NULL)),
   '   CONSTRAINT orgs_no_hpii CHECK (NOT (hpii IS NOT NULL AND fk_person IS NULL))
   ' )
   ' WITH (
   '   OIDS=FALSE
   ' );
   
   Dim res As Result
   Dim sql As String
   
   Message.Info("Stop richard, using modContacsDBI.set_numbers should not be possible")
   Return 
   If fk_branch = 0 Then           'if we are dealing with an sole tradeer/person not in organisation, get existing numbers
      res = modDBConnect.exec_query("select * from contacts.data_numbers where fk_person = &1 and fk_branch is null", [fk_person])
   Else                            'we are dealing with an employee
      res = modDBConnect.exec_query("select * from contacts.data_numbers where fk_person = &1 and fk_branch = &2", [fk_person, fk_branch])
   Endif
   
   If res.count = 0 Then           'found no current entries?, add as appropriate
      If fk_branch < 1 Then fk_branch = Null
      If prescriber_number = "" Then prescriber_number = Null
      If provider_number = "" Then provider_number = Null
      If hpio = "" Then hpio = Null
      If hpii = "" Then hpii = Null
      If australian_business_number = "" Then australian_business_number = Null
      If IsNull(provider_number) And IsNull(prescriber_number) Then Return
      modDBConnect.insert("contacts.data_numbers", ["fk_person": fk_person, "fk_branch": fk_branch, "provider_number": provider_number, "prescriber_number": prescriber_number, "australian_business_number": australian_business_number, "hpii": hpii, "hpio": hpio], Null)
   Else                             'data does exist for this person or employee
      If IsNull(prescriber_number) Or If prescriber_number = "" Then
         prescriber_number = "NULL"
      Else
         prescriber_number = "'" & prescriber_number & "'"
      Endif
      If IsNull(prescriber_number) Or If provider_number = "" Then
         provider_number = "NULL"
      Else
         provider_number = "'" & provider_number & "'"
      Endif
      If IsNull(australian_business_number) Or If australian_business_number = "" Then
         australian_business_number = "NULL"
      Else
         australian_business_number = "'" & australian_business_number & "'"
      Endif
      If IsNull(hpii) Or If hpii = "" Then
         hpii = "NULL"
      Else
         hpii = "'" & hpii & "'"
      Endif  
      If IsNull(hpio) Or If hpio = "" Then
         hpio = "NULL"
      Else
         hpio = "'" & hpio & "'"
      Endif  
      
      If IsNull(fk_branch) Or If fk_branch < 1 Then
         sql = "fk_branch is null"
      Else
         sql = "fk_branch = " & fk_branch
      Endif
      If provider_number = "NULL" And If prescriber_number = "NULL" Then
         sql = Subst$("delete from contacts.data_numbers where fk_person = &1 and &2", fk_person, sql)
      Else
         '**WRONG RICHARD***
         sql = Subst$("update contacts.data_numbers set provider_number=&1, prescriber_number=&2, australian_business_number=&3, hpii = &4, hpio =&5 where fk_person=&3 and &4", provider_number, prescriber_number, fk_person, sql)
      Endif
      modDBConnect.exec_query(sql)
   Endif
   
End

Public Sub Australian_Business_Number_Validate(abn As String) As String
   '------------------------------------------------------------------------------
   'Validate_ABN returns the same ABN(minus spaces) If it Is Valid, Null otherwise
   'Implements the ATO 's check algorithm
   '------------------------------------------------------------------------------
   
   Dim total As Integer = 0
   Dim i As Integer
   Dim magic As Integer[] = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
   
   abn = Replace$(abn, " ", "")
   abn = Replace$(abn, "-", "")
   If Len(abn) <> 11 Then Return Null
   total = (CInt(Left$(abn, 1)) - 1) * magic[0]
   For i = 1 To 10
      total += CInt(Mid$(abn, i + 1, 1)) * magic[i]
   Next
   If total Mod 89 = 0 Then Return abn
   Return Null
   
End

Public Sub Australian_Business_Number_Display(abn As String) As String
   '-------------------------------------------------------------------------
   ' Display_ABN takes a spaceless ABN And inserts 3 spaces at positions 2, 5
   ' And 8 Like the ATO website has.
   '-------------------------------------------------------------------------- 

   If Len(abn) <> 11 Then Error.Raise("ABN must be 11 digits")
  Return Left$(abn, 2) & " " & Mid$(abn, 3, 3) & " " & Mid$(abn, 6, 3) & " " & Mid$(abn, 9, 3)
  
End
