' Gambas module file

' Copyright (C) 2008-2012 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'----------------------------------------------------------------------
Public sSubroutineName As String
Private searchtext As String
Private regex As Regexp

Public Sub Communication_UnDelete(pk As Integer)
   'Un-deletes a communication, returns non-zero if succeeded
   
   modDBConnect.exec_query("Update contacts.data_communications set deleted = False where pk =" & pk)
   
End

Public Function Towns_Get() As Collection
   '------------------------------------------------------------------------
   ' Return a collection of all Towns/localities or whatever you'd call them
   ' vwTowns is ordered alphabetically
   '------------------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("select * from contacts.vwTowns")
   
End

Public Function firstname_add(firstname As String, sex As String) As Integer
   
   Dim res As Integer
   Dim sql As String
   Dim $result As Result
   
   res = 4999
   sql = "select max(ord) as pk_firstname from contacts.lu_firstnames"
   $result = modDBConnect.exec_query(sql)
   res = $Result!pk_firstname 
   sql = "Insert into contacts.lu_firstnames(firstname, ord, sex) Values($$"
   sql &= firstname & "$$," & res
   sql &= ",$$" & sex & "$$)"
   $result = modDBConnect.exec_query(sql)     
   Return 1 
   
End

Public Function Firstname_Get(name As String) As Collection
   
   Dim sql As String
   
   sql = "SELECT distinct pk, firstname, sex FROM contacts.lu_firstnames WHERE lower (firstname) LIKE $$" 
   sql &= Lower$(name) & "%$$  LIMIT 10"
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function find_surname(name As String) As Result
   
   Dim sql As String
   Dim $dataset As Result
   
   sql = "SELECT * "
   "FROM "
   "contacts.lu_surnames "
   "WHERE "
   " lower (surname) LIKE $$" 
   sql &= Lower$(name) & "%$$  LIMIT 20"
   $dataset = modDBConnect.exec_query(sql)
   Return $dataset           
   
End

Public Function Get_Category(category As String) As Collection 
   
   Return modDBConnect.exec_query_collection("SELECT * FROM contacts.lu_categories WHERE category ILIKE $$%" & category & "%$$  LIMIT 20")         
   
End

Public Function Category_Save(category As String) As Integer
   '----------------------------------------------
   'Inserts a category into contacts.lu_categories
   '----------------------------------------------
   
   Dim $Result As Result
   
   $Result = modDBConnect.exec_query("INSERT INTO contacts.lu_categories (category) VALUES($$" & category & "$$) returning pk")
   Return $Result!pk
   
End

Public Function Language_Get(language As String) As Collection 
   
   Return modDBConnect.exec_query_collection("SELECT *   FROM common.lu_languages WHERE  lower (language) ILIKE $$" & Lower$(language) & "%$$  LIMIT 20")
   
End

Public Function Ethnicity_Get(ethnicity As String) As Collection 
   
   Return modDBConnect.exec_query_collection("SELECT * FROM common.lu_ethnicity WHERE ethnicity ILIKE $$" & ethnicity & "%$$  LIMIT 20")
   
End

Public Function Country_Get(country As String) As Collection 
   
   Return modDBConnect.exec_query_collection("SELECT * FROM common.lu_countries WHERE lower (country) ILIKE $$" & Lower(country) & "%$$ LIMIT 10")
   
End

Public Function get_last_person_pk() As Integer
   'fetches the last person's pk inserted into the database
   
   Dim sql As String
   Dim $dataset As Result
   
   sql = "select * from contacts.data_persons where pk = currval('contacts.data_persons_pk_seq')"
   $dataset = modDBConnect.exec_query(sql)
   Return $dataset!pk           
   
End

Public Function get_last_family_pk() As Integer
   
End 

Public Sub Person_Addresses_Save(old_data As Collection, pk_view_address As Variant, addresses As Collection, person As Collection) 
   
   Dim address As Collection
   '-------------------------------------
   'Address: create new or change details
   '-------------------------------------
   For Each Address In addresses
      If Not IsNull(address) Then
         If IsNull(address!fk_address) Then
            '--------------------
            'Create a new address
            '--------------------
            address!fk_address = modDBConnect.insert("contacts.data_addresses", address)
            person_address_link(person!fk_person, address!fk_address)
            
         Else
            '-------------------------------
            'change existing address details
            '-------------------------------
            Try address.Remove("town")
            Try address.Remove("postcode")
            Try address.Remove("state")
            modDBConnect.update("contacts.data_addresses", old_data[address!fk_address], address, "fk_address")
         End If
      End If  
   Next
   
End

Public Function person_addresses_get(fk_person As Integer) As Collection
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwPersonsAddresses where fk_person = " & fk_person)
   
End

Public Function person_comms_get(fk_person As Integer) As Collection
   
   Return modDBConnect.exec_query_collection("Select * From contacts.vwpersonscomms where fk_person = " & fk_person & " And deleted = False")
   
End

Public Sub Employee_Comm_Link(fk_employee As Integer, pk_comm As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_employees_comms "
   "(fk_employee,fk_comm)"
   "VALUES ("
   sql &= fk_employee & "," & pk_comm & ")"
   modDBConnect.exec_query(sql)  
   
End

Public Function Employee_Get(surname As String) As Collection
   
   Dim sql As String
   
   sql = " Select * From contacts.vwOrganisationsEmployees where surname ILIKE $$"
   sql &= Trim(surname) & "%$$ ORDER BY surname, firstname, category"  
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_get_memo(fk_organisation As Integer, fk_branch As Integer, fk_person As Integer) As Collection 
   
   Dim sql As String 
   
   sql = "Select * From contacts.vwOrganisationsEmployees WHERE "
   sql &= "fk_organisation = " & fk_organisation 
   sql &= " AND fk_branch = " & fk_branch
   sql &= " AND fk_person = " & fk_person
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Get_With_Memo_Like(surname As String, memo As String, Optional sex As Integer = const.cSexUnknown) As Collection
   '--------------------------------------------------------------------
   'I am arbitrarily allowing searching on multiple things eg anger;sex;
   '--------------------------------------------------------------------
   
   Dim sql As String
   Dim searchitems As String[]
   Dim item As String   
   Dim x As Integer
   
   searchitems = Split(memo, ";", "", True)
   
   sql = "Select * From contacts.vwOrganisationsEmployees where surname ILIKE $$"
   sql &= Trim(surname) & "%$$ " 
   If sex <> const.cSexUnknown Then
      sql &= "AND fk_sex = " & sex & " " 
   End If
   
   For x = 0 To searchitems.count - 1 
      
      sql &= "AND memo ILIKE $$%" & searchitems[x] & "%$$ "
      
   Next
   sql &= "ORDER BY surname, firstname, category"  
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Clinic_Save(clinic As Collection) As Integer   
   '-------------------------------
   'save branch address as a clinic
   '-------------------------------
   
   If IsNull(clinic!fk_clinic) Then
      clinic!fk_clinic = modDBConnect.insert("admin.clinics", clinic)
   Else
   End If
   modDBConnect.CommitTrans()
   Return clinic!fk_clinic
   
End

Public Function Staff_Exists() As Boolean
   'checks if any staff yet exists
   
   If modDBConnect.exec_query("select count(*) from admin.staff")!count Then
      Return True
   Else
      Return False
   End If   
   
End

Public Function Staff_Member_Save(old_data As Collection, pk_view As String, staff As Collection, employees_place_of_work As Collection) As Integer
   '----------------------------------------------------
   'Saves or changes a staff member with particular role
   'easygp the only one who can add new staff members
   '(unless of course you are a superuser!)
   '----------------------------------------------------
   
   Dim $Result As Result
   Dim sql As String
   Dim role As String
   'this is temporary IAN FIXME.
   Select Case staff!fk_role
      Case const.StaffRole_SysAdmin
         role = "easygp"
      Case Else
         role = "staff"
   End Select
   If IsNull(staff!fk_staff) Then
      '----------------------------------------------------
      'New staff member? add as user with selected password
      '----------------------------------------------------
      If Not modDBConnect.Role_Check_If_Exists(staff!logon_name) Then
         sql = "CREATE USER  \"" & staff!logon_name & "\" PASSWORD $$" & staff!password & "$$ IN ROLE " & role
         If Not (IsNull(staff!logon_date_to)) Then
            sql &= " VALID UNTIL '" & Format$(staff!logon_date_to, "dd/mm/yyyy") & "'"
         End If   
         $Result = modDBConnect.exec_query(sql)
         sql = "GRANT staff to \"" & staff!logon_name & "\""
         $Result = modDBConnect.exec_query(sql)
     End If
      '------------------------------------
      'Now create the user as a EasyGP user
      '------------------------------------
      staff.remove("password") ' don't save password in table 
      staff!fk_staff = modDBConnect.insert("admin.staff", staff)
      '---------------------------------------
      'now link the staff member to the clinic
      '---------------------------------------
      employees_place_of_work!fk_staff = staff!fk_staff
      employees_place_of_work!fk_link_staff_clinic = modDBConnect.insert("admin.link_staff_clinics", employees_place_of_work)
   Else
      '------------------------------------------------------------
      'An existing user
      '------------------------------------------------------------
      If staff!logon_name <> old_data[pk_view]!logon_name Then
         sql = "ALTER ROLE \"&1\" RENAME TO \"&2\""
         sql = Subst$(sql, old_data[pk_view]!logon_name, staff!logon_name)
         modDBConnect.exec_query(sql)
      Endif 
      If staff!logon_date_to <> old_data[pk_view]!logon_date_to Then
         sql = "ALTER ROLE \"&1\" VALID UNTIL '&2'"
         sql = Subst$(sql, staff!logon_name, Format$(staff!logon_date_to, "dd/mm/yyyy"))
         modDBConnect.exec_query(sql)
      Endif
      If staff.Exist("password") And If staff!password <> "" Then
         sql = "ALTER ROLE \"&1\" WITH PASSWORD '&2'"
         sql = Subst$(sql, staff!logon_name, staff!password)
         modDBConnect.exec_query(sql)
         staff.Remove("password") ' password not stored anywhere else
      Endif
      modDBConnect.update("admin.staff", old_data[pk_view], staff, "fk_staff")
      modDBConnect.update("admin.link_staff_clinics", old_data[pk_view], employees_place_of_work, "fk_link_staff_clinic")
   End If
   Return staff!fk_staff
   
End

Public Function Staff_Status_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from admin.lu_staff_status")
   
End

Public Function Image_Save(The_Image As Collection, Optional fk_consult As Integer) As Integer
   '-------------------------------------------------------------
   'Saves an image, usually a persons picture  returns its pk
   'Fixme - move Iamge_Save from modconsultDBI to somewhere else
   '------------------------------------------------------------- 
   
   If IsNull(The_Image!fk_image) Then
      Return modConsultDBI.Image_Save(The_Image!path, fk_consult, modUtil.Calc_md5sum_File(The_Image!path))
   Else
      ' Message.Info("STOP: BUG HERE")
      Return The_Image!fk_image 'fixme allow editing
      '   Return modConsultDBI.Image_Save(The_Image!path, The_Image!fk_image)
   End If
   
End

Public Function Patients_Erase()
   '----------------------------------------------------
   'Wipes the entire patient database
   'As Yet does'nt cascade to person as I've not put in
   'referential integrity, not wipes any data
   'just using this during import practice
   '-----------------------------------------------------
   
   Dim sql As String
   Dim $result As Result
   
   sql = "Delete from clerical.data_patients"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "Delete from clerical.data_family_members"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "Delete from clerical.data_families"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "ALTER SEQUENCE clerical.data_patients_pk_seq"
   "    INCREMENT 1  MINVALUE 1"
   "    MAXVALUE 9223372036854775807  RESTART 1"
   "    CACHE 1  NO CYCLE"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "ALTER SEQUENCE clerical.data_family_members_pk_seq"
   "    INCREMENT 1  MINVALUE 1"
   "    MAXVALUE 9223372036854775807  RESTART 1"
   "    CACHE 1  NO CYCLE"
   $Result = modDBConnect.exec_query(sql)
   
   sql = "ALTER SEQUENCE clerical.data_families_pk_seq "
   " INCREMENT 1  MINVALUE 1 "
   " MAXVALUE 9223372036854775807  RESTART 1 "
   " CACHE 1  NO CYCLE"
   $Result = modDBConnect.exec_query(sql)
   
End

Public Function Person_Save(old_data As Collection, old_pk As String, person As Collection, comms As Collection, old_comms As Collection) As Integer
   '---------------------
   'First, the occupation
   '---------------------
   
   Dim comm As Collection 
   
   If IsNull(person!fk_occupation) And (Not IsNull(person!occupation)) Then
      person!fk_occupation = Occupation_Save(person!occupation)
      person.Remove("occupation")
   End If
   If IsNull(person!fk_category) And (Not IsNull(person!category)) Then
      person!fk_category = Category_Save(person!category)
   End If
   Try person.Remove("category")
   '-------------------------
   'Save or modify the person
   '-------------------------
   If IsNull(person!fk_person) Then
      person!fk_person = modDBConnect.insert("contacts.data_persons", person)
   Else
      modDBConnect.update("contacts.data_persons", old_data[old_pk], person, "fk_person")
   End If
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         person_Comm_Link(person!fk_person, comm!pk)
      Else
         modDBConnect.update("contacts.data_communications", old_comms[comm!pk], comm, "pk")
      End If
   Next
   Return person!fk_person
   
End

Public Function Patient_Save(old_data_patient As Collection, old_pk As String, patient As Collection) As Integer ', person As collection, comms As collection, old_comms As collection) As Integer
   '---------------------------------------------
   'Saves or updates a patient
   'FIXME - PUT IN VALIDATION THAT NOT DUPLICATED
   '---------------------------------------------
   
   Dim comm As Collection 
   Dim family As Collection 
   Dim collection_to_return As New Collection 
   '-------------------------------
   'Save occupation if not existing
   '------------------------------- 
   ' If IsNull(patient!fk_occupation) And (Not IsNull(patient!occupation)) Then
   '     patient!fk_occupation = Occupation_Save(patient!occupation)
   '     patient.Remove("occupation")
   ' End If
   '-------------------------------
   'A Patient is firstly a person
   '------------------------------
   ' If IsNull(person!fk_person) Then
   '       person!fk_person = modDBConnect.insert("contacts.data_persons", person)
   ' Else
   '      modDBConnect.update("contacts.data_persons", old_data_patient[old_pk], person, "fk_person")
   ' End If
   '-------------------------------------------
   'Saves communications for patient
   '--------------------------------------------
   ' For Each comm In comms
   '    Try comm.Remove("type") 'was needed for display in editing
   '    If IsNull(comm!pk) Then
   '       comm!pk = modDBConnect.insert("contacts.data_communications", comm)
   '       person_Comm_Link(person!fk_person, comm!pk)
   '   
   '    Else
   '       modDBConnect.update("contacts.data_communications", old_comms[comm!pk], comm, "pk")
   '    End If
   ' Next
   ' 'Ok, finished with person specific stuff. in a minute split this routine
   '-------------------------------
   'Now, make this person a patient
   '-------------------------------
   If IsNull(patient!fk_patient) Then
      ' patient!fk_person = person!fk_person
      patient!fk_patient = modDBConnect.insert("clerical.data_patients", patient)
      If IsNull(patient!fk_family) Then
         '-------------------------------------------------------------
         'A family gets a single pk and as long as family members exist
         'then disbanded = False
         '-------------------------------------------------------------
         family = New Collection
         family!disbanded = False
         family!fk_family = modDBConnect.insert("clerical.data_families", family)
         family.Remove("disbanded")
         'havn't checked this - should it be fk-patient or fk_person
         family!fk_patient = patient!fk_patient 
         'this name has no meaning here
         family!fk_family = modDBConnect.insert("clerical.data_family_members", family)
         '-----------------------------------------------------------------
         ' now insert this into data_family_members, with the patient key
         '-----------------------------------------------------------------
      End If
   Else
      modDBConnect.update("clerical.data_patients", old_data_patient[old_pk], patient, "fk_patient")
      
   End If
   
   Return patient!fk_patient
   
End

Public Function Employee_Comms_Get(fk_employee As Integer) As Collection
   
   Dim sql As String
   
   sql = "Select " 
   " COMMS.pk ,"
   " COMMS.value,"
   " COMMS.note,"
   " COMMS.preferred_method,"
   " COMMS.confidential,"
   " COMMS.deleted,"
   " COMMS.fk_type, "
   " TYPES.type"
   " From "
   " contacts.data_communications COMMS "
   " INNER JOIN contacts.links_employees_comms ON(COMMS.pk = contacts.links_employees_comms.fk_comm) "
   "  INNER JOIN contacts.lu_contact_type TYPES ON(COMMS.fk_type = TYPES.pk) "
   "WHERE "
   sql &= "contacts.links_employees_comms.fk_employee = " & fk_employee
   
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Branch_Comms_Get(fk_branch As Integer) As Collection
   '-------------------------------------------------------------------
   'Fetch all communications or contact information for a single branch
   '-------------------------------------------------------------------  
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwBranchesComms where fk_branch =" & fk_branch)
   
End

Public Function Employees_All_Locations_get(pk_person As Integer) As Result
   '--------------------------------------------------------------------------
   'Filters record on employee, note must be on pk_person as each location
   'has a different pk_employee as they are employed by distinct organisations
   'or branches
   '--------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees "
   "WHERE "
   sql &= " pk_person =" & pk_person 
   sql &= " AND organisation_deleted = False And branch_deleted = False "
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query(sql)
   
End

Public Function Clinics_Get() As Collection
   '---------------------------------------------------
   'Returns a collection of clinics in our organisation
   '---------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * from admin.vwClinics")
   
End

Public Function Staff_Get(Optional surname As String) As Collection 
   '----------------------------------------------------------------------------------
   'Return a collection of staff(or member)  in our organisation. This is not the same
   'as employees in an organisation but specific to the practice running EasyGP
   '----------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = "Select * from admin.vwStaffInClinics "
   If surname Then
      sql &= " WHERE surname ILIKE $$%" & surname & "%$$"
   Endif
   Return modDBConnect.exec_query_collection(sql)
   
End 

Public Function Unmatched_Staff_Get() As Collection
   
   Return modDBConnect.exec_query_collection("Select * from documents.unmatched_staff where fk_real_staff is null")
   
End

Public Function Organisations_Employees_Get(organisation As String, Optional limit As Integer = 0) As Collection
   '-----------------------------------------------------------
   'PURPOSE    Get a list of organisations and their employee's
   '-----------------------------------------------------------

   Dim bits As String[]
   Dim bits_branch As String[]
   Dim sql As String 
   
   sql = "Select * From contacts.vwOrganisationsEmployees where organisation ILIKE $$%"
   If InStr(organisation, ",") Then
      '----------------------------------------------      
      'lets say user wants john hunter emergency ward
      'has typed joh,em
      '----------------------------------------------
      bits = Split(organisation, ",")
      If InStr(Trim(bits[0]), " ") Then 'mm.... someone could have typed eg john , instead of john, 
         bits_branch = Split(bits[0], " ", "", True) 
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "
      Else
         sql &= Trim(bits[0]) & "%$$"
      End If
      sql &= " AND branch ILIKE  $$%" & Trim(bits[1]) & "%$$ "
   Else
      '---------------------------------------------------------------------
      'user not after a head office, branch, maybe a two worded organisation
      '---------------------------------------------------------------------
      If InStr(Trim(organisation), " ") Then
         bits_branch = Split(organisation, " ", "", True) 
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "
      Else
         sql &= organisation & "%$$ "
      End If
   Endif
   sql &= "AND (employee_deleted = False Or employee_deleted Is null) "
   sql &= " AND branch_deleted = False and organisation_deleted = FALSE "
   sql &= " order by organisation ASC,  branch, surname DESC, firstname "
   Return modDBConnect.exec_query_collection(sql)
   
   '    - - - - -
   '    Dim sql As String
   '    
   '    sql = "SELECT * FROM contacts.vwOrganisationsEmployees "
   '    "WHERE "
   '    sql &= " Lower(vwOrganisationsEmployees.organisation) LIKE $$" & Lower$(organisation) & "%$$ "
   '    sql &= " AND organisation_deleted = False And branch_deleted = False "
   '    sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   '    sql &= " order by organisation ASC,  branch, surname DESC, firstname "
   '    If limit <> 0 Then
   '     sql &= " LIMIT " & limit
   '    End If   
   ' '   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT " & limit
   ' 
   '    Return modDBConnect.exec_query_collection(sql)
   
End 

Public Function Organisations_Employees_Get_OLD_IANDONOTREMOVETHIS(organisation As String, Optional limit As Integer = 0) As Collection
   '-----------------------------------------------------------
   'PURPOSE    Get a list of organisations and their employee's
   '-----------------------------------------------------------
   
   Dim sql As String
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees "
   "WHERE "
   sql &= " Lower(vwOrganisationsEmployees.organisation) LIKE $$" & Lower$(organisation) & "%$$ "
   sql &= " AND organisation_deleted = False And branch_deleted = False "
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC,  branch, surname DESC, firstname "
   If limit <> 0 Then
      sql &= " LIMIT " & limit
   End If   
   '   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT " & limit
   
   Return modDBConnect.exec_query_collection(sql)
   
End 

Public Function Organisations_Get_HeadOffice(organisation As String) As Collection
   
   Dim sql As String    
   
   sql = "Select * from contacts.vworganisationsEmployees where organisation ILIKE $$%" & organisation & "%$$ "
   sql &= "AND fk_employee = 0 AND head_office = true " 
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Organisations_Get_HeadOffices_For_Provider_Type(fk_category As Integer, organisation As String) As Collection
   
   Dim sql As String
   
   sql = "Select * from contacts.vworganisationsEmployees where organisation ILIKE $$%" & organisation & "%$$ "
   sql &= "AND fk_employee = 0 AND head_office = true and fk_category = " & fk_category
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Provider_Get_Types() As Collection 
   '------------------------------------------------------------------
   'Gets list of all provider types by category
   'Note that everyone we want to provider services must be allocated
   'to a category name 'Name Provider' eg Pathology Provider
   '------------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * from contacts.lu_categories where category ILIKE $$%provider%$$ ORDER BY category")
   
End

Public Function Provider_Get_Types_Like(stype As String) As Collection 
   '------------------------------------------------------------------
   'Gets list of all provider types by category
   'Note that everyone we want to provider services must be allocated
   'to a category name 'Name Provider' eg Pathology Provider
   '------------------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("Select * from contacts.lu_categories where category ILIKE $$%provider%$$ ORDER BY category")
   
End

Public Function Organisation_Get_Head_office_pk(fk_organisation As Integer) As Integer
   '------------------------------------------------------------------------------
   'Returns the primary key of the branch whose address is the address of the head
   'office of an organisation
   '------------------------------------------------------------------------------
   
   Dim sql As String 
   
   sql = "SELECT contacts.data_branches.pk FROM  contacts.data_branches "
   "INNER JOIN contacts.data_addresses ON (contacts.data_branches.fk_address = contacts.data_addresses.pk) "
   "WHERE contacts.data_branches.fk_organisation = "
   sql &= fk_organisation & " And   contacts.data_addresses.head_office = True"
   Return modDBConnect.exec_query(sql)!pk
   
End

Public Function Branches_Get_For_Category(fk_organisation As Integer, fk_category As Integer) As Collection
   '---------------------------------------------------------------------------------------
   'Gets branches for an organisation as a collection including comms using fk_organisation
   '---------------------------------------------------------------------------------------
   
   Dim sql As String
   Dim branches As Collection 
   Dim branch As Collection 
   Dim comms As Collection 
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees WHERE fk_organisation = "
   sql &= fk_organisation & " AND fk_category =" & fk_category 
   sql &= " And fk_employee < 1 and organisation_deleted = FALSE "
   sql &= "ORDER BY branch asc LIMIT 20 "
   branches = modDBConnect.exec_query_collection(sql)
   For Each branch In branches
      sql = "Select * from contacts.vwBranchesComms WHERE fk_branch = " & branch!fk_branch
      comms = modDBConnect.exec_query_collection(sql)
      branch!comms = comms
   Next
   Return branches    
   
End

Public Function Branches_Get_For_Organisation(fk_organisation As Integer, Optional branch_name As String) As Collection
   '----------------------------------------------------------------------------------------
   'Gets branches for an organisation as a collection including comms using fk_organisation
   'fix me include like branch
   '---------------------------------------------------------------------------------------
   
   Dim sql As String
   Dim branches As Collection 
   Dim branch As Collection 
   Dim comms As Collection 
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees WHERE fk_organisation = "
   sql &= fk_organisation
   sql &= " And fk_employee < 1 and organisation_deleted = FALSE "
   sql &= "ORDER BY branch asc LIMIT 20 "
   branches = modDBConnect.exec_query_collection(sql)
   For Each branch In branches
      sql = "Select * from contacts.vwBranchesComms WHERE fk_branch = " & branch!fk_branch
      comms = modDBConnect.exec_query_collection(sql)
      branch!comms = comms
   Next
   Return branches    
   
End

Public Function Branches_Get_Like(branch As String) As Collection
   'changed to :and fk_employee = 0 23Feb10, this may fuck contacts?
   
   Return modDBConnect.exec_query_collection("select * from contacts.vwOrganisationsEmployees where branch ILIKE $$%" & branch & "%$$ and fk_employee = 0")
   
End

Public Sub Branch_get_by_keys(fk_branch As Integer) As Collection 
   
   Return modDBConnect.exec_query_collection("Select * From contacts.vwOrganisationsEmployees where fk_branch = " & fk_branch & " and fk_employee = 0")
   
End

Public Sub Organisations_Get_By_Category(category As String) As Collection
   '------------------------------------------------------------------------------------------
   'get organisations by category
   'notes: as collection must have unique key, I've used fk_branch as the pk_view, still need
   'fk_branch for use within the calling routine
   '------------------------------------------------------------------------------------------
   
   Dim sql As String
   
   sql = ""
   "select distinct category, organisation, fk_organisation, branch, fk_branch as pk_view, fk_branch, "
   "town, street1, street2, postcode from contacts.vwOrganisations "
   "where organisation_deleted = false and branch_deleted = false and address_deleted = false "
   sql &= " and category  ILIKE $$%" & category & "%$$ order by category, organisation, fk_branch " 'this way head-office always as first branch
   
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub Organisations_Get(organisation As String) As Collection
   '-------------------------------------------------------------------------------
   'Gets a list of organisations without employees, if comma separated
   'the searches on organisation and branch
   'can recieve text like org,branch or new rad,ad = newcastle radiology adamstown
   'need to Trim as can receive eg newc,  em instead of newc,em
   '------------------------------------------------------------------------------
   
   Dim bits As String[]
   Dim bits_branch As String[]
   Dim sql As String 
   
   sql = "Select * From contacts.vwOrganisationsEmployees where organisation ILIKE $$%"
   If InStr(organisation, ",") Then
      '----------------------------------------------      
      'lets say user wants john hunter emergency ward
      'has typed joh,em
      '----------------------------------------------
      bits = Split(organisation, ",")
      If InStr(Trim(bits[0]), " ") Then 'mm.... someone could have typed eg john , instead of john, 
         bits_branch = Split(bits[0], " ", "", True) 
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "
      Else
         sql &= Trim(bits[0]) & "%$$"
      End If
      sql &= " AND branch ILIKE  $$%" & Trim(bits[1]) & "%$$ "
   Else
      '---------------------------------------------------------------------
      'user not after a head office, branch, maybe a two worded organisation
      '---------------------------------------------------------------------
      If InStr(Trim(organisation), " ") Then
         bits_branch = Split(organisation, " ", "", True) 
         sql &= Trim(bits_branch[0]) & "%" & Trim(bits_branch[1]) & "%$$ "
      Else
         sql &= organisation & "%$$ "
      End If
   Endif
   sql &= " AND fk_employee = 0  and branch_deleted = False and organisation_deleted = FALSE "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub person_address_delete(pk_address As Integer)
   '---------------------------------------------------------------
   'Marks an address as deleted in the addresses table, and removes
   'the linkage in the appropriate table
   '---------------------------------------------------------------
   
   Dim sql As String
   
   If pk_address Then
      sql = "Update contacts.links_persons_addresses set deleted = TRUE  where fk_address = "
      sql &= pk_address
      modDBConnect.exec_query(sql)
      sql = "Update contacts.data_addresses set deleted = TRUE where pk = "
      sql &= pk_address
      modDBConnect.exec_query(sql)
   End If
   
End

Public Sub person_address_link(pk_person As Integer, pk_address As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_persons_addresses "
   "(fk_address,fk_person)"
   "VALUES ("
   sql &= pk_address & "," & pk_person & ")"
   modDBConnect.exec_query(sql)
   
End   

Public Sub person_comm_link(pk_person As Integer, pk_comm As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_persons_comms "
   "(fk_comm,fk_person)"
   "VALUES ("
   sql &= pk_comm & "," & pk_person & ")"
   modDBConnect.exec_query(sql)
   
End 

Public Function AnalyseName(searchtext As String) As String[]
   '---------------------------------------------------------------------
   'Splits the seach text into firstname, surname using this logic:
   'If input is comma separated:
   '        if two parts eg "smith, pe" assummed to be surname,firstname
   '        if one part eg "cathy," assumed to be a firstname
   'if input is space separated
   '        if one part eg "terry" assumed to be surname
   '        if two parts eg rich ter" assumed to be firstname surname
   'Returns strArray[0]=surname
   '        strArray[1]=firstname
   '---------------------------------------------------------------------
   
   Dim firstname As String
   Dim surname As String
   Dim title As String 
   Dim commapos As Integer
   Dim strArray As New String[] 'was 3
   
   commapos = InStr(searchtext, ",")
   'If there is a comma in the search text
   'can be surname,firstname or firstname,
   If commapos > 0 Then
      strArray = Split(searchtext, (","))
      surname = strArray[0]
      firstname = strArray[1]
      'IF what we are assuming TO be firstname(ie what 's left after the comma is nothing"""
      If Len(firstname) = 0 Then
         strArray[1] = surname 'ie actually a fistname strArray.Add("", 1)
         strArray[0] = ""
      End If
      
   Else 
      'otherwise, check if two words separated by blank
      'which we will interpret as firstname <space> surname
      If InStr(searchtext, " ") > 0 Then
         strArray = Split(searchtext, (" "))
         If strArray.count = 3 Then
            'this is not 100% accurate but will do as a start
            'two possibilities 1) Title, firstname, surname or firstname surname (as eg joe de lyall)
            If LCase(strArray[0]) = "mr" Or LCase(strArray[0]) = "mrs" Or LCase(strArray[0]) = "mst" Or LCase(strArray[0]) = "ms" Or LCase(strArray[0]) = "miss" Or LCase(strArray[0]) = "prof" Or LCase(strArray[0]) = "dr" Then
               surname = strArray[2]
               firstname = strArray[1]
               title = strArray[0]
               strArray[2] = title
               strArray[1] = firstname
               strArray[0] = surname 
            Else
               surname = strArray[1] & " " & strArray[2]
               firstname = strArray[0]
               strArray[0] = surname
               strArray[1] = firstname
            End If
         Else
            surname = strArray[1]
            firstname = strArray[0]
            strArray[0] = surname
            strArray[1] = firstname
         Endif
      Else
         'othwise is just a single word, no comma, so assume a surname search 
         
         strArray.Add(searchtext, 0)  
         strArray.Add("", 1)
      Endif 
   End If
   
   Return strArray
   
End

Public Function family_members_get(fk_family As Integer) As Result
   
   Dim sql As String
   
   sql = "select * from contacts.vwPatients WHERE fk_family=" & fk_family
   Return modDBConnect.exec_query(sql)
   
End

Public Function person_get_firstname_surname(name As String) As Result
   'FIXME BAD BAD BUGS IN HERE, INPUT NOT PARSED TO EXCLUDE UNSEARCHABLE THINGS
   'FIX AS PER FIND PATIENTS. 

   Dim sql As String
   Dim strArrayNames As String[]
   
   strArrayNames = AnalyseName(name)
   
   sql = "SELECT PERSONS.*,TITLE.title, MARITAL.marital,SEX.sex "
   
   "FROM  contacts.data_persons PERSONS "
   "Left OUTER JOIN contacts.lu_title TITLE ON(PERSONS.fk_title = TITLE.pk) "
   "Left OUTER JOIN contacts.lu_marital MARITAL ON(PERSONS.fk_marital = MARITAL.pk) "
   "Left OUTER JOIN contacts.lu_sex SEX ON(PERSONS.fk_sex = SEX.pk) "
   "WHERE "
   "lower(surname) LIKE $$"
   sql &= Lower$(strArrayNames[0]) & "%$$ "
   sql &= "AND lower(firstname) LIKE $$"
   sql &= Lower$(strArrayNames[1]) & "%$$" 
   sql &= "ORDER BY surname LIMIT 100;"
   Return modDBConnect.exec_query(sql)
   
End

Public Function Employee_get_For_Organisation(fk_branch As Integer, surname As String, firstname As String) As Collection
   
   Dim sql As String
   
   sql = "Select * from contacts.vwOrganisationsEmployees where fk_branch = " & fk_branch
   sql &= " AND organisation_deleted = False and employee_deleted = false AND "
   If firstname <> "" Then
      sql &= "firstname ILIKE $$" & firstname & "$$ "
   End If
   If surname <> "" Then
      sql &= "AND surname ILIKE $$" & surname & "$$ "
   End If
   'note could be two employees of same name
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Get_By_Fk_branch_fk_person(fk_person As Integer, fk_branch As Integer) As Integer

   Dim R As Result

   R = modDBConnect.exec_query("Select fk_employee from  contacts.vwemployees where fk_person=" & fk_person & " AND fk_branch=" & fk_branch)
   If R.count Then Return R!fk_employee
   
End

Public Function Employees_Get(name As String) As Collection
   '------------------------------------------------------------
   'Gets all employees like name (expects string comma delimited
   'This one has both organisation_category and employee_category
   'only rows with employee's not with organisations and employee
   '------------------------------------------------------------
   
   Dim strArrayNames As String[]
   Dim sql As String
   
   strArrayNames = AnalyseName(name)
   sql = "SELECT * FROM contacts.vwEmployees  WHERE "
   sql &= "surname ILIKE $$" & strArrayNames[0] & "%$$ "
   sql &= "AND firstname ILIKE $$"
   sql &= strArrayNames[1] & "%$$ " 
   If Not strArrayNames.count = 3 Then
      sql &= "AND title ILIKE $$"
      sql &= strArrayNames[2] & "%$$ " 
   End If
   sql &= " AND organisation_deleted = False And branch_deleted = False "
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employee_Get_By_Surname(surname As String) As Collection
   '-----------------------------------------
   'return a collection of persons by surname
   '-----------------------------------------
   
   Dim sql As String    
   
   sql = "Select DISTINCT occupation, surname, firstname , fk_person  as pk_person," 
   sql &= "title || ' ' ||firstname || ' ' || surname as wholename from "
   sql &= "contacts.vwOrganisationsEmployees where surname ILIKE $$%" 
   sql = sql & surname & "%$$ ORDER BY surname  LIMIT 20 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Employees_In_Organisations_Find(name As String) As Collection 
   '------------------------------------------------------------
   'Gets all employees like name (expects string comma delimited
   '------------------------------------------------------------
   
   Dim strArrayNames As String[]
   Dim sql As String
   
   strArrayNames = AnalyseName(name)
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees  WHERE "
   sql &= "surname ILIKE $$" & strArrayNames[0] & "%$$ "
   sql &= "AND firstname ILIKE $$"
   sql &= strArrayNames[1] & "%$$ " 
   If Not strArrayNames.count = 3 Then
      sql &= "AND title ILIKE $$"
      sql &= strArrayNames[2] & "%$$ " 
   End If
   sql &= " AND organisation_deleted = False And branch_deleted = False "
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Patients_Get_Temp(searchtext2 As String) As Collection
   
   Dim sql As String
   'used by my contacts patients form until ian fixes the search
   sql = "Select * from contacts.vwPatients where surname ILIKE $$" & Trim(searchtext2) & "%$$ order by surname limit 20"
   Return modDBConnect.exec_query_collection(sql)
   
End

Private Function test_regex(sRegex As String[]) As Boolean
   
   Dim sql As String
   Dim i As String
   
   If searchtext = "" Then Return False   
   For Each i In sRegex
      regex = New Regexp(searchtext, i)
      If regex.Offset >= 0 Then
         searchtext = Left$(searchtext, regex.Offset) & Right$(searchtext, Len(searchtext) - Len(regex.Text) - regex.Offset)
         Return True
      Endif
   Next
   Return False
   
End

Public Function Patient_Get_Using_PK(fk_patient As Integer) As Collection 
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwPatients where fk_patient =" & fk_patient & " AND address_deleted = False")
   
End

Public Function Patient_Get_pk_Using_Person_pk(fk_person As Integer) As Integer
   '-------------------------------------------------------------------------------
   'Get the patient's primary key for clerical.data_patients, using their fk_person
   'used during data updating in the patient import wizard
   '-------------------------------------------------------------------------------
   
   Dim sql As String
   Dim R As Result
   
   sql = "Select * From contacts.vwpatients where fk_person = " & fk_person
   If R.count Then
      Return modDBConnect.exec_query(sql)!fk_patient
   Else
      Return 0
   End If
   
End

Public Function patients_get_firstname_surname(searchtext2 As String, Optional bDeceased As Boolean = False, Optional limit As Integer = 100) As Collection 
   '-------------------------------------------------------
   'Find a patient according to criteria
   'if sql criteria, use that, otherwise firstname, surname
   'fixme put in optional limit
   '-------------------------------------------------------
   
   '-----------------------------------------------------
   'first attempt at searching by query criteria FIXME UP
   '-----------------------------------------------------
   Dim sql As String
   Dim clauses As New String[]
   Dim tables As New String[]
   Dim sql_in_english_array As New String[]
   Dim $result As Collection
   
   searchtext = Lower$(searchtext2)
   tables.Clear
   clauses.Clear
   sql_in_english_array.Clear
   
   tables.Add("contacts.vwpatients cvwp")
   If test_regex(["(sex|gender) ?(:|=) ?(f|female|woman)"]) Then
      ' clauses.Add("cvwp.sex = 'F'")
      clauses.Add("cvwp.fk_sex =" & const.cSexFemale)
      sql_in_english_array.Add("patient is female")
   Endif
   If test_regex(["(sex|gender) ?(:|=) ?(m|male|man)"]) Then
      ' clauses.Add("cvwp.sex = 'M'")
      clauses.Add("cvwp.fk_sex = " & const.cSexMale)
      sql_in_english_array.Add("patient is male")
   Endif
   
   If test_regex(["([0-9]+) ?< ?age ?< ?([0-9]+)", "age ?> ?([0-9]+) ?< ?([0-9]+)", "age between ([0-9]+) and ([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[2].Text & " years'")
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("age is between " & regex.SubMatches[1].Text & " and " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?> ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("older than " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?< ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("younger than " & regex.SubMatches[1].Text)
   Endif
   
   ' search in the form surname, firstname
   If test_regex(["([a-z' \\-]+) ?, ?([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & Trim(regex.SubMatches[1].Text) & "%$$") 'trim eg bailey<space> **ATTENTION IAN***
      clauses.Add("lower(cvwp.firstname) like $$%" & Trim(regex.SubMatches[2].Text) & "%$$") 'RT inserted %for instring search 08Feb12
      sql_in_english_array.Add("surname begins with \"" & Trim(regex.SubMatches[1].Text) & "\"")
      sql_in_english_array.Add("firstname begins with \"" & Trim(regex.SubMatches[2].Text) & "\"")
   Endif
   
   ' search in the form firstname surname
   If test_regex(["([a-z'\\-]+) +([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[2].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$%" & regex.SubMatches[1].Text & "%$$") 'RT inserted %for instring search 08Feb12
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[2].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   
   If test_regex(["([a-z'\\-]+)"]) Then ' just the surname
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[1].text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   'ian fixme quickndirty fix because if characters like *% entered in search > crashes (do need at least the wildcard
   If clauses.count = 0 Then
      sql = "SELECT cvwp.* FROM "
      sql &= tables.Join(",")
      sql &= " WHERE surname ILIKE $$%$$ "
   Else
      sql = "SELECT cvwp.* FROM "
      sql &= tables.Join(",")
      sql &= " WHERE address_deleted = FALSE AND " & clauses.Join(" AND ")
   End If   
   If bDeceased = False Then
      sql &= " AND deceased = false " 
   Endif
   sql &= " ORDER BY surname, firstname ASC LIMIT " & limit 
   $result = modDBConnect.exec_query_collection(sql)
   $result!sql_in_english = sql_in_english_array.Join(" and ")
   Return $result
   
End

Public Function patients_get_firstname_surname_old(searchtext2 As String, Optional bDeceased As Boolean = False) As Collection 
   '-------------------------------------------------------
   'Find a patient according to criteria
   'if sql criteria, use that, otherwise firstname, surname
   'fixme put in optional limit
   '-------------------------------------------------------
   
   '-----------------------------------------------------
   'first attempt at searching by query criteria FIXME UP
   '-----------------------------------------------------
   Dim sql As String
   Dim clauses As New String[]
   Dim tables As New String[]
   Dim sql_in_english_array As New String[]
   Dim $result As Collection
   
   searchtext = Lower$(searchtext2)
   tables.Clear
   clauses.Clear
   sql_in_english_array.Clear
   
   tables.Add("contacts.vwpatients cvwp")
   If test_regex(["(sex|gender) ?(:|=) ?(f|female|woman)"]) Then
      clauses.Add("cvwp.sex = 'F'")
      sql_in_english_array.Add("patient is female")
   Endif
   If test_regex(["(sex|gender) ?(:|=) ?(m|male|man)"]) Then
      clauses.Add("cvwp.sex = 'M'")
      sql_in_english_array.Add("patient is male")
   Endif
   
   If test_regex(["([0-9]+) ?< ?age ?< ?([0-9]+)", "age ?> ?([0-9]+) ?< ?([0-9]+)", "age between ([0-9]+) and ([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[2].Text & " years'")
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("age is between " & regex.SubMatches[1].Text & " and " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?> ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("older than " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?< ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[1].Text & " years'")
      sql_in_english_array.Add("younger than " & regex.SubMatches[1].Text)
   Endif
   
   ' search in the form surname, firstname
   If test_regex(["([a-z' \\-]+) ?, ?([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[1].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$" & regex.SubMatches[2].Text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[1].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[2].Text & "\"")
   Endif
   
   ' search in the form firstname surname
   If test_regex(["([a-z'\\-]+) +([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[2].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$" & regex.SubMatches[1].Text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[2].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   
   If test_regex(["([a-z'\\-]+)"]) Then ' just the surname
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[1].text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   'ian fixme quickndirty fix because if characters like *% entered in search > crashes (do need at least the wildcard
   If clauses.count = 0 Then
      sql = "SELECT cvwp.* FROM "
      sql &= tables.Join(",")
      sql &= " WHERE surname ILIKE $$%$$ "
   Else
      sql = "SELECT cvwp.* FROM "
      sql &= tables.Join(",")
      sql &= " WHERE address_deleted = FALSE AND " & clauses.Join(" AND ")
   End If   
   If bDeceased = False Then
      sql &= " AND deceased = false " 
   Endif
   sql &= " ORDER BY surname, firstname ASC"
   $result = modDBConnect.exec_query_collection(sql)
   $result!sql_in_english = sql_in_english_array.Join(" and ")
   Return $result
   
End

Public Function Person_Get_By_pk(fk_person As Integer) As Collection
   
   Dim sql As String 
   
   sql = "Select * From contacts.vwpersonsexcludingpatients "
   sql &= "where fk_person = " & fk_person
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Person_Get(searchtext2 As String, iSearchCriteria As Integer, Optional bDeceased As Boolean = False) As Collection 
   '------------------------------------------------------------------------------
   'Get a list of either only patients, only non-patients or persons who are both
   '-----------------------------------------------------------------------------
   
   Dim sql As String
   Dim clauses As New String[]
   Dim tables As New String[]
   Dim sql_in_english_array As New String[]
   Dim Persons As Collection
   
   searchtext = Lower$(searchtext2)
   tables.Clear
   clauses.Clear
   sql_in_english_array.Clear
   Select Case iSearchCriteria
      Case const.contacttype_patient
         tables.Add("contacts.vwpatients cvwp")
      Case const.contacttype_person
         tables.Add("contacts.vwpersonsexcludingpatients cvwp")
      Case Else
         tables.Add("contacts.vwpersonsincludingpatients cvwp")
   End Select 
   
   If test_regex(["(sex|gender) ?(:|=) ?(f|female|woman)"]) Then
      clauses.Add("cvwp.sex = 'F'")
      sql_in_english_array.Add("patient is female")
   Endif
   If test_regex(["(sex|gender) ?(:|=) ?(m|male|man)"]) Then
      clauses.Add("cvwp.sex = 'M'")
      sql_in_english_array.Add("patient is male")
   Endif
   
   If test_regex(["([0-9]+) ?< ?age ?< ?([0-9]+)", "age ?> ?([0-9]+) ?< ?([0-9]+)", "age between ([0-9]+) and ([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[1].Text & " years'")
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[0].Text & " years'")
      sql_in_english_array.Add("age is between " & regex.SubMatches[0].Text & " and " & regex.SubMatches[1].Text)
   Endif
   
   If test_regex(["age ?> ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) > '" & regex.SubMatches[0].Text & " years'")
      sql_in_english_array.Add("older than " & regex.SubMatches[0].Text)
   Endif
   
   If test_regex(["age ?< ?([0-9]+)"]) Then
      clauses.Add("age(cvwp.birthdate) < '" & regex.SubMatches[0].Text & " years'")
      sql_in_english_array.Add("younger than " & regex.SubMatches[0].Text)
   Endif
   
   ' search in the form surname, firstname
   If test_regex(["([a-z' \\-]+) ?, ?([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[0].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$" & regex.SubMatches[1].Text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[0].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[1].Text & "\"")
   Endif
   
   ' search in the form firstname surname
   If test_regex(["([a-z'\\-]+) +([a-z'\\-]+)"]) Then
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[1].Text & "%$$")
      clauses.Add("lower(cvwp.firstname) like $$" & regex.SubMatches[0].Text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[1].Text & "\"")
      sql_in_english_array.Add("firstname begins with \"" & regex.SubMatches[0].Text & "\"")
   Endif
   
   If test_regex(["([a-z'\\-]+)"]) Then ' just the surname
      clauses.Add("lower(cvwp.surname) like $$" & regex.SubMatches[0].text & "%$$")
      sql_in_english_array.Add("surname begins with \"" & regex.SubMatches[0].Text & "\"")
   Endif
   'ian fixme quickndirty fix because if characters like *% entered in search > crashes (do need at least the wildcard
   sql = "SELECT cvwp.* FROM "
   sql &= tables.Join(",") & " WHERE "
   If bDeceased Then
      sql &= "deceased = True "
   Else
      sql &= "deceased = False "
   Endif
   
   If clauses.count = 0 Then
      sql &= " AND surname ILIKE $$%$$ "
   Else
      sql &= " AND " & clauses.Join(" AND ")
   End If  
   Persons = modDBConnect.exec_query_collection(sql)
   Persons!sql_in_english = sql_in_english_array.Join(" AND ")
   Return Persons
   
End

Public Function Person_Get_Using_Pk(pk_person As Integer) As Collection 
   
   Return modDBConnect.exec_query_collection("Select * from contacts.vwpersonsexcludingpatients where fk_person = " & pk_person)
   
End

Public Function person_get_with_pk(pk_person As Integer) As Result
   
   Dim sql As String
   
   sql = "SELECT PERSONS.*,TITLE.title, MARITAL.marital,SEX.sex "
   "FROM  contacts.data_persons PERSONS "
   "Left OUTER JOIN contacts.lu_title TITLE ON(PERSONS.fk_title = TITLE.pk) "
   "Left OUTER JOIN contacts.lu_marital MARITAL ON(PERSONS.fk_marital = MARITAL.pk) "
   "Left OUTER JOIN contacts.lu_sex SEX ON(PERSONS.fk_sex = SEX.pk) "
   "WHERE PERSONS.pk ="
   sql &= pk_person
   Return modDBConnect.exec_query(sql)
   
End

Public Function Get_Town(town As String, Optional wildcard_search As Boolean = False, Optional LIMIT As Integer = 20) As Collection 
   
   Dim sql As String
   
   sql = "SELECT * from contacts.lu_towns WHERE town ILIKE $$"
   If wildcard_search Then
      sql &= "%" 
   Endif
   sql &= town & "%$$ order by town  LIMIT " & LIMIT
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Function Occupation_Get(occupation As String) As Collection 
   '------------------------------------------------------
   'Fetch a list of occupations from common.lu_occupations
   '------------------------------------------------------
   
   Return modDBConnect.exec_query_collection("SELECT * FROM common.lu_occupations WHERE occupation ILIKE $$%" & occupation & "%$$  LIMIT 20")
   
End

Public Function Occupations_Get(occupation As String) As Result
   
   Dim sql As String
   
   sql = "SELECT * FROM common.lu_occupations WHERE  lower (occupation) ILIKE $$" 
   sql &= Lower$(occupation) & "%$$  LIMIT 20"
   Return modDBConnect.exec_query(sql)
   
End

Public Function Occupation_Save(occupation As String) As Integer
   '--------------------------------------------------
   'Insert a new occupation into common.lu_occupations
   'and returns the primary key of that table
   '--------------------------------------------------
   
   Dim $result As Result
   
   $Result = modDBConnect.exec_query("INSERT INTO common.lu_occupations (occupation) VALUES ($$" & occupation & "$$) returning pk")
   Return $Result!pk
   
End

Public Sub Employee_Delete(fk_person As Integer, fk_branch As Integer)
   
   modDBConnect.exec_query("Update contacts.data_employees set deleted = True where fk_person = " & fk_person & " AND fk_branch = " & fk_branch)
   
End

Public Function Employee_Save(old_data As Collection, pk_view As String, person As Collection, employee As Collection, comms As Collection, views_comms As Collection) As Collection ', old_comms As collection) As collection
   '--------------------------------------------
   'Saves an employee in an organisation
   'Nothing in the organisation can have changed
   '--------------------------------------------
   
   Dim comm As Collection 
   Dim collection_to_return As New Collection 
   Dim sql As String 
   '-------------------------------------------------------
   'does the firstname exist in the fistnames table?
   'FIXME PUT IN THE CODE, BUT WHAT ABOUT SPELLING mistakes
   '-------------------------------------------------------
   If IsNull(person!fk_person) Then
      person!fk_person = modDBConnect.insert("contacts.data_persons", person)
   Else
      '------------------------------------------------------------------------------------
      'As there is no associated 'old-data' for a person cannot use this:
      ' modDBConnect.update("contacts.data_persons", old_data[pk_view], person, "fk_person")
      ' so am doing it the 'old way'
      modDBConnect.update("contacts.data_persons", old_data[pk_view], person, "fk_person")
   End If
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         person_Comm_Link(person!fk_person, comm!pk)
      Else
         comm.Remove("fk_person")
         modDBConnect.update("contacts.data_communications", views_comms[comm!pk], comm, "pk")
      End If
   Next
   '---------------------------------
   'Save any new employee occupations
   '---------------------------------
   If IsNull(employee!fk_occupation) Then
      employee!fk_occupation = Occupation_Save(employee!occupation)
   End If   
   Try employee.remove("occupation")
   '-----------------------------------------
   'Next check if the employee already exists
   '-----------------------------------------
   If IsNull(employee!fk_employee) Then
      employee!fk_person = person!fk_person
      employee!fk_employee = modDBConnect.insert("contacts.data_employees", employee)
   Else
      modDBConnect.update("contacts.data_employees", old_data[pk_view], employee, "fk_employee")
   End If
   '-------------------------------------------
   'Saves communications for branch or employee  
   '--------------------------------------------
   ' For Each comm In comms
   '    Try comm.Remove("type") 'was needed for display in editing
   '    If IsNull(comm!pk) Then
   '       comm!pk = modDBConnect.insert("contacts.data_communications", comm)
   '       Employee_Comm_Link(employee!fk_employee, comm!pk)
   '    Else
   '       modDBConnect.update("contacts.data_communications", old_comms[pk_view], comm, "pk")
   '    End If
   ' Next
   
   '--------------------------------------------------------------------------------
   'Now, if the employee is a staff member = for us, a database user, deal with that
   '--------------------------------------------------------------------------------
   ' modDBConnect.CommitTrans()
   '--------------------------------------------------------------------
   'These three keys identify a row, and will be used to restore the row
   '--------------------------------------------------------------------
   ' collection_to_return.Add(organisation!fk_organisation, "fk_organisation")
   ' collection_to_return.Add(branch!fk_branch, "fk_branch")
   ' If Not IsNull(employee) Then
   '   collection_to_return.Add(employee!fk_employee, "fk_employee")
   ' End If  
   collection_to_return!fk_person = person!fk_person
   collection_to_return!fk_employee = employee!fk_employee
   'this will break contacts - fixme
   Return collection_to_return
   
End

Public Function organisation_save(old_data_organisation As Collection, old_pk As Integer, organisation As Collection, branch As Collection, address As Collection, comms As Collection, old_comms As Collection) As Collection
   '-------------------------------------------------------------------------
   'Saves an organisation +/- its branch, address, communications 
   'First save any previously unkown fields for which we need the key
   'COMMENTS:  Note all fields needed for user to make sense of gui but not
   '           needed in the data tables are removed like this:
   '           Try collection.remove("field")
   '--------------------------------------------------------------------------
   
   Dim comm As Collection 
   Dim collection_to_return As New Collection 
   
   If IsNull(organisation!fk_organisation) Then
      organisation!fk_organisation = modDBConnect.insert("contacts.data_organisations", organisation)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      modDBConnect.update("contacts.data_organisations", old_data_organisation[old_pk], organisation, "fk_organisation")
   End If
   '-------------------------------------
   'Address: create new or change details
   '-------------------------------------
   If Not IsNull(address) Then
      If IsNull(address!fk_address) Then
         '--------------------------------------------------------------------------------
         'Thought there may be an address collection, the user may have put nothing in it
         '-------------------------------------------------------------------------------
         '-------------------
         'Create a new address
         '-------------------
         address!fk_address = modDBConnect.insert("contacts.data_addresses", address)
      Else
         '-------------------------------
         'change existing address details
         '-------------------------------
         Try address.Remove("town")
         Try address.Remove("postcode")
         Try address.Remove("state")
         modDBConnect.update("contacts.data_addresses", old_data_organisation[old_pk], address, "fk_address")
      End If
   End If
   '--------------------------------------------
   'Branch: create new or change details
   '        first save its category if necessary
   '--------------------------------------------
   If IsNull(branch!fk_category) Then
      branch!fk_category = Category_Save(branch!category)
   End If
   Try branch.Remove("category") 
   
   If IsNull(branch!fk_branch) Then
      '-------------------
      'Create a new branch
      '-------------------
      Try branch!fk_address = address!fk_address  'may not have an address
      branch!fk_organisation = organisation!fk_organisation
      branch!fk_branch = modDBConnect.insert("contacts.data_branches", branch)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      modDBConnect.update("contacts.data_branches", old_data_organisation[old_pk], branch, "fk_branch")
   End If
   
   '-------------------------------------------
   'Saves communications for branch or employee  
   '--------------------------------------------
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         Branch_Comm_Link(branch!fk_branch, comm!pk)
      Else
         comm.Remove("fk_branch")
         modDBConnect.update("contacts.data_communications", old_comms[old_pk], comm, "pk")
         
      End If
   Next
   'Now save the default clinic to the admin.clinics table
   
   modDBConnect.CommitTrans()
   '--------------------------------------------------------------------
   'These two keys identify a row, and will be used to restore the row
   '--------------------------------------------------------------------
   collection_to_return.Add(organisation!fk_organisation, "fk_organisation")
   collection_to_return.Add(branch!fk_branch, "fk_branch")
   Return collection_to_return
   
End

Public Function Org_save(old_data_organisation As Collection, old_pk As Integer, organisation As Collection, branch As Collection, address As Collection, comms As Collection, old_comms As Collection, clinic As Collection) As Collection
   '-------------------------------------------------------------------------
   'Saves an organisation +/- its branch, address, communications 
   'First save any previously unkown fields for which we need the key
   'COMMENTS:  Note all fields needed for user to make sense of gui but not
   '           needed in the data tables are removed like this:
   '           Try collection.remove("field")
   '--------------------------------------------------------------------------
   
   Dim comm As Collection 
   Dim collection_to_return As New Collection 
   
   '------------------------------------------
   'Organisation: create new or change details
   '------------------------------------------
   If IsNull(organisation!fk_organisation) Then
      organisation!fk_organisation = modDBConnect.insert("contacts.data_organisations", organisation)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      modDBConnect.update("contacts.data_organisations", old_data_organisation[old_pk], organisation, "fk_organisation")
   End If
   '-------------------------------------
   'Address: create new or change details
   '-------------------------------------
   If Not IsNull(address) Then
      If IsNull(address!fk_address) Then
         '--------------------------------------------------------------------------------
         'Thought there may be an address collection, the user may have put nothing in it
         '-------------------------------------------------------------------------------
         '-------------------
         'Create a new address
         '-------------------
         address!fk_address = modDBConnect.insert("contacts.data_addresses", address)
      Else
         '-------------------------------
         'change existing address details
         '-------------------------------
         Try address.Remove("town")
         Try address.Remove("postcode")
         Try address.Remove("state")
         modDBConnect.update("contacts.data_addresses", old_data_organisation[old_pk], address, "fk_address")
      End If
   End If
   '--------------------------------------------
   'Branch: create new or change details
   '        first save its category if necessary
   '--------------------------------------------
   If IsNull(branch!fk_category) Then
      branch!fk_category = Category_Save(branch!category)
   End If
   Try branch.Remove("category") 
   
   If IsNull(branch!fk_branch) Then
      '-------------------
      'Create a new branch
      '-------------------
      Try branch!fk_address = address!fk_address  'may not have an address
      branch!fk_organisation = organisation!fk_organisation
      branch!fk_branch = modDBConnect.insert("contacts.data_branches", branch)
   Else
      '------------------------------
      'change existing branch details
      '------------------------------
      Try branch!fk_address = address!fk_address  'may now have an address
      modDBConnect.update("contacts.data_branches", old_data_organisation[old_pk], branch, "fk_branch")
   End If
   '-------------------------------------------
   'Saves communications for branch or employee  
   '--------------------------------------------
   For Each comm In comms
      Try comm.Remove("type") 'was needed for display in editing
      If IsNull(comm!pk) Then
         comm!pk = modDBConnect.insert("contacts.data_communications", comm)
         Branch_Comm_Link(branch!fk_branch, comm!pk)
      Else
         comm.Remove("fk_branch")
         modDBConnect.update("contacts.data_communications", old_comms[comm!pk], comm, "pk")
      End If
   Next
   
   '-------------------------------------
   'Now save or modify the clinic details
   '-------------------------------------
   If Not IsNull(clinic) Then
      If clinic!fk_clinic = 0 Then  ' And clinic!default_clinic Then
         Try clinic.remove("fk_clinic")
         Try clinic.Remove("default_clinic")
         clinic!fk_branch = branch!fk_branch
         clinic!fk_clinic = modDBConnect.insert("admin.clinics", clinic)
      End If
   End If
   '--------------------------------------------------------------------
   'These two keys identify a row, and will be used to restore the row
   '--------------------------------------------------------------------
   collection_to_return.Add(organisation!fk_organisation, "fk_organisation")
   collection_to_return.Add(branch!fk_branch, "fk_branch")
   collection_to_return.Add(branch!fk_category, "fk_category") 'FIXME MAKE ME LOGICAL
   Return collection_to_return
   
End

Public Function Organisations_Employees_Get_By_Keys(fk_organisation As Integer, Optional fk_branch As Integer, Optional fk_employee As Integer) As Collection 
   
   Dim sql As String
   
   sql = "SELECT * FROM contacts.vwOrganisationsEmployees WHERE "
   sql &= "fk_organisation =" & fk_organisation 
   If fk_branch Then
      sql &= " AND " "fk_branch =" & fk_branch
   End If
   sql &= "And (employee_deleted = False Or employee_deleted Is null) "
   sql &= " order by organisation ASC, fk_branch, branch, surname DESC, firstname LIMIT 100 "
   Return modDBConnect.exec_query_collection(sql)
   
End

Public Sub Branch_Comm_Link(fk_branch As Integer, pk_comm As Integer)
   
   Dim sql As String
   
   sql = "INSERT INTO contacts.links_branches_comms "
   "(fk_comm,fk_branch)"
   "VALUES ("
   sql &= pk_comm & "," & fk_branch & ")"
   modDBConnect.exec_query(sql)  
   
End

Public Sub Branch_Comm_Delete(fk_branch As Integer, fk_comm As Integer)
   '------------------------------------
   'Marks a comm as deleted and the link
   '------------------------------------
   
   Dim sql As String
   Dim $Result As Result
   
   sql = "UPDATE contacts.links_branches_comms SET Deleted = True "
   sql &= " WHERE fk_branch =" & fk_branch & " AND fk_comm = " & fk_comm
   $result = modDBConnect.exec_query(sql)
   
End

Public Function Misspelt_towns_Get(town As String) As Collection   
   '---------------------------------------------------------------
   'Called by FImportPatients.PatientCreate if a suburb match fails
   'This may have occurred previously
   '---------------------------------------------------------------
   
   Return modDBConnect.exec_query_first("select * from contacts.lu_misspelt_towns where town_misspelt ILIKE $$" & town & "$$")
   
End
