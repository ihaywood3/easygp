' Gambas class file

' Copyright (C) 2010-2014 Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.

Private segments As String[]
Private segment_parsed As String[]
Private curr As Integer
Private codeset As String = "ISO-8859-1" ' the Windows charset: sadly a safe assumption
Property Read Number As Integer
Property Read Segment As String

Public Sub _new(txt As String)
   
   Dim i As Integer
   
   If txt = "" Then Return
   If Left$(txt, 1) = "/" Then ' it's a filename
      txt = File.Load(txt)
   Endif
   segments = Split(txt, "\r")
   If segments.Length = 1 Then
      segments = Split(txt, "\n")
   Endif
   If segments.Length > 1 Then
      If Left$(segments[1], 1) = "\n" Then ' naughty, naughty, someone's using MS-DOS style newlines
         For i = 1 To segments.Length - 1
            segments[i] = Right$(segments[i], -1)
         Next
      Endif
   Endif
   curr = 0
   segment_parsed = Null
   
End Sub

Public Sub _new_ian_14aug14(txt As String)
   
   Dim i As Integer
   Dim re As RegExp
   
   If txt = "" Then Return
   If Left$(txt, 1) = "/" Then ' it's a filename
      txt = File.Load(txt)
   Endif
   segments = Split(txt, "\r")
   If segments.Length = 1 Then
      segments = Split(txt, "\n")
   Endif
   If segments.Length > 1 Then
      If Left$(segments[1], 1) = "\n" Then ' naughty, naughty, someone's using MS-DOS style newlines
         For i = 1 To segments.Length - 1
            segments[i] = Right$(segments[i], -1)
         Next
      Endif
   Endif
   ' check for inappropriate use of \r
   i = 1
   While i < segments.Length
     If IsNull(segments[i]) Or If Len(segments[i]) = 0 Then
        segments.Delete(i)
     Else
       re = New RegExp(segments[i], "^[A-Z][A-Z][A-Z]")
       If re.Offset = -1 Then
         ' merge with previous line
         segments[i - 1] = segments[i - 1] & segments[i]
         segments.Delete(i)
       Else
         Inc i
       Endif
     Endif
   Wend
   Print segments[8]
   curr = 0
   segment_parsed = Null
   
End Sub

Public Function Get_segments() As String[]
   
   'please leave in just for a while
   Return segments 
   
End

Private Function Number_Read() As Integer
   
   Return curr
   
End

Private Function Segment_Read() As String
   
   Return Left$(segments[curr], 3)
   
End

Public Function Next(find_segment As String, Optional end_segment As String = "***", end_segment2 As String = "***", end_segment3 As String = "***") As Boolean
   
   Dim segname As String
   
   If IsNull(segment_parsed) And Left$(segments[curr], 3) = find_segment Then
      Return True
   Endif
   Do 
      If curr >= segments.Length - 1 Then
         Return False
      Else
         curr = curr + 1
         segname = Left$(segments[curr], 3)
         If segname = end_segment Or segname = end_segment2 Or segname = end_segment3 Then
            curr = curr - 1
            Return False
         Else
            If segname = find_segment Then
               segment_parsed = Null
               Return True
            Endif
         Endif
      Endif
   Loop
   
End 

Public Function _get(field As Integer, Optional subfield As Integer = -1) As String
   
   Dim subfields As String[]
   'field -= 1 FIXME RICHARD ACTIVATE THIS LINE AFTER YOU CHANGE ALL THE SEGEMENT CONSTANTS
   If IsNull(segment_parsed)
      segment_parsed = Split(Conv$(segments[curr], codeset, Desktop.Charset), "|")
   Endif
   If field >= segment_parsed.Length Then
      Return ""
   Endif
   If subfield = -1 Then
      Return segment_parsed[field]
   Else
      subfields = Split(segment_parsed[field], "^")
      Try Return subfields[subfield]
      ' Try Return subfields[subfield]
      If Error Then Return ""
   Endif
   
End

' this is quick convience function to unpack a complex field into a collection

Public Function GetField(field As Integer, names As String[]) As Collection
   
   Dim subfields As String[]
   Dim coll As New Collection
   Dim i As Integer
   
   subfields = Split(Me[field], "^")
   For i = 0 To Min(subfields.Count - 1, names.Count - 1)
      coll[names[i]] = subfields[i]
   Next
   Return coll
   
End

Public Function GetFieldAsName(field As Integer) As String
   
   Dim subfields As String[]
   
   If Me[field] = ""
      Return ""
   Endif
   subfields = Split(Me[field], "^")
   Return subfields[modHL7Constants.RQ_Provider_Title] & " " & subfields[modHL7Constants.RQ_Provider_Firstname] & " " & subfields[modHL7Constants.RQ_Provider_Surname] 
   
End

Public Function GetNameAsCollection(field As Integer) As Collection 
   '-------------------------------------------------------------------------------------------------------
   'Getting the name should be simple however these sort of variations occur
   'firstname^surname, surname^firstname, surname^firstname^provider_no (pn sometimes wrong or extra digits)
   'or missing, sometimes titles stuck in there, sometimes incorrect number of hats!
   'Yes in theory you should just be able to pull in the provider number segment but its not that simple
   'sometime even eg Dr J Smith 34522Y   
   'e.g if parsing OBR-16 or ORC-12:
   '
   ' 4.5.1.16 Ordering provider (XCN) 00226
   ' 
   ' Components: <ID number (ST)> ^ <family name (ST)> ^ <given name (ST)> ^ <middle initial or name (ST)> ^ <suffix (e.g., JR or III) (ST)> ^ <prefix (e.g., DR) (ST)> ^ <degree (e.g., MD) (ST)> ^ <source table (IS)> ^ <assigning authority (HD)> ^ <name type code(ID)> ^ <identifier check digit (ST)> ^ <code identifying the check digit scheme employed (ID )> ^ <identifier type code (IS)> ^ <assigning facility (HD)>
   ' 
   ' Subcomponents of assigning authority: <namespace ID (IS)> & <universal ID (ST)> & <universal ID type (ID)
   ' 
   ' Subcomponents of assigning facility: <namespace ID (IS)> & <universal ID (ST)> & <universal ID type (ID)
   ' 
   ' Definition: This field identifies the provider who ordered the test. Either the ID code or the name, or both, may be present. This is the same as ORC-12-ordering provider. 
   '
   ' 08/2014: now more crap from HAPS |2960669J^DR S ADERA,|
   '-------------------------------------------------------------------------------------------------------

   Dim subfields As String[]
   Dim C As New Collection 
   Dim bits As String[]
   Dim r As Collection 
   Dim tempstring As String
   
   If Me[field] = ""
      Return C
   Endif
   tempstring = Me[field]
   If InStr(tempstring, ",") Then 
      tempstring = Trim(Replace(tempstring, ",", " ")) 'eg now  |2960669J^DR S ADERA,| could be |2960669J^DR S ADERA|
   End If 
   subfields = Split(tempstring, "^")
   Select Case subfields.Length
      Case 1
         c!surname = subfields[0]
         Return c
      Case 2
         'assume idiocy eg HAPS (John Hunter), also interesting laverty
         'This is HAPS crap - usually like this Dr J Smith, laverty sometimes doesn't put in all the hats
         bits = Split(subfields[modHL7Constants.RQ_Provider_Surname], " ")
         Select Case bits.Count
            Case 2
               c!title = "Dr" ' at a guess
               c!provider_number = subfields[0]
               c!firstname = Replace$(bits[0], ".", " ")
               c!surname = bits[1]
            Case 3
               c!provider_number = subfields[0]
               c!title = Replace$(bits[0], ".", " ")
               c!firstname = Replace$(bits[1], ".", " ")
               c!surname = bits[2]
         End Select
         Return c
      Case 3 'eg have received this |^surname^Mrs| (see above for what it should contain) Genie spits this stuff out
         'this is essentiall unparsable
         c!title = "Unknown"
         c!provider_number = subfields[0]
         c!firstname = subfields[2]
         c!surname = subfields[1]
         Return c
        'ian reviewion 1899
     ' Case 3   ' only one case seen
     '    If subfields[0] = "" Then
     '      c!surname = subfields[1]
     '      c!firstname = subfields[2]
     '      Return c
     '    Else
     '       ' really guessing now
     '       c!surname = subfields.Join(" ")
     '       Return c
     '    Endif
      Case 4   'only ever seen one case of 4, the 3, 4th were empty anway
         bits = Split(subfields[modHL7Constants.RQ_Provider_Surname], " ")
         c!title = "Dr" ' at a guess
         c!provider_number = subfields[0]
         c!firstname = Replace$(bits[0], ".", " ")
         c!surname = bits[1]
         Return c 
      Case Else
         '----------------------------------------------------------------------
         'Ian problem here: some hl7 has names like this Dr^PETER SMITH
         'but others genuinely have a space in the surname eg De Lyall^Fred^^^Dr
         'this falls over
         'This also crashes this segment:
         'UUH^UNIFIED HEALTHCARE^^^^^^^LOCNATA2203|
         'Haps has some like 458332T^DR R Terry ^^^^^^^^^^^^^^^(12 of these ^~458332T'
         'even the health link test message is f*'d  eg. 0123456L^HEALTHLINK^HEALTH ^DR^AUSHICPR
         'I don't think there is  a good solution here
         '-----------------------------------------------------------------------
         c!provider_number = subfields[modHL7Constants.RQ_Provider_Provider_Number]
         c!firstname = subfields[modHL7Constants.RQ_Provider_Firstname]
         c!surname = subfields[modHL7Constants.RQ_Provider_Surname] 
         Try c!title = subfields[modHL7Constants.RQ_Provider_Title]
         If Error Then  'I give up this could be an ywhere amongst the myriad of f*ing hats
            c!title = "Unknown"
         Endif
         '----------------------------------------------------------------------------------------------------
         'ok, we could be fucked here  has some like 458332T^DR R Terry ^^^^^^^^^^^^^^^(12 of these ^~458332T
         'Last penultimate last ditch effort, look up by provider number
         '----------------------------------------------------------------------------------------------------
         If c.count <> 4 Then
            r = modDBConnect.exec_query_first("Select * from admin.vwstaffinclinics where provider_number= $$" & c!provider_number & "$$")
            If IsNull(r) Then
               'really last ditch, sometimes they stick a zero in front of a0 provider number which may not be needed
               If Left(c!provider_number) = "0" Then
                  c!provider_number = Right(c!provider_number, Len(c!provider_number) - 1)
                  r = modDBConnect.exec_query_first("Select * from admin.vwstaffinclinics where provider_number= $$" & c!provider_number & "$$")
               End If
               If Not IsNull(r) Then
                  c!firstname = r!firstname
                  c!surname = r!surname
                  c!title = r!title                        
               End If
            Else
               c!firstname = r!firstname
               c!surname = r!surname
               c!title = r!title
            End If
         End If
         Return C
   End Select
   
End

Static Public Function FreeText_Format(ft As String, style As Integer) As String
   
   Dim substs As String[]
   Dim i As String
   Dim charpos As Integer
   Dim url As String 
   '---------------------
   'THE REPORT IS AVAILABLE TO VIEW ONLINE: http://www.medinexus.com.au/login/?id=22302810 \N\
   'insert any hyperlinks: IAN FIXME
   '<A HREF="http://www.gpaccess.com.au/">gpAccess</A>
   '---------------------
   If InStr(ft, "http://www") Then
      charpos = InStr(ft, "http:")
      url = Mid$(ft, charpos, InStr(ft, "\\N\\") - charpos)
      ft = Replace(ft, url, "<A HREF='" & url & "'>online report</A>")
   Endif
   'Eliminate some crappy formatting eg _Hba1c, _Glucose, _PSA
   substs = ["_BHCG PREG VIRTUAL", "_Creatinine Clearance", "_Cardiac markers", "_Hba1c", "_Glucose", "_PSA", "Routine Biochemistry", "_HAEMATOLOGY", "_BLOOD BANK", "_Hepatitis B Serology", "_Iron Studies", "_B12/Folate/RCF", "_Renin/Aldosterone", "_FERTILITY VIRTUAL", "_Thyroid Function", "_Rubella Serology", "_APOLIPOPROTEINS", "_URINE Drug Screen", "_Hepatitis Serology", "_Syphilis"] 
   If Style = const.Document_Display_As_Result Then 
      For Each i In substs
         ft = Replace$(ft, i, "", gb.IgnoreCase)
      Next
   End If
   ft = Replace$(ft, "\\F\\", "|")
   ft = Replace$(ft, "\\S\\", "^")
   ft = Replace$(ft, "\\T\\", " & ")
   substs = ["Your reference", "Report date", "Report:", "Comment:"]
   For Each i In substs
      ft = Replace$(ft, i, "<BR/><B>" & i & "</B>", gb.IgnoreCase)
   Next
   substs = ["Consultation date", "Clinical History", "Findings", "Views", "ECG Summary:", "Clinical notes", "SUMMARY", "Impression", "Conclusion", 
      "Summary:", "Exam date:", "History:", "Examination:", "MACROSCOPIC EXAMINATION", "MACROSCOPIC:", "CONCLUSION", "MICROSCOPIC EXAMINATION", "MICROSCOPIC:", "HISTOPATHOLOGY REPORT", "DIAGNOSIS", "Myocardial Perfusion Imaging",
      "GLUCOSE TOLERANCE TEST:", "CULTURE", "SENSITIVITIES", "WOUND SWAB", "EYE SWAB", "GRAM STAIN", "CYTOPATHOLOGY REPORT", 
      "URINE", "MICROSCOPY:", "CHEMISTRY:", "MOLECULAR BIOLOGY", "Site:", "Diagnostic Category:", "Specific Findings:", 
      "Recommendation:", "Specimen Adequacy:", "Pap Test Register Consent:", "Dose given", "HEPATITIS SEROLOGY", "Recommendations:"]
   If style = const.Document_Display_As_Result        
      For Each i In substs
         ft = Replace(ft, i, "<BR/><B>" & i & "</B>", gb.IgnoreCase)
      Next
   End If
   ft = Replace(ft, "\\.br\\", "<BR>", gb.IgnoreCase) 
   
   ft = Replace(ft, "\\.nf\\", " ", gb.IgnoreCase)
   ft = Replace(ft, "\\h\\", "<B>", gb.IgnoreCase)
   ft = Replace(ft, "\\n\\", "</B>", gb.IgnoreCase)
   Return ft
   
End
