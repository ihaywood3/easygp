' Gambas class file

' Copyright (C) 2010-2014 Dr. Ian Haywood

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.

Public segments As String[]
Private segment_parsed As String[]
Private curr As Integer
Private codeset As String = "ISO-8859-1" ' the Windows charset: sadly a safe assumption
Property Read Number As Integer
Property Read Segment As String

Public Sub _new(txt As String) 
   'read an hl7 file and splits into segments
   'takes into accound illegal internal \r (carriage return's) within a segment e.g in a letter
   
   Dim i As Integer
   Dim re As RegExp
   
   If txt = "" Then Return
   If Left$(txt, 1) = "/" Then ' it's a filename
      txt = File.Load(txt)
   Endif
   txt = modHL7FileImport.Make_ASCII_Safe(txt)         'remove microsoft crap character's which upset postgres
   segments = Split(txt, "\r")
   If segments.Length = 1 Then
      segments = Split(txt, "\n")
   Endif
   If segments.Length > 1 Then
      If Left$(segments[1], 1) = "\n" Then            ' naughty, naughty, someone's using MS-DOS style newlines
         For i = 1 To segments.Length - 1
            segments[i] = Right$(segments[i], -1)
         Next
      Endif
   Endif
   ' check for inappropriate use of \r
   i = 1
   While i < segments.Length
      If IsNull(segments[i]) Or If Len(segments[i]) = 0 Then
         segments.Delete(i)
      Else
         re = New RegExp(segments[i], "^[A-Z][A-Z][A-Z0-9]\\|")
         If re.Offset = -1 Then
            ' merge with previous line
            segments[i - 1] = segments[i - 1] & segments[i]
            segments.Delete(i)
         Else
            Inc i
         Endif
      Endif
   Wend
   curr = 0
   segment_parsed = Null
   
End Sub

Private Function Number_Read() As Integer
   
   Return curr
   
End

Private Function Segment_Read() As String
   
   Return Left$(segments[curr], 3)
   
End

Public Function Next(find_segment As String, Optional end_segment As String = "***", end_segment2 As String = "***", end_segment3 As String = "***") As Boolean
   
   Dim segname As String
   
   If IsNull(segment_parsed) And Left$(segments[curr], 3) = find_segment Then
      Return True
   Endif
   Do 
      If curr >= segments.Length - 1 Then
         Return False
      Else
         curr = curr + 1
         segname = Left$(segments[curr], 3)
         If segname = end_segment Or segname = end_segment2 Or segname = end_segment3 Then
            curr = curr - 1
            Return False
         Else
            If segname = find_segment Then
               segment_parsed = Null
               Return True
            Endif
         Endif
      Endif
   Loop
   
End 

Public Function _get(field As Integer, Optional subfield As Integer = -1) As String
   
   Dim subfields As String[]
   'field -= 1 FIXME RICHARD ACTIVATE THIS LINE AFTER YOU CHANGE ALL THE SEGEMENT CONSTANTS
   If IsNull(segment_parsed)
      segment_parsed = Split(Conv$(segments[curr], codeset, Desktop.Charset), "|")
   Endif
   If field >= segment_parsed.Length Then
      Return ""
   Endif
   If subfield = -1 Then
      Return segment_parsed[field]
   Else
      subfields = Split(segment_parsed[field], "^")
      Try Return subfields[subfield]
      If Error Then Return ""
   Endif
   
End

' this is quick convience function to unpack a complex field into a collection
Public Function GetField(field As Integer, names As String[]) As Collection
   
   Dim subfields As String[]
   Dim coll As New Collection
   Dim i As Integer
   
   subfields = Split(Me[field], "^")
   For i = 0 To Min(subfields.Count - 1, names.Count - 1)
      coll[names[i]] = subfields[i]
   Next
   Return coll
   
End

Public Function GetFieldAsName(field As Integer) As String
   
   Dim subfields As String[]
   
   If Me[field] = ""
      Return ""
   Endif
   subfields = Split(Me[field], "^")
   Return subfields[modHL7Constants.RQ_Provider_Title] & " " & subfields[modHL7Constants.RQ_Provider_Firstname] & " " & subfields[modHL7Constants.RQ_Provider_Surname] 
   
End

Public Function No_Data_In_Fields(subfields As String[]) As Boolean
   '---------------------------------------------------------------------------------- 
   'returns True if no useful data in the subfields eg splits to empty fields contents
   '---------------------------------------------------------------------------------- 
   
   Dim subfield As String
   
   For Each subfield In subfields
      If Trim(subfield) <> "" Then
         Return
      End If
   Next
   Return True
   
End

Public Function GetNameAsCollection(seg_name As String, field As Integer, Optional multiple_name_index As Integer = -1) As Collection 
   '-------------------------------------------------------------------------------------------------------------------------------
   'extracts name (person/doctor setc) From a segment, returns empty(Not Null)collection If fails
   'Getting the name should be simple however these sort of variations occur: 
   'firstname^surname,
   'surname^firstname, 
   'surname^firstname^provider_no (pn sometimes wrong or extra digits)
   '|2960669J^DR S ADERA,|
   '|^^| - just empty hats
   'or missing, sometimes titles stuck in there, sometimes incorrect number of hats!
   'I could go on on on... every conceivable variation of stupidy exists
   'Yes in theory you should just be able to pull in the provider number segment but its not that simple
   'sometime even eg Dr J Smith 34522Y   
   'e.g if parsing OBR-16 or ORC-12:
   'Select5
   ' 4.5.1.16 Ordering provider (XCN) 00226
   ' 
   ' Components: <ID number (ST)> ^ <family name (ST)> ^ <given name (ST)> ^ <middle initial or name (ST)> ^ <suffix (e.g., JR or III) (ST)> ^ <prefix (e.g., DR) (ST)> ^ <degree (e.g., MD) (ST)> ^ <source table (IS)> ^ <assigning authority (HD)> ^ <name type code(ID)> ^ <identifier check digit (ST)> ^ <code identifying the check digit scheme employed (ID )> ^ <identifier type code (IS)> ^ <assigning facility (HD)>
   ' 
   ' Subcomponents of assigning authority: <namespace ID (IS)> & <universal ID (ST)> & <universal ID type (ID)
   ' 
   ' Subcomponents of assigning facility: <namespace ID (IS)> & <universal ID (ST)> & <universal ID type (ID)
   ' 
   ' Definition: This field identifies the provider who ordered the test. Either the ID code or the name, or both, may be present. This is the same as ORC-12-ordering provider. 
   '
   ' 08/2014: now more crap from HAPS |2960669J^DR S ADERA,|
   '--------------------------------------------------------------------------------------------------------------------------------
   
   Dim subfields As String[]
   Dim C As New Collection 
   Dim bits As String[]
   Dim r As Collection 
   Dim tempstring As String
   Dim substring As String
   Dim icounter As Integer
   Dim bHaveProviderNumber As Boolean
   Dim subfields1 As String[]
   Dim bReplacedcommas As Boolean
   Dim bNoUsefulData As Boolean
   
   If Me[field] = "" Then 
      Return C
   Endif
   If multiple_name_index <> -1 Then
      tempstring = Split(Me[field], "~")[multiple_name_index] 'multiple copy to names fixme only looking at first one now
   Else
      tempstring = Me[field]
   End If 
   If InStr(tempstring, ".") Then 
      tempstring = Trim(Replace(tempstring, ".", "")) 'eg now  |2960669J^DR. S ADERA,| could be |2960669J^DR S ADERA| or any title with . e.g Dr. > Dr 
   End If 
   tempstring = Trim(tempstring)
   tempstring = Trim(modUtilGUI.Strip_Last_Character(tempstring, True))  'strip any ending fullstops of comma's off eg 'Dr R Cervantes,' from HAPS
   subfields = Split(tempstring, "^")
   If No_Data_In_Fields(subfields) Then  'This is usually OBR(28) copy to where e.g HAPS put in |^ with no data
      Return c
   Endif
   Select Case seg_name
      Case "PRD"
         '---------------------------------------------------------------------------------------------------------------------
         ' Components: <family name (ST)> ^ <given name (ST)> ^ <middle initial or name (ST)> ^ <suffix (e.g., JR or III) (ST)> ^ <prefix (e.g., DR) (ST)> ^ <degree (e.g., MD) (ST)> ^ <name type code (ID) >
         ' Definition: This field contains the name of the provider identified in this segment. Generally, this field will describe a physician associated with the referral.
         ' However, it is not limited to physicians. This field may contain the name of any valid healthcare provider associated with this referral.
         ' If this Provider Name is a physicianâ€™s name, you may refer to PRD-1-provider identifiers (Section 11.5.3.7) for the physician identifier.
         ' Samples:
         '       GPAcess |Dr Jon Kochanski| << i.e does not conform
         '       Others |McGrath^Shaun^^^Dr^^^|
         ' First does it conform - it, are there hats
         ' -------------------------------------------------------------------------------------------------------------------------------------------
         If subfields.Length = 1 And InStr(subfields[0], " ") Then
            Subfields = Split(subfields[0], " ")
         End If 
         If subfields.max > 2 Then   
            If InStr("mrs,dr,prof,ms,miss,mst,master", Lower(subfields[0])) Then
               c!title = Replace(subfields[0], ".", "")  
               c!firstname = subfields[1]
               c!surname = subfields[2]
               Return c
            Endif
         End If   
         If Subfields.Max > 3 Then   
            If InStr("mrs,dr,prof,ms,miss,mst,master", Lower(subfields[4])) Then
               subfields[4] = Replace(subfields[4], ".", "")
               c!title = subfields[4]
               c!firstname = subfields[1]
               c!surname = subfields[0] 
               Return c
            Else
               c!firstname = subfields[1]
               c!surname = subfields[0] 
               Return c
            Endif
         End If   
         
         If Subfields.Length = 3 Then
            If InStr("mrs,dr,prof,ms,miss,mst,master", Lower(subfields[0])) Then
               c!title = Replace(subfields[0], ".", "")
            Endif
            c!firstname = subfields[1]
            c!surname = Subfields[2]
            Return c 
         Endif
         If subfields.Length = 2 Then   'ok, sometimes not a doctor and no title eg Ellen Smith
            If InStr("mrs,dr,prof,ms,miss,mst,master", Lower(subfields[0])) Then
               c!title = Replace(subfields[0], ".", "")
            Endif
            If InStr("mrs,dr,prof,ms,miss,mst,master", Lower(subfields[1])) Then
               c!title = Replace(subfields[1], ".", "")
            Endif
            If modContactsDBI.Is_Firstname(subfields[0]) Then
               c!firstname = subfields[0]
               c!surname = Subfields[1]
               Return c 
            Else
               c!firstname = subfields[1]
               c!surname = Subfields[0]
               Return c
            Endif
         End If  
         If subfields.Length = 1 Then 
            c!surname = subfields[0]
            Return c      
         End If   
      Case "PV1", "ORC", "OBR"
         '----------------------------------------------------------------------------------------------------------------------
         ' The PV1 segment is used by Registration/ADT applications to communicate information on a visit-specific basis. 
         ' This segment can be used to send multiple-visit statistic records to the same patient account or single-visit records
         ' to more than one account. Individual sites must determine the use for this segment. 
         ' .eg 458332T^Terry^^Richard^^^Dr^^^L^^^UPIN^^
         '         ' Sometimes the hats are not in the correct position
         ' field(7) = Attending Doctor
         ' field(8) = Referring Doctor
         ' field(9) = Consulting Doctor .... but often this convention not adhered to
         ' subfields (5) or (6) usually hold the title
         ' The ORC segment = common order segment and ORC(12) should be the same as OBR(16) 'ordering provider'
         ' Sometimes this seg contains variations lik this
         ' Dr R Terry
         ' Dr Terry R
         ' Terry R DR
         ' provider_no^Dr R Terry
         ' provider_no^Terry Richard etc, it goes on for-ever will add exceptions as they occur
         ' ---------------------------------------------------------------------------------------------------------------------
         If modUtil.Provider_Number_Check(subfields[0]) <> "*INVALID*" Then                                'if have a provider number, one of the above patterns will exist
            c!provider_number = subfields[0]
         Else          'won't try too hard eg may get this |^surname^title| < crap hl7
            If subfields.max > 1 Then
               c!surname = subfields[1]
               c!firstname = subfields[2] 
            Endif
         End If   
         If subfields.Length = 2 Then 
            If Not IsNull(c!provider_number) And InStr(subfields[1], " ") Then   'e.g Dr A Doctor
               subfields = Split(Replace(subfields[1], ".", ""), " ")      'get rid of fullstops (yes haps put them after titles, surnames sometimes)
               If subfields.Length = 3 Then 'eg Dr A Doctor
                  If InStr(Lower("Mrs,Dr,Prof,Ms,Miss,Mst,Master"), Lower(subfields[0])) Then 
                     c!title = subfields[0]
                     c!firstname = subfields[1]
                     c!title = subfields[2]
                     Return c
                  End If   
               Endif  
            End If    
         End If        
         If subfields.max > 4 Then 
            If InStr(Lower("Mrs,Dr,Prof,Ms,Miss,Mst,Master"), Lower(subfields[5])) Then 
               c!title = Replace(subfields[5], ".", "")
            End If      
         End If   
         If subfields.max > 5 Then
            If InStr(Lower("Mrs,Dr,Prof,Ms,Miss,Mst,Master"), Lower(subfields[6])) Then 
               c!title = Replace(subfields[6], ".", "")
            End If   
         End If  
         If subfields.Length <> 1 Then   
            c!surname = subfields[1]
            c!firstname = subfields[2]
            Return c
         End If   
         
   End Select
 '  Message.Info ("Richard returning emtpy collection")
   Return c
   
End

Static Public Function FreeText_Format(ft As String, style As Integer) As String
   
   Dim substs As String[]
   Dim i As String
   Dim charpos As Integer
   Dim url As String 
   '---------------------
   'THE REPORT IS AVAILABLE TO VIEW ONLINE: http://www.medinexus.com.au/login/?id=22302810 \N\
   'insert any hyperlinks: IAN FIXME
   '<A HREF="http://www.gpaccess.com.au/">gpAccess</A>
   '---------------------
   If InStr(ft, "http://www") Then
      charpos = InStr(ft, "http:")
      url = Mid$(ft, charpos, InStr(ft, "\\N\\") - charpos)
      ft = Replace(ft, url, "<A HREF='" & url & "'>online report</A>")
   Endif
   'Eliminate some crappy formatting eg _Hba1c, _Glucose, _PSA
   substs = ["_BHCG PREG VIRTUAL", "_Creatinine Clearance", "_Cardiac markers", "_Hba1c", "_Glucose", "_PSA", "Routine Biochemistry", "_HAEMATOLOGY", "_BLOOD BANK", "_Hepatitis B Serology", "_Iron Studies", "_B12/Folate/RCF", "_Renin/Aldosterone", "_FERTILITY VIRTUAL", "_Thyroid Function", "_Rubella Serology", "_APOLIPOPROTEINS", "_URINE Drug Screen", "_Hepatitis Serology", "_Syphilis"] 
   If Style = const.Document_Display_As_Result Then 
      For Each i In substs
         ft = Replace$(ft, i, "", gb.IgnoreCase)
      Next
   End If
   ft = Replace$(ft, "\\F\\", "|")
   ft = Replace$(ft, "\\S\\", "^")
   ft = Replace$(ft, "\\T\\", "&amp;")
   ft = Replace$(ft, "\\R\\", "~")
   ft = Replace$(ft, "\\E\\", "\\")
   substs = ["Your reference", "Report date", "Report:", "Comment:"]
   For Each i In substs
      ft = Replace$(ft, i, "<BR/><B>" & i & "</B>", gb.IgnoreCase)
   Next
   substs = ["Consultation date", "Clinical History", "Findings", "Views", "ECG Summary:", "Clinical notes", "SUMMARY", "Impression", "Conclusion", 
      "Summary:", "Exam date:", "History:", "Examination:", "MACROSCOPIC EXAMINATION", "MACROSCOPIC:", "CONCLUSION", "MICROSCOPIC EXAMINATION", "MICROSCOPIC:", "HISTOPATHOLOGY REPORT", "DIAGNOSIS", "Myocardial Perfusion Imaging",
      "GLUCOSE TOLERANCE TEST:", "CULTURE", "SENSITIVITIES", "WOUND SWAB", "EYE SWAB", "GRAM STAIN", "CYTOPATHOLOGY REPORT", 
      "URINE", "MICROSCOPY:", "CHEMISTRY:", "MOLECULAR BIOLOGY", "Site:", "Diagnostic Category:", "Specific Findings:", 
      "Recommendation:", "Specimen Adequacy:", "Pap Test Register Consent:", "Dose given", "HEPATITIS SEROLOGY", "Recommendations:"]
   If style = const.Document_Display_As_Result        
      For Each i In substs
         ft = Replace(ft, i, "<BR/><B>" & i & "</B>", gb.IgnoreCase)
      Next
   End If
   ft = Replace(ft, "\\.br\\", "<BR>", gb.IgnoreCase) 
   
   ft = Replace(ft, "\\.nf\\", " ", gb.IgnoreCase)
   ft = Replace(ft, "\\h\\", "<B>", gb.IgnoreCase)
   ft = Replace(ft, "\\n\\", "</B>", gb.IgnoreCase)
   Return ft
   
End
