' Gambas class file

' Copyright (C) 2008-2012 Dr. Richard Terry

' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.

' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.

' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'-------------------------------------------------------------------
' PURPOSE        To import legacy data
' TODO           Just about everything this is only just started
'                check are getting all the comm types
' BUGS           Millions, in practice this module won't work at all
' ------------------------------------------------------------------
Private oddoccupations As String[] 
Private OddRecords As Collection
Private rejected_records As Collection
Private patients As Collection 
Private patient As Collection 
Private surname As Integer = 0
Private firstname As Integer = 1
Private birthdate As Integer = 2
Private social_history As Integer = 3
Private sLineInput As String
Private currentconsult As CConsult
Private import_dir As String = User.home &/ "easygp/import/"
Private Errorfile As File
Private hfile As File
Private FICPC As FICPCBrowser
Private Form_directorychooser As FDirectoryChooser
Private Form_Help As FHtmlViewer 
Private json_string As String
Private skipped_towns As Collection 
Private skipped_town As Collection 
Private missing_towns As Collection 
Private missing_town_count As Integer
Private misspelt_towns As Collection
Private misspelt_town As Collection
Private bSkipTown As Boolean
Public fk_town As Integer
Private Corrected_Town As Collection
Private hLog_file As File

Static Private Form_Legacy_Data_Import As FImportLegacyData

Static Public Sub Corrected_Towns_Set(Town As Collection)
   
   Form_Legacy_Data_Import.Set_Corrected_Town(town)
   
End

Public Sub Set_Corrected_Town(town As Collection)
   'collection =  the real name, the real key
   
   Corrected_Town = town
   fk_town = town!pk
   
End

Public Sub form_Open()
   
   init()
   
End

Public Sub init()
   
   Form_Legacy_Data_Import = Me
   With Form_Help = New FHtmlViewer(Vbox_Help)
      .tbWebBrowserZoomIn.Visible = True
      .tbWebBrowserZoomOut.Visible = True  
      .Help_Show("importing-data-from-other-systems.html")
   End With
   Try Settings_Load()
   cmbMedicalProgram.Add("DrsDesk")
   cmbMedicalProgram.Add("Medical Director V2")
   cmbMedicalProgram.Add("Medical Director V3")
   cmbMedicalProgram.Add("Best Practice") 
   cmbMedicalProgram.Add("Profile")
   cmbMedicalProgram.Add("Genie")
   cmbMedicalProgram.Add("Medibase")
   txtPastHistoryPath.text = User.home &/ "easygp/import/Exported_PastHistory_small.txt" 'fixme
   lblmeasure.text = "  Import Patient Demographics  "
   modEditAreaHelpers.Resize_labels(Vbox_EditArea, lblmeasure)
   txtImportDirectory.text = "/home/richard/easygp/import"
   '  txtImportDirectory.text = "/home/richard/horst/MEDIBASE_EXPORT/" 'FIXME REMOVE ME
   
End

Public Sub Settings_Save()
   
   Settings["Legacy Data Import/HSplit_ImportLegacy.Layout"] = HSplit_ImportLegacy.Layout
   Settings["Legacy Data Import/VSplit_Legacy.Layout"] = VSplit_Legacy.layout
   Settings["Legacy Data Import/HSplit_Legacy.layout"] = HSplit_Legacy1.layout
   Settings["Legacy Data Import/import_file_dir"] = Trim(txtImportDirectory.text)

End

Private Sub Settings_Load()
   
   Try HSplit_ImportLegacy.Layout = Settings["Legacy Data Import/HSplit_ImportLegacy.Layout"]
   Try VSplit_Legacy.layout = Settings["Legacy Data Import/VSplit_Legacy.Layout"]
   Try HSplit_Legacy1.layout = Settings["Legacy Data Import/HSplit_Legacy.Layout"]
   Try txtImportDirectory.text = Settings["Legacy Data Import/import_file_dir"]

End

Public Sub chkLegacyData_Click()
   
   '-------------------------------------------------------------------
   'User has checked a box, wants to load legacy data for this segment
   'Search for the children of the Hbox the checkbox is in, when find
   'the only other Hbox which contains the toolbutton, enable or
   'disable the toolbutton according to whether the checkbox is checked
   '-------------------------------------------------------------------
   Dim hCtrl As Control
   Dim hCtrl1 As Control
   Dim aBox As Hbox
   Dim tb As Toolbutton
   Dim aTextBox As Textbox
   
   For Each hCtrl In Last.parent.children
      If hctrl Is Hbox Then
         aBox = hctrl
         Break
      End If
   Next
   For Each hCtrl In aBox.Children
      If hctrl Is Toolbutton Then
         tb = hctrl
         tb.Enabled = Last.value
         If Last.value = False Then
            For Each hCtrl1 In Last.parent.children
               If hCtrl1 Is TextBox Then
                  aTextbox = hCtrl1
                  aTextbox.text = "" 
               End If
            Next
         End If        
      End If
   Next
   
End

Public Sub tbSelectlegacyFile_Click()
   '---------------------------------------------
   'Select a file to import demographic data from
   '---------------------------------------------
   
   Dim hfile As File
   Dim sFilename As String
   Dim sLineInput As String
   Dim hCtrl As Control
   Dim aTextbox As Textbox
   Dim x As Integer
   
   'Dialog.Path = EasyGP.dir_root & "import/"
   '------------------------------
   'No file to process, then leave
   '------------------------------
   If Dialog.OpenFile() Then Return
   '-----------------------------------------
   'file to process, then put its name in the
   'corresponding textbox on the screen
   '-----------------------------------------
   For Each hctrl In Last.parent.parent.children
      If hctrl Is Textbox Then
         aTextbox = hctrl
         aTextbox.text = Dialog.Path
         ' tbImportExport.Enabled = True
         Break
      End If
   Next
   
End

Public Sub txtLegacyImportPath_LostFocus()
   
   Last.pos = 1
   
End

Public Sub SocialHistory_Import()
   '--------------------------------------------------------------
   'Imports the patients social history initially only DrsDesk
   'The DrsDesk social history came from a multi-line text control
   'so sometimes users inserted a CR by mistake.
   'Due to the social history text containing internal CR's
   'I've stuck a field on the end of the import data |end, so
   'that where this code splits a line in the middle of a 
   'social history field, I can detect and repair it
   '--------------------------------------------------------------
   
   Dim $Result As Result
   Dim sql As String
   Dim cons As CConsult
   Dim sfilename As String 
   Dim Errorfile As File
   Dim bits As String[]
   Dim skipcode As Boolean
   Dim x As Integer
   Dim y As Integer
   Dim missingpatients As Integer
   Dim bError As Boolean
   Dim badfilename As Integer
   Dim sFileError As String
   Dim anError As Error
   Dim bLineComplete As Boolean
   Dim sIncompleteLine As String
   Dim ICPCTerm As Collection 
   Dim SH As Collection 
   Dim Errorcount As Integer
   'open an error file to log errors
   
   modDBConnect.BeginTrans()
   patients = New Collection 
   '  ErrorFile = Open import_dir & "/socialhistory_import_errors.txt" For Write Create
   '-------------------------------------------------
   'Insist on at least some sort of attempt at a name
   '-------------------------------------------------
   Sfilename = Trim(txtSocialHistoryPath.text)
   If sFilename = "" Then 
      txtSocialHistoryPath.SetFocus()
      Return
   End If
   '------------------------------------------------------------------
   'Attempt to open the designated file
   'If fail, given an appropriate understandable error message and exit
   '-------------------------------------------------------------------
   Try hfile = Open sfilename For Input
   If Error Then
      sFileError = File_IO_Describe_Error(Error.code)
      Message.Warning("Unable to open " & sFilename & "\n\n" & sFileError)
      Return
   End If
   '-------------------------------------------------------------------
   'So far so good - hourglass to user to indicate we are go for import
   '-------------------------------------------------------------------
   Inc Application.Busy
   lvDataImportProgressMessages.Clear()
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Starting social history import..............")
   'Patients = New collection
   '  While Not Eof(hfile)
   '------------------------------------------ 
   'Input each line and split at the delimeter
   '------------------------------------------
   '  Line Input #hfile, sLineInput 
   '    Inc x
   '    If x = 10 Then Return
   '  Wend
   While Not Eof(hfile)
      '------------------------------------------ 
      'Input each line and split at the delimeter
      'The data in DrsDesk is "dirty", there are 
      'carriage returns randomly in the text
      '------------------------------------------
      bLineComplete = False      'assume their is an internal CR to muck things up
      Line Input #hfile, sLineInput                'read single line gb.unix as default
      sIncompleteLine = sLineInput                 'use a copy
      Do Until Right(sIncompleteLine, 4) = "|end"  'does it have an ending
         Line Input #hfile, sLineInput              'No, then get the next line
         sIncompleteLine &= sLineInput          'and concatenate for re-testing
      Loop
      sLineInput = sIncompleteLine                 'line has an ending, keep going.
      bits = Split(sLineInput, "|")
      '----------------------------------------------------------
      'Create a new patient object add to the patients collection
      '----------------------------------------------------------
      patient = New Collection
      patient!firstname = bits[firstname]
      patient!surname = bits[surname]
      patient!birthdate = Val(bits[birthdate])
      If bits[firstname] = "" Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no firstname:" & patient!firstname & " " & patient!surname)
         bError = True
      End If
      If bits[surname] = "" Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no surname:" & patient!firstname & " " & patient!surname)
         bError = True
      End If
      If Year(patient!birthdate) = 0 Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no birthdate:" & patient!firstname & " " & patient!surname)
         Wait
         Inc Errorcount
         patient!birthdate = CDate("01/01/1901")
         Wait
         Inc Errorcount
         bError = True
      End If
      patients.Add(patient, patients.count)
      '--------------------------------------------------- 
      'Now match that patient to the demographic database
      '--------------------------------------------------- 
      sql = "Select * from contacts.vwPatients where "
      sql &= "firstname ILIKE $$" & patient!firstname & "$$ "
      sql &= " AND surname ILIKE $$" & patient!surname & "$$ "
      sql &= " AND birthdate ='" & Format(patient!birthdate, "dd/mm/yyyy") & "'"
      $Result = modDBConnect.exec_query(sql)
      If $Result.count = 1 Then
         patient!fk_patient = $Result!fk_patient
         lblImporting2.text = "Importing data for" & patient!firstname & " " & patient!surname 
         Wait
         '--------------------------------------------------
         'Ok we have a patient, so save their social history
         'Should we worry about the original data of entry
         'if yes, then add it later, for now, just use today
         'create a consult and retrieve pk_consult
         'necessary because every table linked to consult
         'fixme later: use only a single pk_consult for an
         'entire patients imported data
         '--------------------------------------------------
         '------------------------------------
         'class cSocialHistory
         '
         ' Public pk As Integer
         ' Public fk_consult As Integer
         ' Public history As String
         ' Public data_changed As String
         ' Public pk_progressnote As Integer   
         ' Public responsible_person As String
         '-------------------------------------
         
         currentconsult = New CConsult(patient)
         currentconsult.Set(const.ConsultType_DataImport, "Social History Imported")
         SH = New Collection
         SH!fk_consult = currentconsult.GetPK()
         SH!history = bits[social_history]
         
         SH!fk_socialhistory = modDBConnect.insert("clin_history.social_history", SH)
      Else
         If $Result.count > 1 Then
            Message.info("More than 1 patient found with same names and dob")
            Print patient
            lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "duplicate name:" & patient!firstname & " " & patient!surname)
            Inc MissingPatients
            Wait
         End If
         If $Result.count = 0 Then
            lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Not in Demographic Database:" & patient!firstname & " " & patient!surname)
            Wait
            Inc MissingPatients
         End If
      End If
      Inc x 
   Wend
   modDBConnect.CommitTrans()
   
   '  lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Import completed")
   '  lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "We imported " & Str(patients.count) & " patients")
   ' lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(missingpatients) & "missing or duplicated patients")
   ''
   
   Dec Application.busy
   
End

Public Sub DrsDesk_PastHistory_Import()
   '--------------------------------------------------------------
   ' Imports the patients past history initially only DrsDesk
   ' Adams|George|20/12/1925 0:00:00|M|289|1|35|7|Deafness||0|102008601|1960|0|0|0|1|0
   ' surname
   ' firstname
   ' birthdate
   ' sex
   ' ph_id
   ' active flag 0=not 1 = yes
   ' age_onset
   ' age_onset_units eg 7 = year 5 = week, 6 = month
   ' condition
   ' comment
   ' side body 0, 1=left, 2= right 3 = both
   ' ozcode
   ' date_onset
   ' operation
   ' cause death
   ' confidential
   ' significant
   ' deleted
   '-----------------------------------------------------------------------------------------------
   'From the ICPC-2 documentation:
   '
   ' After considering spelling, keyword length and term organisation if you
   ' still can't find the term you want:-
   ' In each software product, there should be a facility to enter the term in free text and apply a
   ' temporary code - J99. The term you record should be retained in the database and
   ' allocated a term code (so that the first time you use J99, the term you record will be saved
   ' as term number J99-001 and so on.) Your software should allow you to view your list of
   ' temporary terms. You could print out the list and post or fax it to the Family Medicine
   ' Research Centre so that the terms can be allocated to the correct ICPC-2 code and added
   ' to ICPC-2 PLUS with their term keys. The next upgrade you receive will therefore include the
   ' term, the correct code and term code. Your software should allow you to alter your original
   ' record to the correct code (of course always retaining the hidden audit trail of the change for
   ' medico-legal purposes).
   '-------------------------------------------------------------------------------------------------
   
   Dim $Result As Result
   Dim sql As String
   Dim LearntTerms As Result
   Dim cons As CConsult
   Dim sfilename As String 
   Dim unmatchables As New Collection
   Dim Unmatchable As Collection 
   Dim progressNote As String
   Dim fk_progressNote As Integer
   ' Dim sex As Integer = 3
   'Dim ph_id As Integer = 4
   Dim active As Integer = 3
   Dim age_onset As Integer = 4
   Dim age_onset_units As Integer = 5
   Dim condition As Integer = 6
   Dim comment As Integer = 7
   Dim lateralisation As Integer = 10
   Dim ozcode As Integer = 11
   Dim date_onset As Integer = 9
   Dim operation As Integer = 10
   Dim cause_death As Integer = 11
   Dim confidential As Integer = 12
   Dim significant As Integer = 13
   Dim Deleted As Integer = 13
   Dim Errorfile As File
   Dim bits As String[]
   Dim vwTerms As Collection 
   Dim skipcode As Boolean
   Dim x As Integer
   Dim y As Integer
   Dim missingpatients As Integer
   Dim bError As Boolean
   Dim badfilename As Integer
   Dim learntTerm As Collection
   Dim iTemporaryProblemKey As Integer
   Dim sFileError As String
   Dim anError As Error
   Dim bLineComplete As Boolean
   Dim sIncompleteLine As String
   Dim past_history_item_count As Integer 
   Dim sLastPatient As String
   Dim scurrentPatient As String
   Dim bValidPatient As Boolean
   Dim PH As CRow 
   Dim PastHistory As Collection 'of all PH
   Dim a_term As Collection 
   Dim icpc_terms As Collection
   Dim icd10_terms As Collection
   Dim J_code_count As Integer 
   Dim PN As CRow 
   Dim import_count As Integer
   
   modDBConnect.BeginTrans()
   
   icpc_terms = modDBConnect.exec_query_collection("Select * from coding.icpc2_terms")
   ' icd10_terms = modDBConnect.exec_query_collection("Select code as pk_code, term  from coding.lu_icd10")
   icd10_terms = modDBConnect.exec_query_collection("Select code as pk_code, term  from coding.generic_terms where fk_coding_system = 2")
   sql = ""
   "SELECT distinct"
   "  icpc2_terms.term as pk_view,"
   "  icpc2_terms.term, "
   "  icpc2_terms.term_code, "
   "  icpc2_terms.icpc_code, "
   "  icpc2_drsdesk_term_mapper.drsdesk_free_text "
   "FROM "
   "  coding.icpc2_terms, "
   "  coding.icpc2_drsdesk_term_mapper "
   "WHERE "
   "  icpc2_drsdesk_term_mapper.fk_term = icpc2_terms.pk;"
   import_dir = "/home/richard/easygp/import/"
   learntTerms = modDBConnect.exec_query(sql)  'Load mappable terms drsdesk to icpc
   ErrorFile = Open import_dir & "/pasthistory_import_errors.txt" For Write Create   'open an error file to log errors
   Sfilename = import_dir & "/" & Trim("Exported_PastHistory.txt")                                         'Insist on at least some sort Of attempt at a name
   If sFilename = "" Then 
      txtPastHistoryPath.SetFocus()
      Return
   End If
   Try hfile = Open sfilename For Input                                              'Attempt to open the designated file
   If Error Then
      sFileError = File_IO_Describe_Error(Error.code)
      Message.Warning("Unable to open " & sFilename & "\n\n" & sFileError)
      
   End If
   Inc Application.Busy
   lvDataImportProgressMessages.Clear()
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Starting past history import..............")
   Patients = New Collection
   While Not Eof(hfile)
      '------------------------------------------------------------------------------------ 
      'Input each line and split at the delimeter the data in DrsDesk is "dirty", there are 
      'carriage returns randomly in the text
      '------------------------a_term!pk_code------------------------------------------------------------
      Line Input #hfile, sLineInput           
      bits = Split(sLineInput, "|")
      scurrentPatient = bits[firstname] & bits[surname] & bits[birthdate]
      If sLastPatient <> scurrentPatient Then
         '----------------------------------------------------------------
         'if line contains a new patient, then save any outstanding data
         'If past_history_item_count is > 0, then have data to save
         'And Then Create a New patient object
         '----------------------------------------------------------------
         If past_history_item_count Then
            For Each PH In PastHistory
               PH!fk_progressnote = 0
               PH.Save("clin_history.past_history", "fk_pasthistory")
            Next
            past_history_item_count = 0                                              
            Inc import_count
          '  If import_count = 10 Then
          '     Break
          '  Endif
         End If
         bValidPatient = False 
         patient = Patient_Identify(bits)
         If patient!fk_patient Then
            sLastPatient = bits[firstname] & bits[surname] & bits[birthdate]
            currentconsult = New CConsult(patient)
            currentconsult.Set(const.ConsultType_DataImport, "Past History Imported")
            bValidPatient = True
            PastHistory = New Collection 
         End If
      End If 
      
      '-----------------------------------------------------------------------------
      ' At this point probably got a valid patient, save each past history item
      ' 
      '   pk serial NOT NULL,
      '   fk_consult integer NOT NULL,
      '   age_onset integer NOT NULL,
      '   age_onset_units integer NOT NULL,
      '   description text NOT a_term!pk_codeNULL,
      '   fk_laterality integer DEFAULT 0,
      '   year_onset text NOT NULL,
      '   active boolean DEFAULT false,
      '   operation boolean DEFAULT false,
      '   cause_of_death boolean DEFAULT false,
      '   confidential boolean DEFAULT false,
      '   major boolean DEFAULT false,
      '   deleted boolean DEFAULT false,
      '   year_onset_uncertain boolean DEFAULT false,
      '   management_summary text DEFAULT ''::text,
      '   condition_summary text DEFAULT ''::text,
      '   risk_factor boolean DEFAULT false,
      '   fk_coding_system integer NOT NULL, -- key to coding.lu_coding_system containing name of coding system ...
      '   fk_code text,  PH = New CRow
      '   aim_of_plan text,
      '   fk_progressnote integer, -- foreign key to clin_consult.progressnotes table, used only during each consultation...
      '------------------------------------------ ----------------------------------------------  
      
      If bValidPatient Then
         
         Inc iTemporaryProblemKey
         PH = New CRow 
         PH!fk_consult = currentconsult.GetPK()
         ' PH!pk_pasthistory = iTemporaryProblemKey
         PH!age_onset = bits[age_onset]
         Select Case bits[age_onset_units]
            Case 5
               PH!age_onset_units = const.Units_week
            Case 6
               PH!age_onset_units = const.Units_month
            Case 7
               PH!age_onset_units = const.Units_year
         End Select
         PH!description = Trim(bits[condition])
         '-------------------------------------------------
         'Now try and match this health_issue with an icpc
         'natural_language_term. This is because I only
         'used natural language terms. There are around
         '4000/17000 terms in my database not equatable
         'believe it or not things like NIDDM/IDDM for
         'which ICPC has no equivalent.
         'if can, equate to pk
         'of coding.icpc2_terms, otherwise, when saved
         'the natural_language_term will be added as a 
         'J9900n term or popup an option to search
         '-------------------------------------------------
         '   sql = "Select * from coding.vwGenericTerms where term ILIKE $$" & Lower(PH!description) & "$$"
         ' sql &= "and fk_coding_system = " & const.coding_icpcPlus
         '  vwTerms = modDBConnect.exe Next c_query_collection(sql)
         '  sql = "Select *From coding.icpc2_terms "
         ' sql &= "WHERE Lower(natural_language_term) = $$"
         ' SQL &= Lower(PH!description) & "$$"
         ' $Result = modDBConnect.exec_query(sql)
         For Each a_term In icpc_terms
            If Lower(PH!description) = Lower(a_term!natural_language_term) Then
               Ph!fk_coding_system = const.coding_icpcPlus
               ph!fk_code = a_term!icpc_code & a_term!term_code
               Break
            End If
         Next
          If Not PH.Exist("fk_code") Then  
            For Each a_term In icd10_terms
               If Lower(PH!description) = Lower(a_term!term) Then
                  Ph!fk_coding_system = const.coding_icd10
                  ph!fk_code = a_term!pk_code
                  Break
               End If
            Next
         End If
         
         If Not PH.Exist("fk_code") Then  
            For Each LearntTerms
               If Trim(Lower(PH!description)) = Trim(Lower(LearntTerms!drsdesk_free_text)) Then
                  Ph!fk_coding_system = const.coding_icpcPlus
                  ph!fk_code = a_term!icpc_code & LearntTerms!term_code
                  Break
               End If
            Next
         End If
         If Not PH.Exist("fk_code") Then              
            ' '-------------------------------------------
            ' 'We couldn't match the free text with an icpc
            ' 'natural language term, so, check if we have
            ' 're-allocated this one, if not popup a modal
            ' 'box to get the code.God this could take some
            ' 'time as there are nearly 4000 of these, so
            ' 'I should write these to the database.
            ' '---------------------------------------------
            '    Dec Application.Busy             
            '    FICPC = New FICPCBrowser
            '    FICPC.txtTermToImport.text = PH!description
            '    FICPC.txtSearch.SetFocus()
            '    FICPC.ShowModal()
            '    Inc Application.busy
            '    PH!fk_code = const.globalstring
            '    PH!fk_coding_system = const.coding_icpcPlus
            '    '-----------------------------------------------------
            '    'If user (me) did allocate a term, save for future use
            '    '-----------------------------------------------------
            '    If PH!fk_code Then
            '       sql = "INSERT INTO coding.icpc2_drsdesk_term_mapper("
            '              "fk_term, drsdesk_free_text) " 
            '              "VALUES ("
            '       sql &= PH!fk_code & ", $$"
            '       sql &= PH!description & "$$)"
            '       $Result = modDBConnect.exec_query(sql)
            '       modDBConnect.CommitTrans()
            '        sql = ""
            '     "SELECT distinct"
            '       "  icpc2_terms.term as pk_view,"
            '       "  icpc2_terms.term, "
            '       "  icpc2_terms.term_code, "
            '       "  icpc2_terms.icpc_code, "
            '       "  icpc2_drsdesk_term_mapper.drsdesk_free_text "
            '       "FROM "
            '       "  coding.icpc2_terms, "
            '       "  coding.icpc2_drsdesk_term_mapper "
            '       "WHERE "
            '       "  icpc2_drsdesk_term_mapper.fk_term = icpc2_terms.pk;"
            '       
            '     learntTerms = modDBConnect.exec_query(sql)  'Load mappable terms drsdesk to icpc
            '   
            '     Else
            '      Message.info("Not equated, will save as J term")
            '      PH!coded_health_issue.pk_term = 0
            '    End If
            Inc J_code_count
            PH!fk_code = "J99-" & Format(J_code_count, "00#")
            Ph!fk_coding_system = 1
         Else 
            
            '  .fk_reason = modCodingDBI.Condition_Match_Exact(.description)
            PH!condition_summary = bits[comment]
            PH!fk_laterality = bits[lateralisation] 'same DrsDesk and EasyGP
            PH!year_onset = bits[date_onset]
            If bits[active] = 1 Then
               PH!active = True
            Else
               PH!active = False
            End If
            
            If bits[operation] = 1 Then 
               PH!operation = True 
            Else
               PH!operation = False 
            End If   
            If bits[cause_death] = 1 Then
                PH!cause_of_death = True   
            Else
               PH!cause_of_death = False   
            End If 
            If bits[confidential] = 1 Then
               PH!confidential = True 
            Else
               confidential = False 
            End If   
            '-------------------------------------
            'Now have to do some guessing, in Drs Desk things were either
            'inactive or active, now they can be major or significant or
            'a risk factor
            'fix me - put in some popup learning
            'for starters lets just make them major or inactive
            '-------------------------------------------------------------
            
            PastHistory.Add(PH, PastHistory.count)
            Inc past_history_item_count 'this will be 1 if the first item.(x(x
         End If     
         '  Else
         '      unmatchables.Add(PH, unmatchables.count)      
         ' End If 
         Inc x
      End If 
      
   Wend
   modDBConnect.CommitTrans()
   
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Import completed")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "We imported " & Str(patients.count) & " patients")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(missingpatients) & "missing or duplicated patients")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(x) & "terms matched")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str(unmatchables.count) & "terms not matched")
   Close #hfile
   hfile = Open User.home &/ "easygp/import/unmatched.txt" For Write Create
   For Each unmatchable In unmatchables
      Print #hfile, Lower(unmatchable!description)
   Next
   Close #hfile
   
   Dec Application.busy
   
End

Public Sub PastHistory_Import_PRIOR_25May10()
   '--------------------------------------------------------------
   ' Imports the patients past history initially only DrsDesk
   ' Adams|George|20/12/1925 0:00:00|M|289|1|35|7|Deafness||0|102008601|1960|0|0|0|1|0
   ' surname
   ' firstname
   ' birthdate
   ' sex
   ' ph_id
   ' active flag 0=not 1 = yes
   ' age_onset
   ' age_onset_units eg 7 = year 5 = week, 6 = month
   ' condition
   ' comment
   ' side body 0, 1=left, 2= right 3 = both
   ' ozcode
   ' date_onset
   ' operation Close #hfile
   ' cause death
   ' confidential
   ' significant
   ' deleted
   '--------------------------------------------------------------
   
   Dim $Result As Result
   Dim sql As String
   Dim LearntTerms As Collection
   Dim cons As CConsult
   Dim sfilename As String 
   ' Dim sex As Integer = 3
   'Dim ph_id As Integer = 4
   Dim active As Integer = 3
   Dim age_onset As Integer = 4
   Dim age_onset_units As Integer = 5
   Dim condition As Integer = 6
   Dim comment As Integer = 7
   Dim lateralisation As Integer = 10
   Dim ozcode As Integer = 11
   Dim date_onset As Integer = 9
   Dim operation As Integer = 10
   Dim cause_death As Integer = 11
   Dim confidential As Integer = 12
   Dim significant As Integer = 13
   Dim Deleted As Integer = 13
   Dim Errorfile As File
   Dim bits As String[]
   
   Dim skipcode As Boolean
   Dim x As Integer
   Dim y As Integer
   Dim missingpatients As Integer
   Dim bError As Boolean
   Dim badfilename As Integer
   Dim learntTerm As Collection
   Dim iTemporaryProblemKey As Integer
   Dim sFileError As String
   Dim anError As Error
   Dim bLineComplete As Boolean
   Dim sIncompleteLine As String
   Dim past_history_item_count As Integer 
   Dim sLastPatient As String
   Dim scurrentPatient As String
   Dim bValidPatient As Boolean
   Dim PH As Collection 
   Dim PastHistory As Collection 'of all PH
   
   modDBConnect.BeginTrans()
   sql = "SELECT * FROM coding.icpc2_drsdesk_term_mapper"
   learntTerms = modDBConnect.exec_query_collection(sql)                                'Load mappable terms drsdesk to icpc
   ErrorFile = Open import_dir & "/pasthistory_import_errors.txt" For Write Create   'open an error file to log errors
   Sfilename = Trim(txtPastHistoryPath.text)                                         'Insist on at least some sort Of attempt at a name
   If sFilename = "" Then 
      txtPastHistoryPath.SetFocus()
      Return
   End If
   Try hfile = Open sfilename For Input                                              'Attempt to open the designated file
   If Error Then
      sFileError = File_IO_Describe_Error(Error.code)
      Message.Warning("Unable to open " & sFilename & "\n\n" & sFileError)
      Return
   End If
   Inc Application.Busy
   lvDataImportProgressMessages.Clear()
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Starting past history import..............")
   Patients = New Collection
   While Not Eof(hfile)
      '------------------------------------------------------------------------------------ 
      'Input each line and split at the delimeter the data in DrsDesk is "dirty", there are 
      'carriage returns randomly in the text
      '------------------------------------------------------------------------------------
      Line Input #hfile, sLineInput           
      bits = Split(sLineInput, "|")
      scurrentPatient = bits[firstname] & bits[surname] & bits[birthdate]
      If sLastPatient <> scurrentPatient Then
         '----------------------------------------------------------------
         'if line contains a new patient, then save any outstanding data
         'If past_history_item_count is > 0, then have data to save
         'And Then Create a New patient object
         '----------------------------------------------------------------
         If past_history_item_count Then
            For Each PH In PastHistory
               PH!fk_pasthistory = modPastHistoryDBI.Save(currentconsult, -1, PH)
            Next
            past_history_item_count = 0
            
         End If
         bValidPatient = False 
         patient = Patient_Identify(bits)
         If patient.count Then
            sLastPatient = bits[firstname] & bits[surname] & bits[birthdate]
            currentconsult = New CConsult(patient)
            currentconsult.Set(const.ConsultType_DataImport, "Past History Imported")
            bValidPatient = True
            PastHistory = New Collection 
         End If
      End If 
      
      '-----------------------------------------------------------------------------
      ' At this point probably got a valid patient, save each past history item
      ' 
      '   pk serial NOT NULL,
      '   fk_consult integer NOT NULL,
      '   age_onset integer NOT NULL,
      '   age_onset_units integer NOT NULL,
      '   description text NOT NULL,
      '   fk_laterality integer DEFAULT 0,
      '   year_onset text NOT NULL,
      '   active boolean DEFAULT false,
      '   operation boolean DEFAULT false,
      '   cause_of_death boolean DEFAULT false,
      '   confidential boolean DEFAULT false,
      '   major boolean DEFAULT false,
      '   deleted boolean DEFAULT false,
      '   year_onset_uncertain boolean DEFAULT false,
      '   management_summary text DEFAULT ''::text,
      '   condition_summary text DEFAULT ''::text,
      '   risk_factor boolean DEFAULT false,
      '   fk_coding_system integer NOT NULL, -- key to coding.lu_coding_system containing name of coding system ...
      '   fk_code text,
      '   aim_of_plan text,
      '   fk_progressnote integer, -- foreign key to clin_consult.progressnotes table, used only during each consultation...
      '------------------------------------------ ----------------------------------------------  
      
      If bValidPatient Then
         
         Inc iTemporaryProblemKey
         PH = New Collection 
         PH!fk_consult = currentconsult.GetPK()
         ' PH!pk_pasthistory = iTemporaryProblemKey
         PH!age_onset = bits[age_onset]
         Select Case bits[age_onset_units]
            Case 5
               PH!age_onset_units = const.Units_week
            Case 6
               PH!age_onset_units = const.Units_month
            Case 7
               PH!age_onset_units = const.Units_year
         End Select
         PH!description = Trim(bits[condition])
         '-------------------------------------------------
         'Now try and match this health_issue with an icpc
         'natural_language_term. This is because I only
         'used natural language terms. There are around
         '4000/17000 terms in my database not equatable
         'believe it or not things like NIDDM/IDDM for
         'which ICPC has no equivalent.
         'if can, equate to pk
         'of coding.icpc2_terms, otherwise, when saved
         'the natural_language_term will be added as a 
         'J9900n term or popup an option to search
         '-------------------------------------------------
         '  PH!coded_health_issue = New cICPC2Term
         '  PH!coded_health_issue.natural_language_term = PH!description
         
         sql = "Select *From coding.icpc2_terms "
         sql &= "WHERE Lower(natural_language_term) = $$"
         SQL &= Lower(PH!description) & "$$"
         $Result = modDBConnect.exec_query(sql)
         If $Result.count Then
            
            PH!fk_coding_system = const.coding_icpcPlus
            PH!fk_code = $Result!pk
            
         Else
            '-------------------------------------------
            'We couldn't match the free text with an icpc
            'natural language term, so, check if we have
            're-allocated this one, if not popup a modal
            'box to get the code.God this could take some
            'time as there are nearly 4000 of these, so
            'I should write these to the database.
            '---------------------------------------------
            For Each learntTerm In LearntTerms
               If Lower(LearntTerm!drsdesk_free_text) = Lower(PH!description) Then
                  PH!fk_code = LearntTerm!fk_term
                  PH!fk_coding_system = const.coding_icpcPlus
                  Break
               End If
            Next
            '-------------------------------------------
            'If not already learnt, then popup dialog to 
            'allow user (me) to choose an equivalent
            '-------------------------------------------
            If Not PH!fk_code Then
               Dec Application.Busy             
               FICPC = New FICPCBrowser
               FICPC.txtTermToImport.text = PH!description
               FICPC.txtSearch.SetFocus()
               FICPC.ShowModal()
               Inc Application.busy
               PH!fk_code = const.globalstring
               PH!fk_coding_system = const.coding_icpcPlus
               '-----------------------------------------------------
               'If user (me) did allocate a term, save for future use
               '-----------------------------------------------------
               If PH!fk_code Then
                  sql = "INSERT INTO coding.icpc2_drsdesk_term_mapper("
                  "fk_term, drsdesk_free_text) " 
                  "VALUES ("
                  sql &= PH!fk_code & ", $$"
                  sql &= PH!description & "$$)"
                  $Result = modDBConnect.exec_query(sql)
                  modDBConnect.CommitTrans()
                  learntTerm = New Collection
                  LearntTerm!natural_language_term = PH!description
                  LearntTerm!pk_term = PH!fk_code
                  LearntTerms.Add(learntTerm, LearntTerms.count)
               Else
                  Message.info("Not equated, will save as J term")
                  PH!coded_health_issue.pk_term = 0
               End If
            End If
         End If
         
         '  .fk_reason = modCodingDBI.Condition_Match_Exact(.description)
         PH!condition_summary = bits[comment]
         PH!fk_laterality = bits[lateralisation] 'same DrsDesk and EasyGP
         PH!year_onset = bits[date_onset]
         If bits[active] = 1 Then
            PH!active = True
            ' Message.info(.health_issue & " is " & Str(bits[active]))
         Else
            PH!active = False
         End If
         '.active = bits[active]
         PH!operation = bits[operation]
         PH!cause_of_death = bits[cause_death]
         PH!confidential = bits[confidential]
         '-------------------------------------
         'Now have to do some guessing, in Drs Desk things were either
         'inactive or active, now they can be major or significant or
         'a risk factor
         'fix me - put in some popup learning
         'for starters lets just make them major or inactive
         '-------------------------------------------------------------
         
         PastHistory.Add(PH, PastHistory.count)
         Inc past_history_item_count 'this will be 1 if the first item.
         
      End If 
      Inc x
   Wend
   modDBConnect.CommitTrans()
   
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Import completed")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "We imported " & Str(patients.count) & " patients")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(missingpatients) & "missing or duplicated patients")
   
   Dec Application.busy
   
End

Public Sub Patient_Identify(bits As String[]) As Collection
   
   Dim sql As String 
   Dim $Result As Result 
   Dim sMsg As String
   
   patient = New Collection
   patient!firstname = bits[firstname]
   patient!surname = bits[surname]
   patient!birthdate = Val(bits[birthdate])
   If bits[firstname] = "" Then
      lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no firstname:" & patient!firstname & " " & patient!surname)
   End If
   If bits[surname] = "" Then
      lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no surname:" & patient!firstname & " " & patient!surname)
   End If
   If Year(patient!birthdate) = 0 Then
      lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no birthdate:" & patient!firstname & " " & patient!surname)
      Wait
      patient!birthdate = CDate("01/01/1901")
    End If
   
   '--------------------------------------------------- 
   'Now match that patient to the demographic database
   '--------------------------------------------------- 
   sql = "Select * from contacts.vwPatients where "
   sql &= "firstname ILIKE $$" & patient!firstname & "$$ "
   sql &= " AND surname ILIKE $$" & patient!surname & "$$ "
   sql &= " AND birthdate ='" & Format(patient!birthdate, "dd/mm/yyyy") & "'"
   $Result = modDBConnect.exec_query(sql)
   If $Result.count = 1 Then
      patient!fk_patient = $Result!fk_patient
      lblImporting2.text = "Importing data for" & patient!firstname & " " & patient!surname 
      Wait
   Else
      sMsg = ""
      If $Result.count > 1 Then
          patient!fk_patient = $Result!fk_patient
        '  For Each $Result
        '     sMsg &= $Result!firstname & " " & $Result!surname & " " & Format($Result!birthdate, "dd/mm/yyyy") & "\n"
        '  Next
        ' 
        ' If Message.Question("More than 1 patient found with same name and dob\n\n" & sMsg & " Same patient?", "Yes", "No") = 2 Then 
        '     patient!fk_patient = 0
        '     lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "duplicate name:" & patient!firstname & " " & patient!surname)
        '     Print patient
        ' Endif
        ' Wait
      End If
      If $Result.count = 0 Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Not in Demographic Database:" & patient!firstname & " " & patient!surname)
         patient!fk_patient = 0
         Wait
      End If
   End If
   patients.Add(patient, patients.count)    
   Return patient
   
End

Public Sub Button1_Click()

   Temp1
   
End

Public Function File_IO_Describe_Error(error_code As Integer) As String
   
   Dim sMsg As String
   
   Select Case error_code
         
      Case const.File_IOError_Out_of_memory 
         smsg = "Unable to open the file - out of memory"
      Case const.File_IOError_Access_Forbidden 
         sMsg = "The file could not be accessed, please check you have the appropriate file permissions"
      Case const.File_IOError_File_is_directory 
         sMsg = "The file you have attempted to open is a directory"
      Case const.File_IOError_File_Non_Existant 
         sMsg = "The file could not be found. Please check the name and path and try again"
      Case const.File_IOError_Device_Full 
         sMsg = "The disk you are trying to write to is full. To continue you should probably clean up your disk"
      Case const.File_IOError_System_Error
         sMsg = "Unkown system error"
   End Select
   Return sMsg
   
End 

Public Sub EditArea_Buttons_Click()
   
   Select Case Last.tag
      Case "import"
         Import()
      Case "import path"
         Import_Select_Dir()
   End Select
   
End

Public Sub DrsDesk_Import()
   
   DrsDesk_PastHistory_Import
   
End

Public Sub Medibase_Import()
   
   Dim bNothingChosen As Boolean = True
   Dim starttime As Date
   Dim endtime As Date
   Dim sOneline As String
   
   starttime = Now()
   hLog_file = Open Trim(txtImportDirectory.text) &/ "staff_json_import_log.txt" For Write Create
   Print #hLog_file, "Started Medidbase import :" & Format(Now, "dd/mm/yyy:hh:nn")
   If chkImportStaff.value = True Then
      bNothingChosen = False  
      Print #hLog_file, "Starting staff import"
      Medibase_Import_Staff()
      Print #hLog_file, "Ending staff import"
      chkImportStaff.value = False
      FStaff.Staff_Refresh_External()
   Endif
   If chkImportPatients.value = True Then
      bNothingChosen = False
      Print #hLog_file, "Starting patient import"
      Medibase_Import_Patients()
      Print #hLog_file, "Ending patient import"
      chkImportPatients.Value = False  
   Endif
   If chkImportLetters.value = True Then
      bNothingChosen = False 
      Print #hLog_file, "Starting letters import"
      Medibase_Import_Letters()
      Print #hLog_file, "Finished letters import"
      chkImportLetters.Value = False   
   End If
   
   If chkImportProgressNotes.value = True Then
      bNothingChosen = False 
      Medibase_Import_Progress_Notes()
      chkImportProgressNotes.Value = False   
   End If
   If chkImportDocuments.value = True Then
      bNothingChosen = False 
      Print #hLog_file, "Starting document import"
      Medibase_Import_Documents()
      Print #hLog_file, "ending document import"
      chkImportDocuments.Value = False  
   End If
   If bNothingChosen Then
      Message.Info("Please select the type of data you wish to import")
   Endif
   endtime = Now()
   Print #hLog_file, "Finished import of medibase records"
   Print #hLog_file, "Total time:" & Str(DateDiff(starttime, Endtime, gb.Minute)) & " minutes"
   Close #hLog_file
   
   hFile = Open Trim(txtImportDirectory.text) &/ "staff_json_import_log.txt" For Read
   
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      lvwLog.Add(lvwLog.count, sOneline)
   Wend
   '  Close #hLog_file  'BUG HERE, why can't close
   
End

Public Function Get_Possible_Request_Tags() As Collection
   '------------------------
   'Gets likely request tags
   '------------------------   

   Return modDBConnect.exec_query_collection("Select * from import_export.lu_misspelt_user_request_tags")
   
End

Public Sub Medibase_Import_Documents()
   
   Dim sFile As String
   Dim sDir As String
   Dim sRootdir As String
   Dim fk_patient As Integer
   Dim sNotesDir As String
   Dim sPatientDir As String
   Dim Documents As Collection
   Dim MetaData As Collection
   Dim x As Integer
   Dim bits As String[]
   Dim hfile As File
   Dim sOneLine As String
   Dim fk_staff As Integer
   Dim consult As CRow
   Dim progressNote As CRow
   Dim datebits As String[]
   Dim timebits As String[]
   Dim metadata_filename_path As String
   Dim pdf_filename_path As String 
   Dim notes As String 
   Dim charpos As Integer
   Dim sString As String
   Dim bpString As String
   Dim LeftString As String
   Dim RightString As String
   Dim iPatientCount As Integer  
   Dim Document As CRow
   Dim pdf_filename_original As String 'the original name exported we will clean up later
   Dim pdf_filename_modified As String 'the orginal name minus the crud
   Dim fk_lu_display_as As Integer
   Dim msh_sending_entity As String
   Dim request_tags As Collection = Get_Possible_Request_Tags()
   Dim request_tag As Collection
   
   ' sRootdir = "/home/richard/horst/test"
   '   fk_patient = modImportDBI.Patient_Get_pk_Using_pk_Legacy("YOUNDEBBA")
   lblImport.text = "Importing Documents"
   lblProgress.text = ""
   rejected_records = New Collection
   sRootdir = Trim(txtImportDirectory.text)  ' &/ "MEDIBASE_EXPORT/"
   If IsDir(sRootdir) Then                             'eg "/home/user/MEDIBASE_EXPORT/"
      For Each sFile In Dir(sRootdir)                 
         If IsDir(sRootdir &/ Sfile) Then             
            sPatientDir = sFile
            fk_patient = modImportDBI.Patient_Get_pk_Using_fk_Legacy(sPatientDir)
            For Each sFile In Dir(sRootdir &/ sPatientDir)
               If sFile = "DOCUMENTS" Then 
                  x = 0 
                  For Each sFile In Dir(sRootdir &/ sPatientDir &/ sNotesDir &/ "DOCUMENTS")
                     If File.Ext(sRootdir &/ sPatientDir &/ sNotesDir &/ sFile) = "meta" Then
                        Documents = New Collection
                        MetaData = New Collection 
                        metadata_filename_path = sRootdir &/ sPatientDir &/ sNotesDir &/ "DOCUMENTS" &/ sFile
                        hFile = Open metadata_filename_path For Read
                        While Not Eof(hFile)
                           Line Input #hFile, sOneLine
                        Wend  
                        Close #hfile
                        MetaData = JSON.Decode(sOneline)
                        pdf_filename_original = Replace(sFile, ".meta", "")         'this is the pdf name
                        pdf_filename_modified = modUtil.Filename_Protect(pdf_filename_original) & ".pdf"                                            'create a new name which won't crash 
                        fk_staff = modImportDBI.Staff_Get_Using_Firstname_Lastname(metadata)
                        '------------------------------------------------------------------------------------------------
                        'Insert the document
                        'the fk_sending_entity = the practice importing the data, ie wherever this program is being run
                        'const.Document_Display_As_Letter not of relevance
                        '---------------------------------------- --------------------------------------------------------
                        Document = New CRow
                        '------------------------------------------------------------
                        'Can sometimes work out if a request result or a letter
                        'HORST/IAN FIXME: replace this long line with a better logic
                        'e.g symbion s & n, 'Holter' etc
                        'Default to assuming it is a letter
                        '------------------------------------------------------------
                        Document!tag_user = MetaData!description
                        fk_lu_display_as = const.Document_Display_As_Letter 
                        Document!tag = "Sender Unknown - scanned letter"
                        
                        If Not InStr(Document!tag_user, "Dr ") Then   
                           For Each request_tag In request_tags                           'loaded from import_export.lu_misspelt_user_request_tags
                              If InStr(Lower(MetaData!description), Lower(request_tag!tag)) Then
                                 fk_lu_display_as = const.Document_Display_As_Result
                                 Document!tag = "Sender Unknown - scanned result"
                                 Break
                              End If   
                           Next
                        End If   
                        msh_sending_entity = modDBConnect.currentUser!organisation & "." & modDBConnect.currentUser!branch
                        Document!fk_sending_entity = modInboxDBI.SendingEntity_GetPK(fk_lu_display_as, msh_sending_entity, modDBConnect.currentUser!fk_branch)
                        If Not File.Ext(pdf_filename_modified) = ".pdf" Then
                           Message.Info(pdf_filename_modified, " is not ok")
                        Endif
                        Document!source_file = pdf_filename_modified
                        Document!imported_time = Now()
                        Document!date_created = MetaData!document_date
                        Document!originator = "sender unknown"
                        Document!fk_patient = fk_patient
                        Document!fk_staff_filed_document = modDBConnect.currentUser!fk_staff
                        Document!fk_staff_destination = modDBConnect.currentUser!fk_staff
                        Document!concluded = True
                        Document!fk_lu_display_as = fk_lu_display_as
                        Document!fk_lu_urgency = const.UrgencyLevelRoutine
                        Document!md5sum = modUtil.Calc_md5sum_File(sRootdir &/ sPatientDir &/ sNotesDir &/ "DOCUMENTS" &/ pdf_filename_original)
                        Try modFiles.Put("document_archiving_directory", pdf_filename_modified, sRootdir &/ sPatientDir &/ sNotesDir &/ "DOCUMENTS" &/ pdf_filename_original) 'copy to our documents dir
                        If Not Error Then
                           Document.Save("documents.documents", "fk_document")
                           modDBConnect.CommitTrans()
                           '   Try Kill sRootdir &/ sPatientDir &/ sNotesDir &/ "DOCUMENTS" &/ pdf_filename_original
                           '  If Error Then
                           '     Message.info("problem killing the original file")
                           '   Endif
                        Else
                           rejected_records.Add(sRootdir &/ sPatientDir &/ sNotesDir &/ "DOCUMENTS" &/ pdf_filename_original, rejected_records.count)
                        Endif
                     Endif
                     Inc x 
                  Next
               End If
            Next
         Endif
         Inc iPatientCount
         Print "patient", iPatientCount
         
         lblProgress.text = "total patients processed:" & Str(iPatientCount)
         Wait 
      Next
   End If
   modDBConnect.CommitTrans 
   If rejected_records.count Then   
      hFile = Open sRootdir &/ "documents_rejected.txt" For Write Create
      For x = 0 To rejected_records.count - 1
         Print #hfile, rejected_records[x]
      Next
      Close #hfile
      Message.Info("Some records could not be processed.\n\nA list may be found in this file:\n\n" & sRootdir &/ "documents_rejected.txt")
   End If   
   
End

Public Sub Medibase_Import_Progress_Notes()
   '----------------------------------------------------
   'Expected directory structure
   'PATIENTNAME/PROGRESSNOTES
   '  file.html
   ' file.json which contains
   ' {"pk_legacy": "MCLEJAMEA", "staff_firstname": "Peter", "staff_lastname": "Wong", "time": "17:33:58", "date": "2000-07-18", "problem": null, "pk_staff_legacy": "1"}
   '-----------------------------------------------------
   
   Dim sFile As String
   Dim sDir As String
   Dim sRootdir As String
   Dim fk_patient As Integer
   Dim sNotesDir As String
   Dim sPatientDir As String
   Dim ProgressNotes As Collection
   Dim MetaData As Collection
   Dim x As Integer
   Dim bits As String[]
   Dim hfile As File
   Dim sOneLine As String
   Dim fk_staff As Integer
   Dim consult As CRow
   Dim progressNote As CRow
   Dim datebits As String[]
   Dim timebits As String[]
   Dim metadata_filename_path As String
   Dim html_filename_path As String 
   Dim notes As String 
   Dim charpos As Integer
   Dim sString As String
   Dim bpString As String
   Dim LeftString As String
   Dim RightString As String
   Dim iPatientCount As Integer  
   
   lblImport.text = "Importing progress notes"
   lblProgress.text = ""
   rejected_records = New Collection
   sRootdir = Trim(txtImportDirectory.text) ' &/ "MEDIBASE_EXPORT/"
   If IsDir(sRootdir) Then                             'eg "/home/user/MEDIBASE_EXPORT/"
      For Each sFile In Dir(sRootdir)                 
         If IsDir(sRootdir &/ Sfile) Then             
            sPatientDir = sFile
            fk_patient = modImportDBI.Patient_Get_pk_Using_fk_Legacy(sPatientDir)
            For Each sFile In Dir(sRootdir &/ sPatientDir)
               If sFile = "PROGRESSNOTES" Then 
                  x = 0 
                  For Each sFile In Dir(sRootdir &/ sPatientDir &/ sNotesDir &/ "PROGRESSNOTES")
                     If File.Ext(sRootdir &/ sPatientDir &/ sNotesDir &/ sFile) = "json" Then
                        ProgressNotes = New Collection
                        MetaData = New Collection 
                        metadata_filename_path = sRootdir &/ sPatientDir &/ sNotesDir &/ "PROGRESSNOTES" &/ sFile
                        hFile = Open metadata_filename_path For Read
                        While Not Eof(hFile)
                           Line Input #hFile, sOneLine
                        Wend  
                        Close #hfile
                        MetaData = JSON.Decode(sOneline)
                        html_filename_path = Replace(metadata_filename_path, ".json", ".html")
                        hFile = Open html_filename_path For Read
                        notes = ""
                        While Not Eof(hFile)
                           Line Input #hFile, sOneLine
                           notes &= sOneLine
                        Wend  
                        Close #hfile
                        '------------------------------------------------------------------------------------------
                        'Ok, massage the notes a little, first correct the formatting, leaving headings on one line
                        '------------------------------------------------------------------------------------------
                        metadata!notes = notes
                        metadata!notes = Replace$(metadata!notes, "<b>Diagnosis:", "<BR><b>Diagnosis:")
                        metadata!notes = Replace$(metadata!notes, "<b>Management:", "<BR><b>Management:")
                        metadata!notes = Replace$(metadata!notes, "<b>Action:", "<BR><b>Management:")
                        metadata!notes = Replace$(metadata!notes, "<b>History:", "<BR><b>History:")
                        metadata!notes = Replace$(metadata!notes, "<b>Examination:", "<BR><b>Examination:")
                        metadata!notes = Replace$(metadata!notes, "<b>Actions:", "<BR><b>Actions:")
                        metadata!notes = Replace$(metadata!notes, "<b>Review:", "<BR><b>Review:")
                        metadata!notes = Replace$(metadata!notes, "&nbsp", "&nbsp;")
                        '------------------------------------------------------------
                        'Next, try and parse out the BP measurements
                        '<A HREF='blood pressure'>blood pressure=180/80 mmhg</A><BR>
                        'BP: 135/85 &nbsp;
                        '-----------------------------------------------------------
                        ' If InStr(metadata!notes, "BP: ") Then
                        '    Print "found a BP"
                        '    Print metadata!notes
                        '    charpos = InStr(metadata!notes, "BP: ")
                        '    LeftString = Left(metadata!notes, InStr(metadata!notes, "BP: ") - 1)
                        '    Print LeftString
                        '  '  metadata!notes = Replace$("BP: ", "<A HREF='blood pressure'>blood pressure=")
                        '    sString = Right(metadata!notes, Len(metadata!notes) - charpos - 3)  'includes e.g 130/85 ;nbsp
                        '    RightString = Right(sString, Len(sSTring) - InStr(sString, "&nbsp") - 5)
                        '    
                        '    Print "right side:", RightString
                        '    
                        '    Print 
                        '    charpos = InStr(sString, "&nbsp")
                        '    bpString = Trim(Left(sSTring, charpos - 1))
                        '    Print bpString
                        '  metadata!notes = LeftString & "<A HREF='blood pressure'>blood pressure=" & bpString & " mmhg</A><BR>" & RightString
                        '  Print metadata!notes   
                        '  
                        ' Endif
                        '   Print "starting ", txtImportPatient.text, fk_patient, MetaData!date, MetaData!time
                        fk_staff = modImportDBI.Staff_Get_Using_Firstname_Lastname(metadata)
                        datebits = Split(MetaData!date, "-")
                        timebits = Split(MetaData!time, ":")
                        consult = New CRow 
                        consult!consult_date = Make_Date_time(datebits, timebits)
                        consult!consult_date = Make_Date_time(datebits, timebits)
                        consult!fk_patient = fk_patient
                        consult!fk_staff = fk_staff
                        consult!fk_type = const.consult_type_at_Surgery
                        consult!summary = "Imported progress note from MediBase" & Format(Now, "dd/mm/yyyy")
                        consult.Save("clin_consult.consult", "fk_consult")
                        Progressnote = New CRow
                        Progressnote!fk_consult = consult!fk_consult
                        Progressnote!fk_audit_action = const.cAuditAction_FileImport
                        Progressnote!notes = metadata!notes
                        Progressnote!fk_section = 0 'general notes
                        Progressnote!fk_problem = 0 'no problem
                        progressNote.Save("clin_consult.progressnotes", "fk_progressnote")
                     Endif
                     Inc x 
                  Next
               End If
            Next
         Endif
         modDBConnect.CommitTrans() 
         Inc iPatientCount
         Print iPatientCount
         lblProgress.text = "Total patients with imported notes:" & Str(iPatientCount)
         Wait
      Next
   End If
   ' Message.Info("Commit Progress Notes?")
   modDBConnect.CommitTrans() 
   If rejected_records.count Then   
      hFile = Open sRootdir &/ "progress_notes_rejected.txt" For Write Create
      For x = 0 To rejected_records.count - 1
         Print #hfile, rejected_records[x]
      Next
      Close #hfile
      Message.Info("Some records could not be processed.\n\nA list may be found in this file:\n\n" & sRootdir &/ "progress_notes_rejected.txt")
   End If   
   
End

Public Sub Import_Select_Dir()
   
   Dim hCtrl As Control
   Dim aTextbox As TextBox
   
   Form_directorychooser = New FDirectoryChooser(Me)
   With Form_directorychooser 
      .top = Vbox_EditArea.top + Last.parent.parent.top + Last.parent.height
      For Each hctrl In Last.parent.children
         If hctrl Is Textbox Then
            aTextbox = hctrl
            Form_directorychooser.tag = aTextbox
            Break
         End If
      Next
      .left = Vbox_EditArea.left + aTextbox.parent.Left
      .width = aTextbox.Width
   End With
   Form_directorychooser.Visible = True  
   Form_directorychooser.ShowModal() 
   
End

Public Sub Import()
   
   If Not IsDir(Trim(txtImportDirectory.text)) Then
      Message.Info("Please select a valid directory before proceeding")
      txtImportDirectory.BackGround = Color.rgb(95, 255, 175)
      txtImportDirectory.SetFocus()
      Return 
   Endif
   Select Case cmbMedicalProgram.text
      Case "Medibase"
         Medibase_Import()
      Case "DrsDesk"
         DrsDesk_Import()
   End Select
   
End

Public Sub btnImportDemographics_Click()
   
   Dim sOneLine As String 
   Dim hFile As File
   Dim apatient As Collection
   Dim contacts As New Collection
   Dim json_lines As New Collection 
   Dim x As Integer
   Dim last_line As String
   Dim duplicate_line_count As Integer
   Dim possible_companies As New Collection 
   
   hFile = Open "/home/richard/horst/patients_json.txt" For Read
   
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      json_lines.Add(soneline, contacts.count)
      contacts.Add(JSON.decode(sOneLIne), contacts.count)
   Wend
   Close #hFile
   
   Medibase_Import_Patients(contacts, json_lines) '
   
End

Public Sub button2_Click()
   
   Dim sOneLine As String 
   Dim hFile As File
   Dim apatient As Collection
   Dim contacts As New Collection
   Dim json_lines As New Collection 
   Dim x As Integer
   Dim last_line As String
   Dim duplicate_line_count As Integer
   Dim possible_companies As New Collection 
   
   '  hFile = Open "/home/richard/horst_json.txt" For Read
   hFile = Open "/home/richard/horst_json_rejected.txt" For Read
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      If sOneLine <> last_line Then
         last_line = sOneLine
         If InStr(soneline, "{\"salutation\": \"Sir/Madam\", \"surname\":") 
            If Not InStr(sOneline, "surname\": \"Dr ") Then 
               If Not InStr(sOneline, "salutation\": \"Dr ") Then 
                  possible_companies.Add(soneline, possible_companies.count)
               End If   
            End If
         Else
            If Not InStr(sOneline, "firstname") Then
               If Not InStr(sOneline, "surname\": \"Dr ") Then 
                  If Not InStr(sOneline, "salutation\": \"Dr ") Then 
                     possible_companies.Add(soneline, possible_companies.count)
                  End If   
               End If   
            Else
               json_lines.Add(soneline, contacts.count)
               contacts.Add(JSON.decode(sOneLIne), contacts.count)
            End If  
         End If   
      Else
         Inc duplicate_line_count
      Endif
      
   Wend
   Close #hFile
   'now eliminate duplicate lines
   
   hFile = Open "/home/richard/contacts_json_unique.txt" For Write Create
   For x = 0 To json_lines.count - 1
      Print #hfile, json_lines[x]
   Next
   Close #hFile
   hFile = Open "/home/richard/contacts_possible_companies.txt" For Write Create
   For x = 0 To possible_companies.count - 1
      Print #hfile, possible_companies[x]
   Next
   Close #hFile
   
   '   Import(contacts, json_lines) '
   
End

Public Sub Medibase_Import_Patients()
   
   Dim bits As String[]
   Dim person As CRow
   Dim persons As New Collection
   Dim address_Link As CRow
   Dim link_person_comm As CRow
   Dim address As CRow
   Dim sql As String
   Dim contact As Collection
   Dim x As Integer
   Dim fk_occupation As Integer
   Dim occupation As Collection
   Dim R As Result
   Dim fk_title As Integer
   Dim sMsg As String
   Dim bOddOccupation As Boolean
   Dim OddRecords As New Collection 
   Dim Notpersons As New Collection
   Dim rejected_records As New Collection
   Dim hFile As File
   Dim brejected As Boolean
   Dim communications As Collection
   Dim communication_row As String
   Dim communication As CRow  
   Dim Town As String
   Dim icounter As Integer
   Dim patient As CRow  
   Dim sOneLine As String 
   Dim oldpatient As Collection 
   Dim apatient As Collection
   Dim last_line As String
   Dim duplicate_line_count As Integer
   Dim sRootdir As String
   Dim json_lines As Collection
   
   lblImport.text = "Importing patient"
   lblProgress.text = ""
   json_lines = New Collection
   patients = New Collection
   sRootdir = Trim(txtImportDirectory.text)
   hFile = Open sRootdir &/ "patients_json.txt" For Read
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      json_lines.Add(soneline, patients.count)
      patients.Add(JSON.decode(sOneLIne), patients.count)
   Wend
   Close #hFile
   'message for horst  - need standardisation of eg communications[] or staight colleciton
   For Each oldpatient In patients
      Inc icounter
      Print icounter
      If icounter = 590 Then
         Print
      Endif
      Person = New CRow                                                          
      Person = Person_Create(oldpatient)                                        'create new person row
      If Not IsNull(person) Then                                                 'is ok?
         If Not IsNull(oldpatient!communications) Then                       'if have comms
            Communications = Comms_Create(oldpatient!communications) 'add their comms
         Endif
         If Not IsNull(oldpatient!addresses) Then                       'if have an address
            Address = Address_Create(oldpatient!addresses, person, const.AddressType_Home)             'add their address
         Endif
         '---------------
         'save the record 
         '---------------
         person.Save("contacts.data_persons", "fk_person")
         '  If Not IsNull(address) Then 
         
         If address.count <> 0 Then 
            address.Save("contacts.data_addresses", "fk_address")
            address_link = New CRow   
            address_link!fk_person = person!fk_person
            address_link!fk_address = address!fk_address
            address_link.Save("contacts.links_persons_addresses", "fk_link_person_address")
         Else
            Print
         End If   
         For Each communication In communications
            communication.Save("contacts.data_communications", "fk_comm")
            link_person_comm = New CRow 
            link_person_comm!fk_person = person!fk_person
            link_person_comm!fk_comm = communication!fk_comm
            link_person_comm.Save("contacts.links_persons_comms", "fk_link_person_comm")
         Next
         patient = New CRow
         patient!fk_person = person!fk_person
         patient!medicare_number = oldpatient!patient!medicare_number
         If Len(oldpatient!patient!medicare_number) > 10 Then
            Message.Info("medicare number too long")
         Endif
         patient!medicare_ref_number = oldpatient!patient!medicare_ref_number
         patient!fk_lu_aboriginality = oldpatient!patient!atsi
         Select Case oldpatient!patient!active_status                           'ok
            Case "a"
               patient!fk_lu_active_status = const.PatientStatus_Active
            Case "i"
               patient!fk_lu_active_status = const.PatientStatus_Inactive
            Case Else
               Message.Info("was active status i don't know")
         End Select
         patient!veteran_number = oldpatient!patient!veteran_number                'ok
         patient!fk_lu_veteran_card_type = oldpatient!patient!veteran_card_type    'ok
         patient!fk_legacy = oldpatient!patient!pk_legacy                          'ok
         lblProgress.text = person!firstname & " " & person!surname
         Wait
         patient.Save("clerical.data_patients", "fk_patient")
      Else
         rejected_records.Add(json_lines[x], rejected_records.count)
      Endif
      Inc x
   Next
   ' If Message.Question("Would you like to commit the transaction to the database?", "Yes", "No") = 1 Then 
   modDBConnect.CommitTrans
   ' Else
   '    Print #hLog_file, "Patient Import was cancelled by the user."
   ' End If   
   
   hFile = Open sRootdir &/ "medibase_patients_rejected.txt" For Write Create 
   For x = 0 To rejected_records.count - 1
      Print #hfile, rejected_records[x]
   Next
   Close #hfile
   
End

' 
Public Sub town_Cleanup(town As String) As String
   'lots of horsts towns have multiple ascii 32's and some have full stops
   
   town = Replace(town, ".", " ")
   Return modUtil.StripExtraBlanks(town)
   
End

Public Sub Town_Make(R As Result, data As Collection, fk_address_type As Integer) As CRow
   
   Dim address As New CRow
   
   If IsNull(r!pk) Or r!pk = 0 Then
      Message.Info("missing-fk_town")
      Print
   Endif
   address!fk_town = r!pk
   address!street1 = data!street1
   address!street2 = data!street2
   address!fk_lu_address_type = fk_address_type
   Return address
   
End
'            '-------------------------------------------------------
'                   missing_towns.Add(bits[iSuburb], missing_town_count)
'                   Inc missing_town_count
'                   Print #hLogfile, person!firstname & " " & person!surname & " - failed to match suburb:" & address!suburb & " checking misspelt towns table for match...."
'                   C = modContactsDBI.Misspelt_towns_Get(address!suburb)
'                   If IsNull(c)
'                      If chkPromptForPostcodes.value = True Then 
'                         'First check if we have encountered this, found no equivalent, and marked to skip
'                          bSkipTown = False  
'                          For Each skipped_town In skipped_towns
'                            If Lower(skipped_town) = Lower(address!suburb) Then
'                                bSkipTown = True
'                                Print #hLogfile, person!firstname & " " & person!surname & " - skipping suburb - not found previously"
'                                Break
'                            Endif
'                          Next
'                          If bSkipTown = False Then                 
'                        
'                            misspelt_town = New Collection
'                            misspelt_town!town_misspelt = address!suburb
'                            FSelectTown.txtNotFound.text = address!suburb
'                            FSelectTown.txtFirstname.text = person!firstname
'                            FSelectTown.txtSurname.text = person!surname
'                            FSelectTown.txtbirthdate.text = person!birthdate
'                            FSelectTown.txtstreet1.text = address!street
'                            Dec Application.Busy
'                            FSelectTown.ShowModal()
'                            Inc Application.Busy
'                            If FSelectTown.fk_town Then
'                               address!fk_town = FSelectTown.fk_town
'                               misspelt_town!fk_town = FSelectTown.fk_town
'                               misspelt_town!town = FSelectTown.town
'                               modDBConnect.BeginTrans
'                               modDBConnect.insert("contacts.lu_misspelt_towns", misspelt_town)
'                               modDBConnect.CommitTrans
'                            Else
'                                Print #hLogfile, person!firstname & " " & person!surname & " - no suburb selected for substitution"
'                                Inc Errorcount
'                            End If
'                          End If
'                          Inc Errorcount
'                          iError = True
'                      End If

Public Sub btnImportStaff_Click()
   
   ' Dim sOneLine As String 
   ' Dim hFile As File
   ' Dim staff As New Collection
   ' Dim json_lines As New Collection 
   ' Dim x As Integer
   ' Dim last_line As String
   ' 
   ' '  hFile = Open "/home/richard/horst_json.txt" For Read
   ' hFile = Open "/home/richard/horst/staff_json.txt" For Read
   ' While Not Eof(hFile)
   '    Line Input #hFile, sOneLine
   '    json_lines.Add(soneline, staff.count)
   '    staff.Add(JSON.decode(sOneLIne), staff.count)
   ' Wend
   ' Close #hFile
   ' 
   ' Import_staff(staff, json_lines) '
   
End

' Public Sub tbImportProgressNotes_Click()
'    
'    Dim sFile As String
'    Dim sDir As String
'    Dim sRootdir As String 
'    Dim fk_patient As Integer
'    Dim sNotesDir As String
'    Dim sPatientDir As String
'    Dim ProgressNotes As Collection
'    Dim MetaData As Collection
'    Dim x As Integer
'    Dim bits As String[]
'    Dim hfile As File
'    Dim sOneLine As String
'    Dim fk_staff As Integer
'    Dim consult As CRow
'    Dim progressNote As CRow
'    Dim datebits As String[]
'    Dim timebits As String[]
'    Dim metadata_filename_path As String
'    Dim html_filename_path As String 
'    Dim notes As String 
'    Dim charpos As Integer
'    Dim sString As String
'    Dim bpString As String
'    Dim LeftString As String
'    Dim RightString As String
'    Dim iPatientCount As Integer  
'    
'    ' Dialog.Title = "Select Path to Progress Notes"
'    
'    '   If Dialog.SelectDirectory() Then Return 
'    '  Print Dialog.Path
'    '----------------------------------------------------
'    'Ok, check this is a valid image (e.g they could have
'    'changed the file selector to any file
'    'directory structure
'    'PATIENTNAME/PROGRESSNOTES
'    '  file.html
'    ' file.json which contains
'    ' {"pk_legacy": "MCLEJAMEA", "staff_firstname": "Peter", "staff_lastname": "Wong", "time": "17:33:58", "date": "2000-07-18", "problem": null, "pk_staff_legacy": "1"}
'    '
'    '-----------------------------------------------------
'    sRootdir = "/home/richard/horst/MEDIBASE_EXPORT/"
'     sRootdir = "/home/richard/Downloads/Horst_Latests"
'    If IsDir(sRootdir) Then                             'eg "/home/richard/horst/MEDIBASE_EXPORT/"
'       For Each sFile In Dir(sRootdir)                  'eg "/home/richard/horst/MEDIBASE_EXPORT/"
'          If IsDir(sRootdir &/ Sfile) Then              '/home/richard/horst/temp/MCGUWAYNA
'             sPatientDir = sFile
'             fk_patient = modImportDBI.Patient_Get_pk_Using_fk_Legacy(sPatientDir)
'             For Each sFile In Dir(sRootdir &/ sPatientDir) '/home/richard/horst/temp/MCGUWAYNA
'                sNotesDir = sFile
'                x = 0 
'                For Each sFile In Dir(sRootdir &/ sPatientDir &/ sNotesDir)
'                   ProgressNotes = New Collection
'                   MetaData = New Collection 
'                   If File.Ext(sRootdir &/ sPatientDir &/ sNotesDir &/ sFile) = "meta" Then
'                      metadata_filename_path = sRootdir &/ sPatientDir &/ sNotesDir &/ sFile
'                      hFile = Open metadata_filename_path For Read
'                      While Not Eof(hFile)
'                         Line Input #hFile, sOneLine
'                      Wend  
'                      Close #hfile
'                      MetaData = JSON.Decode(sOneline)
'                      html_filename_path = Replace(metadata_filename_path, ".meta", "")
'                      hFile = Open html_filename_path For Read
'                      notes = ""
'                      While Not Eof(hFile)
'                         Line Input #hFile, sOneLine
'                         notes &= sOneLine
'                      Wend  
'                      Close #hfile
'                      '------------------------------------------------------------------------------------------
'                      'Ok, massage the notes a little, first correct the formatting, leaving headings on one line
'                      '------------------------------------------------------------------------------------------
'                      metadata!notes = notes
'                      metadata!notes = Replace$(metadata!notes, "<b>Diagnosis:", "<BR><b>Diagnosis:")
'                      metadata!notes = Replace$(metadata!notes, "<b>Management:", "<BR><b>Management:")
'                      metadata!notes = Replace$(metadata!notes, "<b>Action:", "<BR><b>Management:")
'                      metadata!notes = Replace$(metadata!notes, "<b>History:", "<BR><b>History:")
'                      metadata!notes = Replace$(metadata!notes, "<b>Examination:", "<BR><b>Examination:")
'                      metadata!notes = Replace$(metadata!notes, "<b>Actions:", "<BR><b>Actions:")
'                      metadata!notes = Replace$(metadata!notes, "<b>Review:", "<BR><b>Review:")
'                      metadata!notes = Replace$(metadata!notes, "&nbsp", "&nbsp;")
'                      '------------------------------------------------------------
'                      'Next, try and parse out the BP measurements
'                      '<A HREF='blood pressure'>blood pressure=180/80 mmhg</A><BR>
'                      'BP: 135/85 &nbsp;
'                      '-----------------------------------------------------------
'                      ' If InStr(metadata!notes, "BP: ") Then
'                      '    Print "found a BP"
'                      '    Print metadata!notes
'                      '    charpos = InStr(metadata!notes, "BP: ")
'                      '    LeftString = Left(metadata!notes, InStr(metadata!notes, "BP: ") - 1)
'                      '    Print LeftString
'                      '  '  metadata!notes = Replace$("BP: ", "<A HREF='blood pressure'>blood pressure=")
'                      '    sString = Right(metadata!notes, Len(metadata!notes) - charpos - 3)  'includes e.g 130/85 ;nbsp
'                      '    RightString = Right(sString, Len(sSTring) - InStr(sString, "&nbsp") - 5)
'                      '    
'                      '    Print "right side:", RightString
'                      '    
'                      '    Print 
'                      '    charpos = InStr(sString, "&nbsp")
'                      '    bpString = Trim(Left(sSTring, charpos - 1))
'                      '    Print bpString
'                      '  metadata!notes = LeftString & "<A HREF='blood pressure'>blood pressure=" & bpString & " mmhg</A><BR>" & RightString
'                      '  Print metadata!notes   
'                      '  
'                      ' Endif
'                      fk_staff = modImportDBI.Staff_Get_Using_Firstname_Lastname(metadata)
'                      datebits = Split(MetaData!date, "-")
'                      timebits = Split(MetaData!time, ":")
'                      consult = New CRow 
'                      consult!consult_date = Make_Date_time(datebits, timebits)
'                      consult!fk_patient = fk_patient
'                      consult!fk_staff = fk_staff
'                      consult!fk_type = const.consult_type_at_Surgery
'                      consult!summary = "Imported from MediBase" & Format(Now, "dd/mm/yyyy")
'                      consult.Save("clin_consult.consult", "fk_consult")
'                      Progressnote = New CRow
'                      Progressnote!fk_consult = consult!fk_consult
'                      Progressnote!fk_audit_action = const.cAuditAction_FileImport
'                      Progressnote!notes = metadata!notes
'                      Progressnote!fk_section = 0 'general notes
'                      Progressnote!fk_problem = 0 'no problem
'                      progressNote.Save("clin_consult.progressnotes", "fk_progressnote")
'                   Endif
'                   Inc x 
'                Next
'             Next
'             Print "patient key:", fk_patient 
'          Endif
'          Inc iPatientCount
'          Print "Patient:" & iPatientCount
'       Next
'    End If
'    modDBConnect.CommitTrans
'    
' End

Public Sub Medibase_Import_Staff()
   
   Dim logon_suffix As Integer   'if logon_name exists increment this tag on end 
   Dim person As CRow
   Dim link_person_comm As CRow
   Dim x As Integer
   Dim R As Result
   Dim sMsg As String
   Dim rejected_records As New Collection
   Dim hFile As File
   Dim communications As Collection
   Dim communication As CRow  
   Dim icounter As Integer
   Dim staffmember As Collection
   Dim staff As Collection
   Dim newstaff As New CRow   
   Dim link_staff_clinic As New CRow   
   Dim employee As New CRow   
   Dim sOneline As String
   Dim sRootdir As String
   Dim json_lines As Collection 
   Dim data_numbers As CRow
   
   lblImport.text = "Importing Staff"
   lblProgress.text = ""
   '---------------------------------------------
   'Open the staff file, create a json collection
   '---------------------------------------------
   sRootdir = Trim(txtImportDirectory.text)
   staff = New Collection
   json_lines = New Collection 
   oddoccupations = New String[]
   hFile = Open sRootdir &/ "staff_json.txt" For Read
   While Not Eof(hFile)
      Line Input #hFile, sOneLine
      json_lines.Add(soneline, staff.count)
      staff.Add(JSON.decode(sOneLIne), staff.count)
   Wend
   Close #hFile
   For Each staffmember In staff
      Inc icounter
      Print icounter
      '----------------------------------------------------------------------
      'First, try and create a person
      'This will fail for example if duplicate exists in the database already
      'but ajson_lines[x] log file will  be created of this FIXME DO THIS
      '----------------------------------------------------------------------
      Person = New CRow                                                          
      Person = Person_Create(staffmember)                                        'create new person row
      If Not IsNull(person) Then                                                 'is ok?
         If Not IsNull(staffmember!communications[0]) Then                       'if have comms
            Communications = Comms_Create(staffmember!communications[0]) 'add their comms
         Endif
         '----------------------------------------------------------------------------------------
         'If not rejected, try and add the postgres user first with default password of 'password'
         '----------------------------------------------------------------------------------------
         Newstaff = New CRow
         Newstaff!password = "password"
         Newstaff!fk_role = staffmember!fk_role
         Newstaff!fk_status = staffmember!fk_status
         If modDBConnect.Role_Check_If_Exists(staffmember!logon_name) Then 
            Inc logon_suffix
            Newstaff!logon_name = staffmember!logon_name & Str(logon_suffix)
         Else
            Newstaff!logon_name = staffmember!logon_name 
         End If 
         Newstaff!logon_date_from = Now()
         Newstaff!logon_date_to = DateAdd(Now(), gb.Year, 2)
         Newstaff!qualifications = staffmember!qualifications
         Select Case staffmember!fk_role
            Case 1, 3 'doctor
               Newstaff!fk_lu_staff_type = 9 'general practitioners
            Case 2
               Newstaff!fk_lu_staff_type = 3
            Case 4
               Newstaff!fk_lu_staff_type = 13
            Case 5
               Newstaff!fk_lu_staff_type = 7 'general nursing
            Case 6, 7
               Newstaff!fk_lu_staff_type = 12
            Case 8
               Newstaff!fk_lu_staff_type = 4
            Case 9, 11, 12
               Newstaff!fk_lu_staff_type = 2
            Case 10
               Newstaff!fk_lu_staff_type = 6
         End Select   
         If Not (modContactsDBI.Staff_Create_Postgres_User(Null, 0, newstaff)) Then
            rejected_records.Add(json_lines[x], rejected_records.count)
         Else
            person.Save("contacts.data_persons", "fk_person")
            For Each communication In communications
               communication.Save("contacts.data_communications", "fk_comm")
               link_person_comm = New CRow 
               link_person_comm!fk_person = person!fk_person
               link_person_comm!fk_comm = communication!fk_comm
               link_person_comm.Save("contacts.links_persons_comms", "fk_link_person_comm")
            Next
         Endif
         newstaff.Remove("password")
         Newstaff!fk_person = person!fk_person   'put in the person key
         Newstaff.Save("admin.staff", "fk_staff")
         employee = New CRow
         employee!fk_branch = modDBConnect.currentUser!fk_branch
         employee!fk_status = staffmember!fk_status
         If person.Exist("fk_occupation") Then
            employee!fk_occupation = person!fk_occupation
         End If
         employee!fk_person = person!fk_person
         employee.Save("contacts.data_employees", "fk_employee")
         link_staff_clinic = New CRow 
         link_staff_clinic!fk_staff = Newstaff!fk_staff
         link_staff_clinic!fk_clinic = modDBConnect.currentUser!fk_clinic
         link_staff_clinic.Save("admin.link_staff_clinics", "fk_link_staff_clinics") 
         If Not IsNull(staffmember!provider_number) Then 
            modContactsDBI.Set_Numbers(person!fk_person, modDBConnect.currentUser!fk_branch, staffmember!provider_number, staffmember!presciber_number)
         End If  
         lblProgress.text = "Adding " & person!firstname & " " & person!surname 
         Wait
      Else
         rejected_records.Add(json_lines[x], rejected_records.count)
      End If   
      Inc x
   Next
   ' If Message.Question("Would you like to commit the transaction to the database?", "Yes", "No") = 1 Then 
   modDBConnect.CommitTrans
   ' Else
   '    Print #hLog_file, "Staff Import was cancelled by the user."
   ' End If   
   If rejected_records.count Then
      Print #hLog_file, "There were " & Str(rejected_records.count) & " records rejected details in the file " & sRootdir &/ "medibase_staff_rejected/txt"
   End If
   hFile = Open sRootdir &/ "medibase_staff_rejected.txt" For Write Create 
   For x = 0 To rejected_records.count - 1
      Print #hfile, rejected_records[x]
   Next
   Close #hfile
   
End

Public Sub Person_Create(data As Collection) As CRow
   '------------------------------------------------------------------------------------
   'creates a person, if not valid the return cRow is null
   'If person exists in the contacts database with same name/DOB then considered invalid
   'however will write to  a log file FIXME to keep record of this
   '------------------------------------------------------------------------------------
   
   Dim R As Result  
   Dim brejected As Boolean
   Dim bOddOccupation As Boolean
   Dim fk_title As Integer
   Dim bits As String[]
   Dim Person As New CRow
   Dim sql As String
   Dim sMsg As String
   
   person!firstname = data!person!firstname
   R = modDBConnect.exec_query("Select sex from contacts.lu_firstnames where firstname ILIKE $$" & Trim(person!firstname) & "$$")
   If R.count Then
      Select Case R!sex                
         Case "m"
            person!fk_sex = const.cSexMale
         Case "f"
            person!fk_sex = const.cSexFemale
      End Select
   Else
      person!fk_sex = const.cSexUnknown
   Endif
   person!surname = data!person!surname
   If Not IsNull(data!person!birthdate) Then 
      person!birthdate = data!person!birthdate
   Else
      Message.Info("Missing birthdate! - your programming skills are fucked")
      person!birthdate = "1900-01-01"
   End If
   If Not IsNull(data!person!retired) Then
      person!retired = True  
   Endif
   Select Case Lower(Replace(data!person!title, ".", ""))
      Case "dr"
         fk_title = const.ctitleDr
      Case "mr"
         fk_title = const.ctitleMr
      Case "mrs"
         fk_title = const.ctitleMrs
      Case "ms"
         fk_title = const.ctitleMs
      Case "master"
         fk_title = const.ctitleMaster
      Case "miss"
         fk_title = const.ctitleMiss
      Case "prof"
         fk_title = const.ctitleProf
      Case Else 
         Select Case person!fk_sex
            Case const.cSexMale
               bits = Split(person!birthdate, "-")
               If DateDiff(Now, Date(Val(bits[0]), Val(bits[1]), Val(bits[2])), gb.year) > 15 Then
                  fk_title = const.ctitleMr
               Else
                  fk_title = const.ctitleMaster
               End If  
            Case const.cSexFemale
               bits = Split(person!birthdate, "-")
               If DateDiff(Now, Date(Val(bits[0]), Val(bits[1]), Val(bits[2])), gb.year) > 15 Then
                  fk_title = const.ctitleMiss
               Else
                  fk_title = const.ctitleMs
               End If 
         End Select
   End Select
   person!fk_title = fk_title 
   bOddOccupation = False   
   If Not IsNull(Trim(Lower(data!person!occupation))) Then 
      If Not InStr(Trim(Lower(data!person!occupation)), "/") Then       
         R = modDBConnect.exec_query("Select * from common.lu_occupations where occupation ILIKE $$" & Trim(Lower(data!person!occupation)) & "$$")
         If R.count Then
            person!fk_occupation = R!pk
         Else           
            If Not oddoccupations.Exist(Trim(Lower(data!person!occupation))) Then 
               Select Case Message.Question("Occupation not found:\n\n" & data!person!occupation, "Save As New Occupation", "Do Not save")
                  Case 1 
                     person!fk_occupation = modContactsDBI.Occupation_Save(Trim(Lower(data!person!occupation)))
                     modDBConnect.CommitTrans
                  Case 2
                     bOddOccupation = True        
                     oddoccupations.Add(Trim(Lower(data!person!occupation)), oddoccupations.count)    
               End Select
            Else 
               bOddOccupation = True   
            End If   
         Endif
      End If
   End If  
   '-------------------------------------------------------
   'Does the person already exist in the person's database?
   '-------------------------------------------------------  
   bits = Split(person!birthdate, "-")
   sql = "Select * from contacts.data_persons where "
   sql &= "Firstname ILIKE $$" & person!firstname & "$$ AND surname ILIKE $$" & person!surname & "$$ "
   sql &= " AND birthdate = $$" & person!birthdate & "$$"
   R = modDBConnect.exec_query(sql)
   If R.Count Then
      'fixme write to logfile
      ' Message.title = "Duplicate Record" 'fixme write to a logfile
      ' sMsg = " The name:" & person!firstname & " " & person!surname & " " & Format(Date(Val(bits[0]), Val(bits[1]), Val(bits[2])), "dd/mm/yyyy")
      ' sMsg &= " already exists in the database.\n\n"
      ' If R.count > 1 Then
      '    sMsg &= "In fact, the same person and date of birth exist  " & Str(R.count) & " times.\n\n"
      '    sMsg &= "This record cannot be processed and will be added to a list in the log file ."
      '    Message.Info(sMsg)
      ' End If   
      person = Null
   Endif 
   Return Person 
   
End

Public Sub Comms_Create(data As Collection) As Collection 
   '----------------------------------------------------------------------
   'Creates a collection of persons comms null collection returned if none
   '----------------------------------------------------------------------
   
   Dim communications As New Collection
   Dim communication As CRow
   
   communications = New Collection
   If Not IsNull(data!phone_business) Then
      communication = New CRow
      communication!fk_type = const.CommModalityWork
      communication!value = data!phone_business
      communications.Add(communication, communications.count)
   Endif
   If Not IsNull(data!phone_afterhours) Then
      communication = New CRow
      communication!fk_type = const.CommModalityPhoneAfterHours
      communication!value = data!phone_afterhours
      communications.Add(communication, communications.count)
   Endif
   If Not IsNull(data!fax_no) Then
      communication = New CRow
      communication!fk_type = const.CommModalityFax
      communication!value = data!fax_no
      communications.Add(communication, communications.count)
   Endif
   If Not IsNull(data!web) Then
      communication = New CRow 
      communication!fk_type = const.CommModalityWeb
      communication!value = data!web
      communications.Add(communication, communications.count)
   Endif
   If Not IsNull(data!email) Then
      communication = New CRow
      communication!fk_type = const.CommModalityEmail
      communication!value = data!email 
      communications.Add(communication, communications.count)
   Endif
   If Not IsNull(data!phone_mobile) Then
      communication = New CRow 
      communication!fk_type = const.CommModalityMobile
      communication!value = data!phone_mobile
      communications.Add(communication, communications.count)
   Endif
   If Not IsNull(data!phone_home) Then
      communication = New CRow 
      communication!fk_type = const.CommModalityHome
      communication!value = data!phone_home
      communications.Add(communication, communications.count)
   Endif
   Return communications
   
End

Public Function Address_Create(data As Collection, person As CRow, fk_lu_address_type As Integer) As CRow
   '--------------------------------------------------------------------------------
   'Attempt to create an address, however much of the data to import is very 'dirty'
   'as a good many legacy databases had no proper town/postcode data input method
   'and relied on secretarial typing.... many spello's and non-existant towns
   'We will try various things, if they fail we will prompt the user for help
   'town field could have town + postcode
   'the town could be ok, but the state missing
   'the town could be ok but the postcode is wrong
   '---------------------------------------------------------------------------------
   
   Dim address As New CRow
   Dim sql As String
   Dim R As Result
   
   '-------------------------------------------------------------
   'first, lets go for a unique australian town.
   'town_Cleanup(data!town)cleanup crap in the names
   '-------------------------------------------------------------
   If Not data.count Then
      Return address
   Endif
   If person!firstname = "Kylea" Then
      Print 
   Endif
   sql = "Select * from contacts.lu_towns where town ilike $$" & town_Cleanup(data!town) & "$$ AND comment is null"
   R = modDBConnect.exec_query(sql)
   If r.count = 1 Then
      address = town_Make(R, data, fk_lu_address_type)
   Else      
      '-----------------------------------------------------------------------------------------------------
      'ok, bombed on that, there could be none or > 1, try town + state as I've noted postcodes can be wrong
      '-----------------------------------------------------------------------------------------------------
      If Not IsNull(data!state) Then 
         sql = "Select * from contacts.lu_towns where town ilike $$" & town_Cleanup(data!town) & "$$ AND comment is null "        
         sql &= " AND state = $$" & Trim(data!state) & "$$"
         R = modDBConnect.exec_query(sql)
         If R.count = 1 Then  
            address = town_Make(R, data, fk_lu_address_type)
         Endif
      Else   
         '----------------------------------
         'ok, no state, try town + postcode
         '-----------------------------------
         If Not IsNull(data!postcode) Then  
            sql = "Select * from contacts.lu_towns where town ilike $$" & town_Cleanup(data!town) & "$$ AND comment is null "     
            sql &= " AND postcode = $$" & Trim(data!postcode) & "$$"
            R = modDBConnect.exec_query(sql)
            If R.count = 1 Then
               address = town_Make(R, data, fk_lu_address_type)
            End If
         End If 
      End If  
      If Not address.count Then    
         '----------------------------------------------------
         'At this point we have not town, need user input
         'ok, failed, use popup and get use to add the town
         'We'll look first in previously saved mis-spelt town
         '----------------------------------------------------
         If Not IsNull(data!town) Then 
            misspelt_town = modContactsDBI.Misspelt_towns_Get(data!town) 
            If Not IsNull(misspelt_town) Then 
               address = New CRow
               address!fk_town = misspelt_town!fk_town
               address!street1 = data!street1 
               address!street2 = data!street2
               address!fk_lu_address_type = const.AddressType_Work
               Return address
            End If   
            If address.count = 0 And Not IsNull(data!town) Then
               fk_town = 0
               misspelt_town = New Collection  
               misspelt_town!town_misspelt = data!town
               FSelectTown.txtNotFound.text = data!town
               FSelectTown.txtFirstname.text = person!firstname
               FSelectTown.txtSurname.text = person!surname
               FSelectTown.txtstreet1.text = data!street1
               FSelectTown.txtstreet2.text = data!street2
               FSelectTown.Init(data)
               Dec Application.Busy
               FSelectTown.ShowModal()                         'get the data,if user did allocate valid town, fk_town > 0
               Inc Application.Busy
               If fk_town Then
                  '------------------------------------------------------------------------------------------   
                  'if the user allocated a town, fill the address collection
                  'then save the misspelt town to the backend, along with the correct key to the correct town
                  '------------------------------------------------------------------------------------------
                  address = New CRow
                  If fk_town = 0 Then 'should never be trying to find bug
                     Message.Info("fk_town is zero")
                     Print
                  End If
                  address!fk_town = fk_town
                  address!street1 = data!street1
                  address!street2 = data!street2
                  address!fk_lu_address_type = fk_lu_address_type
                  misspelt_town!fk_town = fk_town             'the real town
                  misspelt_town!town = Corrected_Town!town 
                  misspelt_town!town_misspelt = data!town 'the mis-spelt town
                  modDBConnect.BeginTrans
                  modDBConnect.insert("contacts.lu_misspelt_towns", misspelt_town)
                  modDBConnect.CommitTrans
               Else
                  '--------------------------------------------------------
                  ' Not town, but still should have an address of some sort
                  ' -------------------------------------------------------
                  address = New CRow   
                  address!street1 = data!street1
                  address!street2 = data!town
                  address!fk_lu_address_type = fk_lu_address_type
                  Return address
               End If
            End If
         End If
      End If  
   End If
   Return address 
   
End

Public Function Make_Date(bits As String[]) As Date
   
   If bits.count <> 3 Then
      Message.info("bad date bits")
      Return 
   Endif
   Return Date(Val(bits[0]), Val(bits[1]), Val(bits[2]))
   
End

Public Function Make_Date_time(datebits As String[], timebits As String[]) As Date
   'some records missing time in part or whole
   
   Dim x As Integer
   
   For x = timebits.count To 2
      timebits.Add("0")
   Next
   If timebits.count = 2 Then
      timebits.Add("0")
   Endif
   Return Date(Val(datebits[0]), Val(datebits[1]), Val(datebits[2]), Val(timebits[0]), Val(timebits[1]), Val(timebits[2]))
   
End

Public Sub EditArea_TextBox_LostFocus()
   
   Last.BackGround = Color.White
   
End

Public Sub EditArea_TextBox_GotFocus()
   
   Last.BackGround = Color.rgb(95, 255, 175)
   
End

' pk serial Not Null,
'    fk_lu_request_type integer, - - The type Of provider eg pathology provider, radiology provider
' msh_sending_entity text Not Null, - - the entity sending, could be unintelligable eg a NATA / number Or a recognizable name eg Hunter Radiology, however often bears no relationship To a real person Or company
' msh_transmitting_entity text, - - could be the sending entity Or third party transmitter eg Medical Objects, Or the name Of a computer program generating the hl7
' fk_lu_message_display_style integer Not Null, - - display As Letter Or result style...
'    fk_branch integer,
'    fk_employee integer,
'    fk_person integer,
'    fk_lu_message_standard integer Not Null, - - hl7 Or pit
' exclude_ft_report boolean Default False, - - If True Then no Free text segments will be shown
' exclude_pit boolean Default False, - - If contains PIT segments If True these will Not be shown(often duplicated the hl7 data itself)
' abnormals_foreground_color integer Default 16711680,
'    abnormals_background_color integer Default 16777215,
'    deleted boolean Default False,
'    CONSTRAINT sending_entities_pkey PRIMARY KEY(pk)
' )
' With (
'       OIDS = False
'    );
'    ALTER TABLE documents.sending_entities
'    OWNER To richard;
'    GRANT ALL On TABLE documents.sending_entities To richard;
'    GRANT ALL On TABLE documents.sending_entities To easygp;
'    GRANT ALL On TABLE documents.sending_entities To staff;
'    COMMENT On TABLE documents.sending_entities
'    Is 'Sending entities and the parameters to define how to handle incoming hl7 messages 
'       On a per - provider basis.Note these messages can be In form Of various hl7 standards Or old style PIT(sequential numbered text lines eg 100, 110 120 etc This table
'    defines the file type hl7 Or pit, who Is Sending it, where To put it, which segments Of the message To exclude when displaying In Html ';
'    COMMENT On COLUMN documents.sending_entities.fk_lu_request_type Is 'The type of provider eg pathology provider, radiology provider';
'       COMMENT On COLUMN documents.sending_entities.msh_sending_entity Is 'the entity sending, could be unintelligable eg a NATA/number or a recognizable name eg Hunter Radiology, however often bears no relationship to a real person or company';
'       COMMENT On COLUMN documents.sending_entities.msh_transmitting_entity Is 'could be the sending entity or third party transmitter eg Medical Objects, or the name of a computer program generating the hl7';
'       COMMENT On COLUMN documents.sending_entities.fk_lu_message_display_style Is 'display as letter or result style
'       - Public Const Document_Display_As_Letter As Integer = 1 
'    - Public Const Document_Display_As_Result As Integer = 2
'    
'    Note: though this attribute Is Kept For Each document In document.documents
'    at the Time the document Is Signed off by the user,
'       we need To know what the Default display type Is For Each message sender -
'       defaults To 1 = letter, because, though pathology companies are far more
'    common, they will have been set To display As A result In the configuration Of
'    message senders.Scanned documents however will Not by Default , so we assume
'    (sometimes wrongly)that they are usually letters
'    ';
'    COMMENT On COLUMN documents.sending_entities.fk_lu_message_standard Is 'hl7 or pit';
'       COMMENT On COLUMN documents.sending_entities.exclude_ft_report Is 'if true then no free text segments will be shown';
'       COMMENT On COLUMN documents.sending_entities.exclude_pit Is 'if contains PIT segments if true these will not be shown (often duplicated the hl7 data itself)';
'    
'   originator text,
'   originator_reference text,
'   comment_on_document text, - - additional comment e.g NAD etc
' COMMENT On COLUMN documents.documents.comment_on_document Is 'additional comment e.g NAD etc';
' COMMENT On COLUMN documents.documents.staff_intended_for_unknown Is 'Sometimes despite all efforts it is not possible to determine from the hl7 who the message was
'  intended for.In this situation EasyGP has a Default staff member who Is Allocated the
'  orphaned messages.If so, Then this field will be True
'  If this Is Sorted out, Then this field will be re - set To False the fk_staff_destination set
'  To the correct fk_staff, however these changes will be logged ';
' COMMENT On COLUMN documents.documents.fk_lu_display_as Is 'How to display the document 1 as a result 2 as a letter';
' COMMENT On COLUMN documents.documents.fk_lu_request_type Is ' - key to clin_requests.lu_request_type table which contains the types
'     Of requests e.g Pathology Radiology Vascular. 
'   - note this field over - rides the 
'    fk_lu_request_type Of a given documents.sending_entities.fk_lu_request_type
'    which Is There To aid FDocumentMetadata guess the likely type Of request For
'    a given sender Of messages, but may Not be correct all the Time ';
' 
Public Sub Temp1()

   Dim hfile As File
   Dim destFile As File
   Dim sfile As String = "/home/richard/Downloads/pregdat/pregcatdata_AU.txt" 
   Dim sOneline As String
   Dim icounter As Integer
   Dim pregdata As CRow
   Dim alldata As New Collection
   Dim bits As String[]
   Dim sql As String
   Dim R As Result
   Dim iatccount As Integer
   
   Try hfile = Open sfile For Input 
   While Not Eof(hfile)
      Line Input #hfile, sOneline
      bits = Split(sOneline, "|")
      R = modDBConnect.exec_query("Select * from drugs.atc where atcname ILIKE $$" & bits[0] & "$$")
      pregdata = New CRow
      If R.count Then
         pregdata!atccode = R!atccode 
         Inc iatccount  
      End If
      Try pregdata!generic = bits[0]
      Try pregdata!fk_lu_pregnancy_category = bits[1]
      Try pregdata!safety_information = bits[2]
      Try pregdata!class1 = bits[3]
      Try pregdata!class2 = bits[4]
      Try pregdata!class3 = bits[5]
      pregdata.Save("drugs.link_generic_pregcat_safety_info", "fk_link")
      alldata.Add(pregdata, alldata.count)
      Inc icounter
      Print icounter
   Wend
   Print alldata, icounter, iatccount
   modDBConnect.CommitTrans
   
End

Public Sub Medibase_Import_Letters()
   
   '----------------------------------------------------
   'Expected directory structure
   'PATIENTNAME/PROGRESSNOTES
   '  file.html
   ' file.json which contains
   '{"fk_branch": null, "deleted": false, "date_referral": "2006-02-28",
   ' "fk_person": Null, "tag": "TO: Physiotherapist, RE: Letter to specialist",
   '  "body_html": "", "include_careplan": False, "fk_progressnote": Null,
   '   "letter_html": "", "fk_address": Null, "fk_pasthistory": Null, 
   '   "include_healthsummary": False, "fk_type": 11, "copyto": "", 
   '   "fk_consult": Null, "fk_employee": Null}
   ' CREATE TABLE clin_referrals.referrals
   ' (
   '  x  pk serial NOT NULL,
   '  x  fk_consult integer NOT NULL, -- key to the main clin_consult.consult table which is the master table of the database
   '  x  date_referral date NOT NULL, -- Date written on the referral, may not be the consult_date
   '  x  fk_branch integer, -- if not null key to contacts.data_branches - points to organisation and address of the organisation
   '  x  fk_employee integer, -- if not null key to contacts.data_employees table - points to employee of an organisation
   '  x  fk_person integer, -- if not null key to contacts.data_persons table ie person referred to
   '  x  fk_address integer, -- key to contacts.data_addresses, if not null is the address of the person. not the address of the organisation/branch/employee obtained through the other keys
   '  x fk_type integer, -- key to lu_referral_type table ie type of referral e.g opinion or management
   '  x letter_html text NOT NULL, -- html which is the letter itself
   '  x tag text, -- A description of the letter eg 'heart failure'
   '  x deleted boolean DEFAULT false,
   '  x body_html text, -- Contains the html of the body of the letter
   '  x fk_pasthistory integer DEFAULT 0, -- if not 0 = general notes, then is the key to clin_history.past_history table
   '  x fk_progressnote integer, -- key to clin_consult.progress notes table - points to the progress note of a letter during the...
   '  x include_careplan boolean DEFAULT false,
   '  x include_healthsummary boolean DEFAULT false,
   '  x copyto text, -- a Pipe delimated list of entities receiving copies...
   '  x fk_lu_urgency integer DEFAULT 1,
   '  x letter_hl7 text, -- the hl7 of the letter ** minus ** the inclusions OBX segments...
   '   CONSTRAINT referrals_pkey PRIMARY KEY (pk )
   ' )
   ' WITH (
   '   OIDS=FALSE
   ' );
   
   '-----------------------------------------------------
   Dim sFile As String
   Dim sDir As String
   Dim sRootdir As String
   Dim fk_patient As Integer
   Dim sNotesDir As String
   Dim sPatientDir As String
   Dim MetaData As Collection
   Dim x As Integer
   Dim bits As String[]
   Dim hfile As File
   Dim sOneLine As String
   Dim fk_staff As Integer
   Dim consult As CRow
   Dim Referral As CRow
   Dim datebits As String[]
   Dim timebits As String[]
   Dim metadata_filename_path As String
   Dim html_filename_path As String 
   Dim letter_html As String 
   Dim charpos As Integer
   Dim sString As String
   Dim bpString As String
   Dim LeftString As String
   Dim RightString As String
   Dim iPatientCount As Integer  
   
   lblImport.text = "Importing Letters"
   lblProgress.text = ""
   rejected_records = New Collection
   sRootdir = Trim(txtImportDirectory.text) ' &/ "MEDIBASE_EXPORT/"
   If IsDir(sRootdir) Then                             'eg "/home/user/MEDIBASE_EXPORT/"
      For Each sFile In Dir(sRootdir)                 
         If IsDir(sRootdir &/ Sfile) Then             
            sPatientDir = sFile
            fk_patient = modImportDBI.Patient_Get_pk_Using_fk_Legacy(sPatientDir)
            For Each sFile In Dir(sRootdir &/ sPatientDir)
               If sFile = "LETTERS" Then 
                  x = 0 
                  For Each sFile In Dir(sRootdir &/ sPatientDir &/ sNotesDir &/ "LETTERS")
                     If File.Ext(sRootdir &/ sPatientDir &/ sNotesDir &/ sFile) = "json" Then
                        MetaData = New Collection 
                        metadata_filename_path = sRootdir &/ sPatientDir &/ sNotesDir &/ "LETTERS" &/ sFile
                        hFile = Open metadata_filename_path For Read
                        While Not Eof(hFile)
                           Line Input #hFile, sOneLine
                        Wend  
                        Close #hfile
                        MetaData = JSON.Decode(sOneline)
                        html_filename_path = Replace(metadata_filename_path, ".json", ".html")
                        hFile = Open html_filename_path For Read
                        letter_html = ""
                        While Not Eof(hFile)
                           Line Input #hFile, sOneLine
                           letter_html &= sOneLine
                        Wend  
                        Close #hfile
                        '------------------------------------------------------------------------------------------
                        'Ok, massage the notes a little, first correct the formatting, leaving headings on one line
                        '------------------------------------------------------------------------------------------
                        fk_staff = modImportDBI.Staff_Get_Using_Firstname_Lastname(metadata)
                        datebits = Split(MetaData!date_referral, "-")
                        timebits = Split(MetaData!time, ":")
                        consult = New CRow 
                        consult!consult_date = Make_Date_time(datebits, timebits)
                        consult!fk_patient = fk_patient
                        consult!fk_staff = modDBConnect.currentUser!fk_staff
                        consult!fk_type = const.consult_type_at_Surgery
                        consult!summary = "Imported referral letter from MediBase" & Format(Now, "dd/mm/yyyy")
                        consult.Save("clin_consult.consult", "fk_consult")
                        Referral = New CRow
                        Referral!fk_consult = consult!fk_consult
                        Referral!fk_branch = modDBConnect.currentUser!fk_branch   
                        Referral!date_referral = metadata!date_referral
                        Referral!fk_type = const.ReferralType_OpinionAndManagement 'metadata!fk_type
                        Referral!letter_html = letter_html
                        Referral!tag = metadata!tag
                        Referral!body_html = metadata!body_html
                        Referral.Save("clin_referrals.referrals", "fk_referral")
                        modDBConnect.CommitTrans() 
                     Endif
                     Inc x 
                  Next
               End If
            Next
         Endif
         Inc iPatientCount
         Print iPatientCount
         lblProgress.text = "Total patients with imported letters:" & Str(iPatientCount)
         Wait
      Next
   End If
   modDBConnect.CommitTrans() 
   If rejected_records.count Then   
      hFile = Open sRootdir &/ "referral_letters_rejected.txt" For Write Create
      For x = 0 To rejected_records.count - 1
         Print #hfile, rejected_records[x]
      Next
      Close #hfile
      Message.Info("Some records could not be processed.\n\nA list may be found in this file:\n\n" & sRootdir &/ "progress_notes_rejected.txt")
   End If   
   
End
'CLEARING THE DATABASE FOR PREVIOUSLY IMPORTED DATA JUST FOR RICHARD TERRY
' Delete from  clin_consult.consult where "summary" ILIKE 'Past History Imported';
' Delete from clin_history.past_history;
' ALTER SEQUENCE clin_history.past_history_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' Delete from clin_history.team_care_members;
' ALTER SEQUENCE clin_history.team_care_members_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' Delete from clin_history.care_plan_components;
' ALTER SEQUENCE clin_history.care_plan_components_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' Delete from clin_history.care_plan_components_due;
' ALTER SEQUENCE clin_history.care_plan_components_due_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' Delete from clin_history.family_conditions;
' ALTER SEQUENCE clin_history.family_conditions_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' Delete from clin_history.family_links;
' ALTER SEQUENCE clin_history.family_links_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' Delete from clin_history.family_members;
' ALTER SEQUENCE clin_history.family_members_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' Delete from  clin_history.lu_exposures;
' ALTER SEQUENCE clin_history.lu_exposures_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' Delete from  clin_history.occupational_history;
' ALTER SEQUENCE clin_history.occupational_history_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' delete from clin_history.occupations_exposures;
' ALTER SEQUENCE clin_history.occupations_exposures_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' delete from clin_history.lu_careplan_components;
' ALTER SEQUENCE clin_history.lu_careplan_components_pk_seq
'     INCREMENT 1  MINVALUE 1
'     MAXVALUE 9223372036854775807  RESTART 1
'     CACHE 1  NO CYCLE;
' 
' --1;3389 = fk_consults both owned by test_patient
' --2;48015
' 
' --select * from clin_consult.consult where pk=127
' --select distinct (fk_consult) from clin_history.past_history
' 
