' Gambas class file
Private patients As Collection 
Private patient As Collection 
Private surname As Integer = 0
Private firstname As Integer = 1
Private birthdate As Integer = 2
Private social_history As Integer = 3
Private sLineInput As String
Private currentconsult As CConsult
Private import_dir As String = "/home/richard/easygp/import/" 'FIXME
Private Errorfile As File
Private hfile As File
Private FICPC As FICPCBrowser

Public Sub form_Open()
   
   init()
   
End

Public Sub init()

   Try Settings_Load()
   tlHelp.text = "<B>Importing Clinical Data</B><P> "
   "<P>You may now import clinical data from a legacy database.</P>  "
   "<P>The exent to which this is possible varies between systems. </P>" 
   "One of the problems with legacy medical record systems "
   "is that the database structure is not "
   "properly normalised, so that it may not be possible to import as "
   "much as you would like.</p>" 
   cmbMedicalProgram.Add("DrsDesk")
   cmbMedicalProgram.Add("Medical Director V2")
   cmbMedicalProgram.Add("Medical Director V3")
   cmbMedicalProgram.Add("Best Practice") 
   cmbMedicalProgram.Add("Profile")
   cmbMedicalProgram.Add("Genie")
   cmbMedicalProgram.Add("Medical Spectrum")
   txtPastHistoryPath.text = "/home/richard/easygp/import/Exported_PastHistory_small.txt"

End

Public Sub SliderFont_Change()

   tlHelp.Font.size = sliderFont.Value
   tlHelp.Font.size = sliderFont.Value
   
End

Public Sub Settings_Save()
   
   Settings["Legacy Data Import/HSplit_ImportLegacy.Layout"] = HSplit_ImportLegacy.Layout
   Settings["Legacy Data Import/help_font"] = SliderFont.value
   Settings["Legacy Data Import/VSplit_Legacy.Layout"] = VSplit_Legacy.layout
   Settings["Legacy Data Import/HSplit_Legacy.layout"] = HSplit_Legacy.layout
   
End

Private Sub Settings_Load()
   
   Try SliderFont.value = Settings["Legacy Data Import/help_font", 9] 
   Try HSplit_ImportLegacy.Layout = Settings["Legacy Data Import/HSplit_ImportLegacy.Layout"]
   Try VSplit_Legacy.layout = Settings["Legacy Data Import/VSplit_Legacy.Layout"]
   Try HSplit_Legacy.layout = Settings["Legacy Data Import/HSplit_Legacy.Layout"]
   
End

Public Sub chkLegacyData_Click()
   
   '-------------------------------------------------------------------
   'User has checked a box, wants to load legacy data for this segment
   'Search for the children of the Hbox the checkbox is in, when find
   'the only other Hbox which contains the toolbutton, enable or
   'disable the toolbutton according to whether the checkbox is checked
   '-------------------------------------------------------------------
   Dim hCtrl As Control
   Dim hCtrl1 As Control
   Dim aBox As Hbox
   Dim tb As Toolbutton
   Dim aTextBox As Textbox

   For Each hCtrl In Last.parent.children
      If hctrl Is Hbox Then
         Print "found the parent box of the toolbutton"
         aBox = hctrl
         Break
      End If
   Next
   For Each hCtrl In aBox.Children
      If hctrl Is Toolbutton Then
         Print "found the toolbutton"
         tb = hctrl
         tb.Enabled = Last.value
         '  Print "the value was", Last.value
         If Last.value = False Then
            For Each hCtrl1 In Last.parent.children
               If hCtrl1 Is TextBox Then
                  aTextbox = hCtrl1
                  aTextbox.text = "" 
               End If
            Next
         End If        
      End If
   Next
   
End

Public Sub tbSelectlegacyFile_Click()
   '---------------------------------------------
   'Select a file to import demographic data from
   '---------------------------------------------

   Dim hfile As File
   Dim sFilename As String
   Dim sLineInput As String
   Dim hCtrl As Control
   Dim aTextbox As Textbox
   Dim x As Integer
   'Dialog.Path = EasyGP.dir_root & "import/"
   '------------------------------
   'No file to process, then leave
   '------------------------------
   If Dialog.OpenFile() Then Return
   '-----------------------------------------
   'file to process, then put its name in the
   'corresponding textbox on the screen
   '-----------------------------------------
   For Each hctrl In Last.parent.parent.children
      If hctrl Is Textbox Then
         aTextbox = hctrl
         aTextbox.text = Dialog.Path
         ' tbImportExport.Enabled = True
         Break
      End If
   Next

End

Public Sub txtLegacyImportPath_LostFocus()
   
   Last.pos = 1
   
End

Public Sub SocialHistory_Import()
   '--------------------------------------------------------------
   'Imports the patients social history initially only DrsDesk
   'The DrsDesk social history came from a multi-line text control
   'so sometimes users inserted a CR by mistake.
   'Due to the social history text containing internal CR's
   'I've stuck a field on the end of the import data |end, so
   'that where this code splits a line in the middle of a 
   'social history field, I can detect and repair it
   '--------------------------------------------------------------

   Dim $Result As Result
   Dim sql As String
   Dim cons As CConsult
   Dim sfilename As String 
   Dim Errorfile As File
   Dim bits As String[]
   Dim skipcode As Boolean
   Dim x As Integer
   Dim y As Integer
   Dim missingpatients As Integer
   Dim bError As Boolean
   Dim badfilename As Integer
   Dim sFileError As String
   Dim anError As Error
   Dim bLineComplete As Boolean
   Dim sIncompleteLine As String
   Dim ICPCTerm As Collection 
   Dim SH As Collection 
   Dim Errorcount As Integer
   'open an error file to log errors
   
   modDBConnect.BeginTrans()
   patients = New Collection 
   '  ErrorFile = Open import_dir & "/socialhistory_import_errors.txt" For Write Create
   '-------------------------------------------------
   'Insist on at least some sort of attempt at a name
   '-------------------------------------------------
   Sfilename = Trim(txtSocialHistoryPath.text)
   If sFilename = "" Then 
      txtSocialHistoryPath.SetFocus()
      Return
   End If
   '------------------------------------------------------------------
   'Attempt to open the designated file
   'If fail, given an appropriate understandable error message and exit
   '-------------------------------------------------------------------
   Try hfile = Open sfilename For Input
   If Error Then
      sFileError = File_IO_Describe_Error(Error.code)
      Message.Warning("Unable to open " & sFilename & "\n\n" & sFileError)
      Return
   End If
   '-------------------------------------------------------------------
   'So far so good - hourglass to user to indicate we are go for import
   '-------------------------------------------------------------------
   Inc Application.Busy
   lvDataImportProgressMessages.Clear()
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Starting social history import..............")
   'Patients = New collection
   '  While Not Eof(hfile)
   '------------------------------------------ 
   'Input each line and split at the delimeter
   '------------------------------------------
   '  Line Input #hfile, sLineInput 
   '    Print sLineInput 
   '    Inc x
   '    If x = 10 Then Return
   '  Wend
   While Not Eof(hfile)
      '------------------------------------------ 
      'Input each line and split at the delimeter
      'The data in DrsDesk is "dirty", there are 
      'carriage returns randomly in the text
      '------------------------------------------
      bLineComplete = False      'assume their is an internal CR to muck things up
      Line Input #hfile, sLineInput                'read single line gb.unix as default
      sIncompleteLine = sLineInput                 'use a copy
      Do Until Right(sIncompleteLine, 4) = "|end"  'does it have an ending
         Line Input #hfile, sLineInput              'No, then get the next line
         sIncompleteLine &= sLineInput          'and concatenate for re-testing
      Loop
      sLineInput = sIncompleteLine                 'line has an ending, keep going.
      bits = Split(sLineInput, "|")
      '----------------------------------------------------------
      'Create a new patient object add to the patients collection
      '----------------------------------------------------------
      patient = New Collection
      patient!firstname = bits[firstname]
      patient!surname = bits[surname]
      patient!birthdate = Val(bits[birthdate])
      If bits[firstname] = "" Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no firstname:" & patient!firstname & " " & patient!surname)
         bError = True
      End If
      If bits[surname] = "" Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no surname:" & patient!firstname & " " & patient!surname)
         bError = True
      End If
      If Year(patient!birthdate) = 0 Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no birthdate:" & patient!firstname & " " & patient!surname)
         Wait
         Inc Errorcount
         patient!birthdate = CDate("01/01/1901")
         Wait
         Inc Errorcount
         bError = True
      End If
      patients.Add(patient, patients.count)
      '--------------------------------------------------- 
      'Now match that patient to the demographic database
      '--------------------------------------------------- 
      sql = "Select * from contacts.vwPatients where "
      sql &= "firstname ILIKE $$" & patient!firstname & "$$ "
      sql &= " AND surname ILIKE $$" & patient!surname & "$$ "
      sql &= " AND birthdate ='" & Format(patient!birthdate, "dd/mm/yyyy") & "'"
      $Result = modDBConnect.exec_query(sql)
      If $Result.count = 1 Then
         patient!fk_patient = $Result!fk_patient
         lblImporting2.text = "Importing data for" & patient!firstname & " " & patient!surname 
         Wait
         '--------------------------------------------------
         'Ok we have a patient, so save their social history
         'Should we worry about the original data of entry
         'if yes, then add it later, for now, just use today
         'create a consult and retrieve pk_consult
         'necessary because every table linked to consult
         'fixme later: use only a single pk_consult for an
         'entire patients imported data
         '--------------------------------------------------
         '------------------------------------
         'class cSocialHistory
         '
         ' Public pk As Integer
         ' Public fk_consult As Integer
         ' Public history As String
         ' Public data_changed As String
         ' Public pk_progressnote As Integer   
         ' Public responsible_person As String
         '-------------------------------------
         
         currentconsult = New CConsult(patient)
         currentconsult.Set(const.ConsultType_DataImport, "Social History Imported")
         SH = New Collection
         SH!fk_consult = currentconsult.GetPK()
         SH!history = bits[social_history]
         
         SH!fk_socialhistory = modDBConnect.insert("clin_history.social_history", SH)
         Print "inserted"   
      Else
         If $Result.count > 1 Then
            Message.info("More than 1 patient found with same names and dob")
            lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "duplicate name:" & patient!firstname & " " & patient!surname)
            Inc MissingPatients
            Wait
         End If
         If $Result.count = 0 Then
            lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Not in Demographic Database:" & patient!firstname & " " & patient!surname)
            Wait
            Inc MissingPatients
         End If
      End If
      Inc x 
   Wend
   modDBConnect.CommitTrans()
   
   '  lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Import completed")
   '  lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "We imported " & Str(patients.count) & " patients")
   ' lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(missingpatients) & "missing or duplicated patients")
   ''
   
   Dec Application.busy

End

Public Sub PastHistory_Import()
   '--------------------------------------------------------------
   ' Imports the patients past history initially only DrsDesk
   ' Adams|George|20/12/1925 0:00:00|M|289|1|35|7|Deafness||0|102008601|1960|0|0|0|1|0
   ' surname
   ' firstname
   ' birthdate
   ' sex
   ' ph_id
   ' active flag 0=not 1 = yes
   ' age_onset
   ' age_onset_units eg 7 = year 5 = week, 6 = month
   ' condition
   ' comment
   ' side body 0, 1=left, 2= right 3 = both
   ' ozcode
   ' date_onset
   ' operation
   ' cause death
   ' confidential
   ' significant
   ' deleted
   '--------------------------------------------------------------

   Dim $Result As Result
   Dim sql As String
   Dim LearntTerms As Result
   Dim cons As CConsult
   Dim sfilename As String 
   Dim unmatchables As New Collection
   Dim Unmatchable As Collection 
   ' Dim sex As Integer = 3
   'Dim ph_id As Integer = 4
   Dim active As Integer = 3
   Dim age_onset As Integer = 4
   Dim age_onset_units As Integer = 5
   Dim condition As Integer = 6
   Dim comment As Integer = 7
   Dim lateralisation As Integer = 10
   Dim ozcode As Integer = 11
   Dim date_onset As Integer = 9
   Dim operation As Integer = 10
   Dim cause_death As Integer = 11
   Dim confidential As Integer = 12
   Dim significant As Integer = 13
   Dim Deleted As Integer = 13
   Dim Errorfile As File
   Dim bits As String[]
   Dim vwTerms As Collection 
   Dim skipcode As Boolean
   Dim x As Integer
   Dim y As Integer
   Dim missingpatients As Integer
   Dim bError As Boolean
   Dim badfilename As Integer
   Dim learntTerm As Collection
   Dim iTemporaryProblemKey As Integer
   Dim sFileError As String
   Dim anError As Error
   Dim bLineComplete As Boolean
   Dim sIncompleteLine As String
   Dim past_history_item_count As Integer 
   Dim sLastPatient As String
   Dim scurrentPatient As String
   Dim bValidPatient As Boolean
   Dim PH As Collection 
   Dim PastHistory As Collection 'of all PH
   Dim a_term As Collection 
   Dim icpc_terms As Collection
   Dim icd10_terms As Collection
   
   modDBConnect.BeginTrans()
   
   icpc_terms = modDBConnect.exec_query_collection("Select * from coding.icpc2_terms")
   icd10_terms = modDBConnect.exec_query_collection("Select code as pk_code, term  from coding.lu_icd10")
   sql = ""
   "SELECT distinct"
   "  icpc2_terms.term as pk_view,"
   "  icpc2_terms.term, "
   "  icpc2_terms.term_code, "
   "  icpc2_terms.icpc_code, "
   "  icpc2_drsdesk_term_mapper.drsdesk_free_text "
   "FROM "
   "  coding.icpc2_terms, "
   "  coding.icpc2_drsdesk_term_mapper "
   "WHERE "
   "  icpc2_drsdesk_term_mapper.fk_term = icpc2_terms.pk;"
   
   learntTerms = modDBConnect.exec_query(sql)  'Load mappable terms drsdesk to icpc
   ErrorFile = Open import_dir & "/pasthistory_import_errors.txt" For Write Create   'open an error file to log errors
   Sfilename = Trim(txtPastHistoryPath.text)                                         'Insist on at least some sort Of attempt at a name
   If sFilename = "" Then 
      txtPastHistoryPath.SetFocus()
      Return
   End If
   Try hfile = Open sfilename For Input                                              'Attempt to open the designated file
   If Error Then
      sFileError = File_IO_Describe_Error(Error.code)
      Message.Warning("Unable to open " & sFilename & "\n\n" & sFileError)
      
   End If
   Inc Application.Busy
   lvDataImportProgressMessages.Clear()
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Starting past history import..............")
   Patients = New Collection
   While Not Eof(hfile)
      '------------------------------------------------------------------------------------ 
      'Input each line and split at the delimeter the data in DrsDesk is "dirty", there are 
      'carriage returns randomly in the text
      '------------------------a_term!pk_code------------------------------------------------------------
      Line Input #hfile, sLineInput           
      bits = Split(sLineInput, "|")
      scurrentPatient = bits[firstname] & bits[surname] & bits[birthdate]
      If sLastPatient <> scurrentPatient Then
         '----------------------------------------------------------------
         'if line contains a new patient, then save any outstanding data
         'If past_history_item_count is > 0, then have data to save
         'And Then Create a New patient object
         '----------------------------------------------------------------
         If past_history_item_count Then
            For Each PH In PastHistory
               PH!fk_pasthistory = modPastHistoryDBI.Save(currentconsult, -1, PH)
            Next
            past_history_item_count = 0
            
         End If
         bValidPatient = False 
         patient = Patient_Identify(bits)
         If patient!fk_patient Then
            sLastPatient = bits[firstname] & bits[surname] & bits[birthdate]
            currentconsult = New CConsult(patient)
            currentconsult.Set(const.ConsultType_DataImport, "Past History Imported")
            bValidPatient = True
            PastHistory = New Collection 
         End If
      End If 
      
      '-----------------------------------------------------------------------------
      ' At this point probably got a valid patient, save each past history item
      ' 
      '   pk serial NOT NULL,
      '   fk_consult integer NOT NULL,
      '   age_onset integer NOT NULL,
      '   age_onset_units integer NOT NULL,
      '   description text NOT a_term!pk_codeNULL,
      '   fk_laterality integer DEFAULT 0,
      '   year_onset text NOT NULL,
      '   active boolean DEFAULT false,
      '   operation boolean DEFAULT false,
      '   cause_of_death boolean DEFAULT false,
      '   confidential boolean DEFAULT false,
      '   major boolean DEFAULT false,
      '   deleted boolean DEFAULT false,
      '   year_onset_uncertain boolean DEFAULT false,
      '   management_summary text DEFAULT ''::text,
      '   condition_summary text DEFAULT ''::text,
      '   risk_factor boolean DEFAULT false,
      '   fk_coding_system integer NOT NULL, -- key to coding.lu_coding_system containing name of coding system ...
      '   fk_code text,
      '   aim_of_plan text,
      '   fk_progressnote integer, -- foreign key to clin_consult.progressnotes table, used only during each consultation...
      '------------------------------------------ ----------------------------------------------  
      
      If bValidPatient Then
         
         Inc iTemporaryProblemKey
         PH = New Collection 
         PH!fk_consult = currentconsult.GetPK()
         ' PH!pk_pasthistory = iTemporaryProblemKey
         PH!age_onset = bits[age_onset]
         Select Case bits[age_onset_units]
            Case 5
               PH!age_onset_units = const.Units_week
            Case 6
               PH!age_onset_units = const.Units_month
            Case 7
               PH!age_onset_units = const.Units_year
         End Select
         PH!description = Trim(bits[condition])
         '-------------------------------------------------
         'Now try and match this health_issue with an icpc
         'natural_language_term. This is because I only
         'used natural language terms. There are around
         '4000/17000 terms in my database not equatable
         'believe it or not things like NIDDM/IDDM for
         'which ICPC has no equivalent.
         'if can, equate to pk
         'of coding.icpc2_terms, otherwise, when saved
         'the natural_language_term will be added as a 
         'J9900n term or popup an option to search
         '-------------------------------------------------
         '   sql = "Select * from coding.vwGenericTerms where term ILIKE $$" & Lower(PH!description) & "$$"
         ' sql &= "and fk_coding_system = " & const.coding_icpcPlus
         '  vwTerms = modDBConnect.exe Next c_query_collection(sql)
         '  sql = "Select *From coding.icpc2_terms "
         ' sql &= "WHERE Lower(natural_language_term) = $$"
         ' SQL &= Lower(PH!description) & "$$"
         ' $Result = modDBConnect.exec_query(sql)
         For Each a_term In icpc_terms
            If Lower(PH!description) = Lower(a_term!natural_language_term) Then
               Ph!fk_coding_system = const.coding_icpcPlus
               ph!fk_code = a_term!icpc_code & a_term!term_code
               Break
            End If
         Next
         If IsNull(PH!fk_code) Then
            For Each a_term In icd10_terms
               If Lower(PH!description) = Lower(a_term!term) Then
                  Ph!fk_coding_system = const.coding_icd10
                  ph!fk_code = a_term!pk_code
                  Break
               End If
            Next
         End If
         
         If IsNull(PH!fk_code) Then
            For Each LearntTerms
               If Trim(Lower(PH!description)) = Trim(Lower(LearntTerms!drsdesk_free_text)) Then
                  Ph!fk_coding_system = const.coding_icpcPlus
                  ph!fk_code = a_term!icpc_code & LearntTerms!term_code
                  Break
               End If
            Next
         End If
         If IsNull(PH!fk_code) Then             
            ' '-------------------------------------------
            ' 'We couldn't match the free text with an icpc
            ' 'natural language term, so, check if we have
            ' 're-allocated this one, if not popup a modal
            ' 'box to get the code.God this could take some
            ' 'time as there are nearly 4000 of these, so
            ' 'I should write these to the database.
            ' '---------------------------------------------
            '    Dec Application.Busy             
            '    FICPC = New FICPCBrowser
            '    FICPC.txtTermToImport.text = PH!description
            '    FICPC.txtSearch.SetFocus()
            '    FICPC.ShowModal()
            '    Inc Application.busy
            '    PH!fk_code = const.globalstring
            '    PH!fk_coding_system = const.coding_icpcPlus
            '    '-----------------------------------------------------
            '    'If user (me) did allocate a term, save for future use
            '    '-----------------------------------------------------
            '    If PH!fk_code Then
            '       sql = "INSERT INTO coding.icpc2_drsdesk_term_mapper("
            '              "fk_term, drsdesk_free_text) " 
            '              "VALUES ("
            '       sql &= PH!fk_code & ", $$"
            '       sql &= PH!description & "$$)"
            '       $Result = modDBConnect.exec_query(sql)
            '       modDBConnect.CommitTrans()
            '        sql = ""
            '     "SELECT distinct"
            '       "  icpc2_terms.term as pk_view,"
            '       "  icpc2_terms.term, "
            '       "  icpc2_terms.term_code, "
            '       "  icpc2_terms.icpc_code, "
            '       "  icpc2_drsdesk_term_mapper.drsdesk_free_text "
            '       "FROM "
            '       "  coding.icpc2_terms, "
            '       "  coding.icpc2_drsdesk_term_mapper "
            '       "WHERE "
            '       "  icpc2_drsdesk_term_mapper.fk_term = icpc2_terms.pk;"
            '       
            '     learntTerms = modDBConnect.exec_query(sql)  'Load mappable terms drsdesk to icpc
            '   
            '     Else
            '      Message.info("Not equated, will save as J term")
            '      PH!coded_health_issue.pk_term = 0
            '    End If
            
         Else 
            
            '  .fk_reason = modCodingDBI.Condition_Match_Exact(.description)
            PH!condition_summary = bits[comment]
            PH!fk_laterality = bits[lateralisation] 'same DrsDesk and EasyGP
            PH!year_onset = bits[date_onset]
            If bits[active] = 1 Then
               PH!active = True
            Else
               PH!active = False
            End If
            '.active = bits[active]
            PH!operation = bits[operation]
            PH!cause_of_death = bits[cause_death]
            PH!confidential = bits[confidential]
            '-------------------------------------
            'Now have to do some guessing, in Drs Desk things were either
            'inactive or active, now they can be major or significant or
            'a risk factor
            'fix me - put in some popup learning
            'for starters lets just make them major or inactive
            '-------------------------------------------------------------
            
            PastHistory.Add(PH, PastHistory.count)
            Inc past_history_item_count 'this will be 1 if the first item.(x(x
         End If     
         '  Else
         ' Print PH!description 
         '      unmatchables.Add(PH, unmatchables.count)      
         ' End If 
         Inc x
         Print x
         
      End If 
      
   Wend
   modDBConnect.CommitTrans()
   
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Import completed")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "We imported " & Str(patients.count) & " patients")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(missingpatients) & "missing or duplicated patients")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(x) & "terms matched")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str(unmatchables.count) & "terms not matched")
   Close #hfile
   Print "Unmatched:", unmatchables.count 
   hfile = Open "/home/richard/easygp/import/unmatched.txt" For Write Create
   For Each unmatchable In unmatchables
      Print #hfile, Lower(unmatchable!description)
   Next
   Close #hfile
   
   Dec Application.busy

End

Public Sub PastHistory_Import_PRIOR_25May10()
   '--------------------------------------------------------------
   ' Imports the patients past history initially only DrsDesk
   ' Adams|George|20/12/1925 0:00:00|M|289|1|35|7|Deafness||0|102008601|1960|0|0|0|1|0
   ' surname
   ' firstname
   ' birthdate
   ' sex
   ' ph_id
   ' active flag 0=not 1 = yes
   ' age_onset
   ' age_onset_units eg 7 = year 5 = week, 6 = month
   ' condition
   ' comment
   ' side body 0, 1=left, 2= right 3 = both
   ' ozcode
   ' date_onset
   ' operation Close #hfile
   ' cause death
   ' confidential
   ' significant
   ' deleted
   '--------------------------------------------------------------

   Dim $Result As Result
   Dim sql As String
   Dim LearntTerms As Collection
   Dim cons As CConsult
   Dim sfilename As String 
   ' Dim sex As Integer = 3
   'Dim ph_id As Integer = 4
   Dim active As Integer = 3
   Dim age_onset As Integer = 4
   Dim age_onset_units As Integer = 5
   Dim condition As Integer = 6
   Dim comment As Integer = 7
   Dim lateralisation As Integer = 10
   Dim ozcode As Integer = 11
   Dim date_onset As Integer = 9
   Dim operation As Integer = 10
   Dim cause_death As Integer = 11
   Dim confidential As Integer = 12
   Dim significant As Integer = 13
   Dim Deleted As Integer = 13
   Dim Errorfile As File
   Dim bits As String[]
   
   Dim skipcode As Boolean
   Dim x As Integer
   Dim y As Integer
   Dim missingpatients As Integer
   Dim bError As Boolean
   Dim badfilename As Integer
   Dim learntTerm As Collection
   Dim iTemporaryProblemKey As Integer
   Dim sFileError As String
   Dim anError As Error
   Dim bLineComplete As Boolean
   Dim sIncompleteLine As String
   Dim past_history_item_count As Integer 
   Dim sLastPatient As String
   Dim scurrentPatient As String
   Dim bValidPatient As Boolean
   Dim PH As Collection 
   Dim PastHistory As Collection 'of all PH
   
   modDBConnect.BeginTrans()
   sql = "SELECT * FROM coding.icpc2_drsdesk_term_mapper"
   learntTerms = modDBConnect.exec_query_collection(sql)                                'Load mappable terms drsdesk to icpc
   ErrorFile = Open import_dir & "/pasthistory_import_errors.txt" For Write Create   'open an error file to log errors
   Sfilename = Trim(txtPastHistoryPath.text)                                         'Insist on at least some sort Of attempt at a name
   If sFilename = "" Then 
      txtPastHistoryPath.SetFocus()
      Return
   End If
   Try hfile = Open sfilename For Input                                              'Attempt to open the designated file
   If Error Then
      sFileError = File_IO_Describe_Error(Error.code)
      Message.Warning("Unable to open " & sFilename & "\n\n" & sFileError)
      Return
   End If
   Inc Application.Busy
   lvDataImportProgressMessages.Clear()
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Starting past history import..............")
   Patients = New Collection
   While Not Eof(hfile)
      '------------------------------------------------------------------------------------ 
      'Input each line and split at the delimeter the data in DrsDesk is "dirty", there are 
      'carriage returns randomly in the text
      '------------------------------------------------------------------------------------
      Line Input #hfile, sLineInput           
      bits = Split(sLineInput, "|")
      scurrentPatient = bits[firstname] & bits[surname] & bits[birthdate]
      If sLastPatient <> scurrentPatient Then
         '----------------------------------------------------------------
         'if line contains a new patient, then save any outstanding data
         'If past_history_item_count is > 0, then have data to save
         'And Then Create a New patient object
         '----------------------------------------------------------------
         If past_history_item_count Then
            For Each PH In PastHistory
               PH!fk_pasthistory = modPastHistoryDBI.Save(currentconsult, -1, PH)
            Next
            past_history_item_count = 0
            
         End If
         bValidPatient = False 
         patient = Patient_Identify(bits)
         If patient.count Then
            sLastPatient = bits[firstname] & bits[surname] & bits[birthdate]
            currentconsult = New CConsult(patient)
            currentconsult.Set(const.ConsultType_DataImport, "Past History Imported")
            bValidPatient = True
            PastHistory = New Collection 
         End If
      End If 
      
      '-----------------------------------------------------------------------------
      ' At this point probably got a valid patient, save each past history item
      ' 
      '   pk serial NOT NULL,
      '   fk_consult integer NOT NULL,
      '   age_onset integer NOT NULL,
      '   age_onset_units integer NOT NULL,
      '   description text NOT NULL,
      '   fk_laterality integer DEFAULT 0,
      '   year_onset text NOT NULL,
      '   active boolean DEFAULT false,
      '   operation boolean DEFAULT false,
      '   cause_of_death boolean DEFAULT false,
      '   confidential boolean DEFAULT false,
      '   major boolean DEFAULT false,
      '   deleted boolean DEFAULT false,
      '   year_onset_uncertain boolean DEFAULT false,
      '   management_summary text DEFAULT ''::text,
      '   condition_summary text DEFAULT ''::text,
      '   risk_factor boolean DEFAULT false,
      '   fk_coding_system integer NOT NULL, -- key to coding.lu_coding_system containing name of coding system ...
      '   fk_code text,
      '   aim_of_plan text,
      '   fk_progressnote integer, -- foreign key to clin_consult.progressnotes table, used only during each consultation...
      '------------------------------------------ ----------------------------------------------  
      
      If bValidPatient Then
         
         Inc iTemporaryProblemKey
         PH = New Collection 
         PH!fk_consult = currentconsult.GetPK()
         ' PH!pk_pasthistory = iTemporaryProblemKey
         PH!age_onset = bits[age_onset]
         Select Case bits[age_onset_units]
            Case 5
               PH!age_onset_units = const.Units_week
            Case 6
               PH!age_onset_units = const.Units_month
            Case 7
               PH!age_onset_units = const.Units_year
         End Select
         PH!description = Trim(bits[condition])
         '-------------------------------------------------
         'Now try and match this health_issue with an icpc
         'natural_language_term. This is because I only
         'used natural language terms. There are around
         '4000/17000 terms in my database not equatable
         'believe it or not things like NIDDM/IDDM for
         'which ICPC has no equivalent.
         'if can, equate to pk
         'of coding.icpc2_terms, otherwise, when saved
         'the natural_language_term will be added as a 
         'J9900n term or popup an option to search
         '-------------------------------------------------
         '  PH!coded_health_issue = New cICPC2Term
         '  PH!coded_health_issue.natural_language_term = PH!description
         
         sql = "Select *From coding.icpc2_terms "
         sql &= "WHERE Lower(natural_language_term) = $$"
         SQL &= Lower(PH!description) & "$$"
         $Result = modDBConnect.exec_query(sql)
         If $Result.count Then
            
            PH!fk_coding_system = const.coding_icpcPlus
            PH!fk_code = $Result!pk
            
         Else
            '-------------------------------------------
            'We couldn't match the free text with an icpc
            'natural language term, so, check if we have
            're-allocated this one, if not popup a modal
            'box to get the code.God this could take some
            'time as there are nearly 4000 of these, so
            'I should write these to the database.
            '---------------------------------------------
            For Each learntTerm In LearntTerms
               If Lower(LearntTerm!drsdesk_free_text) = Lower(PH!description) Then
                  PH!fk_code = LearntTerm!fk_term
                  PH!fk_coding_system = const.coding_icpcPlus
                  Break
               End If
            Next
            '-------------------------------------------
            'If not already learnt, then popup dialog to 
            'allow user (me) to choose an equivalent
            '-------------------------------------------
            If Not PH!fk_code Then
               Dec Application.Busy             
               FICPC = New FICPCBrowser
               FICPC.txtTermToImport.text = PH!description
               FICPC.txtSearch.SetFocus()
               FICPC.ShowModal()
               Inc Application.busy
               PH!fk_code = const.globalstring
               PH!fk_coding_system = const.coding_icpcPlus
               '-----------------------------------------------------
               'If user (me) did allocate a term, save for future use
               '-----------------------------------------------------
               If PH!fk_code Then
                  sql = "INSERT INTO coding.icpc2_drsdesk_term_mapper("
                  "fk_term, drsdesk_free_text) " 
                  "VALUES ("
                  sql &= PH!fk_code & ", $$"
                  sql &= PH!description & "$$)"
                  $Result = modDBConnect.exec_query(sql)
                  modDBConnect.CommitTrans()
                  learntTerm = New Collection
                  LearntTerm!natural_language_term = PH!description
                  LearntTerm!pk_term = PH!fk_code
                  LearntTerms.Add(learntTerm, LearntTerms.count)
               Else
                  Message.info("Not equated, will save as J term")
                  PH!coded_health_issue.pk_term = 0
               End If
            End If
         End If
         
         '  .fk_reason = modCodingDBI.Condition_Match_Exact(.description)
         PH!condition_summary = bits[comment]
         PH!fk_laterality = bits[lateralisation] 'same DrsDesk and EasyGP
         PH!year_onset = bits[date_onset]
         If bits[active] = 1 Then
            PH!active = True
            ' Message.info(.health_issue & " is " & Str(bits[active]))
         Else
            PH!active = False
         End If
         '.active = bits[active]
         PH!operation = bits[operation]
         PH!cause_of_death = bits[cause_death]
         PH!confidential = bits[confidential]
         '-------------------------------------
         'Now have to do some guessing, in Drs Desk things were either
         'inactive or active, now they can be major or significant or
         'a risk factor
         'fix me - put in some popup learning
         'for starters lets just make them major or inactive
         '-------------------------------------------------------------
         
         PastHistory.Add(PH, PastHistory.count)
         Inc past_history_item_count 'this will be 1 if the first item.
         
      End If 
      Inc x
      Print x
   Wend
   modDBConnect.CommitTrans()
   
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Import completed")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "We imported " & Str(patients.count) & " patients")
   lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "there were" & Str$(missingpatients) & "missing or duplicated patients")
   
   Dec Application.busy

End

Public Sub Patient_Identify(bits As String[]) As Collection

   Dim sql As String 
   Dim $Result As Result 

   patient = New Collection
   patient!firstname = bits[firstname]
   patient!surname = bits[surname]
   patient!birthdate = Val(bits[birthdate])
   If bits[firstname] = "" Then
      lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no firstname:" & patient!firstname & " " & patient!surname)
      
   End If
   If bits[surname] = "" Then
      lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no surname:" & patient!firstname & " " & patient!surname)
      
   End If
   If Year(patient!birthdate) = 0 Then
      lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "no birthdate:" & patient!firstname & " " & patient!surname)
      Wait
      
      patient!birthdate = CDate("01/01/1901")
      Wait
      
   End If
   
   '--------------------------------------------------- 
   'Now match that patient to the demographic database
   '--------------------------------------------------- 
   sql = "Select * from contacts.vwPatients where "
   sql &= "firstname ILIKE $$" & patient!firstname & "$$ "
   sql &= " AND surname ILIKE $$" & patient!surname & "$$ "
   sql &= " AND birthdate ='" & Format(patient!birthdate, "dd/mm/yyyy") & "'"
   $Result = modDBConnect.exec_query(sql)
   If $Result.count = 1 Then
      patient!fk_patient = $Result!fk_patient
      '  lblImporting2.text = "Importing data for" & patient!firstname & " " & patient!surname 
      Wait
   Else
      If $Result.count > 1 Then
         Message.info("More than 1 patient found with same names and dob")
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "duplicate name:" & patient!firstname & " " & patient!surname)
         patient!fk_patient = 0
         Wait
      End If
      If $Result.count = 0 Then
         lvDataImportProgressMessages.Add(lvDataImportProgressMessages.count, "Not in Demographic Database:" & patient!firstname & " " & patient!surname)
         patient!fk_patient = 0
         Wait
         
      End If
   End If
   patients.Add(patient, patients.count)    
   Return patient

End

Public Sub Button1_Click()
   ' Try SocialHistory_Import()

   PastHistory_Import()
   
End

Public Function File_IO_Describe_Error(error_code As Integer) As String

   Dim sMsg As String

   Select Case error_code
         
      Case const.File_IOError_Out_of_memory 
         smsg = "Unable to open the file - out of memory"
      Case const.File_IOError_Access_Forbidden 
         sMsg = "The file could not be accessed, please check you have the appropriate file permissions"
      Case const.File_IOError_File_is_directory 
         sMsg = "The file you have attempted to open is a directory"
      Case const.File_IOError_File_Non_Existant 
         sMsg = "The file could not be found. Please check the name and path and try again"
      Case const.File_IOError_Device_Full 
         sMsg = "The disk you are trying to write to is full. To continue you should probably clean up your disk"
      Case const.File_IOError_System_Error
         sMsg = "Unkown system error"
   End Select
   Return sMsg

End 
